[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "COTAN V2.0 Datasets analysis",
    "section": "",
    "text": "Number\nData-set name\nTissue\nOrganism\nInitial cell number\nOriginal paper\nDatabase code\nCell number after cleaning\nsc Method\nLabelled\n\n\n\n\n1\nE14.5 Mouse Cortex Loo 2019\nBrain\nmm\n\n📖\nGSE123335\n\nDrop-seq\nNO\n\n\n2\nE13.5 Mouse Cortex Yuzwa 2017\nBrain\nmm\n\n📖\nGSE107122\n\nDrop-seq\nNO\n\n\n3\nE17.5 Mouse Cortex Yuzwa 2017\nBrain\nmm\n\n📖\nGSE107122\n\nDrop-seq\nNO\n\n\n4\nE13.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n5\nE14.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n6\nE15.0 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n7\nE15.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n8\nE17.0 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n9\nE17.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n10\nCD14+\nPBMC\nH.s.\n\n📖\nSRP073767\n\n10X\nNO"
  },
  {
    "objectID": "index.html#schematic-data-sets-information",
    "href": "index.html#schematic-data-sets-information",
    "title": "COTAN V2.0 Datasets analysis",
    "section": "",
    "text": "Number\nData-set name\nTissue\nOrganism\nInitial cell number\nOriginal paper\nDatabase code\nCell number after cleaning\nsc Method\nLabelled\n\n\n\n\n1\nE14.5 Mouse Cortex Loo 2019\nBrain\nmm\n\n📖\nGSE123335\n\nDrop-seq\nNO\n\n\n2\nE13.5 Mouse Cortex Yuzwa 2017\nBrain\nmm\n\n📖\nGSE107122\n\nDrop-seq\nNO\n\n\n3\nE17.5 Mouse Cortex Yuzwa 2017\nBrain\nmm\n\n📖\nGSE107122\n\nDrop-seq\nNO\n\n\n4\nE13.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n5\nE14.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n6\nE15.0 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n7\nE15.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n8\nE17.0 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n9\nE17.5 Forebrain La Manno 2021\nBrain\nmm\n\n📖\nPRJNA637987\n\n10X\nYes\n\n\n10\nCD14+\nPBMC\nH.s.\n\n📖\nSRP073767\n\n10X\nNO"
  },
  {
    "objectID": "geneExpressionAnalysisUniformClusters.html",
    "href": "geneExpressionAnalysisUniformClusters.html",
    "title": "Explorative analysis of gene expression",
    "section": "",
    "text": "#library(COTAN)\n#options(parallelly.fork.enable = TRUE)\n#library(Seurat)\n#library(monocle3)\n#library(reticulate)\nlibrary(ggplot2)\nlibrary(stringr)\nlibrary(dplyr)\n\ndirOut &lt;- \"Results/GeneExpressionExploration/\"\nif (!exists(dirOut)) {\n  dir.create(dirOut)\n}\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/SingleClusterRawData/\"\n\n\ndf &lt;- NA\nfor (dataSetName in list.files(dataSetDir)) {\n  print(dataSetName)\n  name &lt;- str_split(dataSetName,pattern = \"_\", simplify = T)[1]\n  cluster.name &lt;- str_split(name,pattern = \"e\", simplify = T)[1]\n  time.point &lt;- paste0(\"E\",str_split(name,pattern = \"e\", simplify = T)[2])\n  dataSet &lt;- readRDS(paste0(dataSetDir,dataSetName))\n  print(dim(dataSet))\n  message(dim(dataSet))\n  df.temp &lt;- as.data.frame(list(\"RowSums\"=rowSums(dataSet)))\n  df.temp$N.cells &lt;- dim(dataSet)[2]\n  df.temp$genes &lt;- rownames(df.temp)\n  df.temp$log10_exp &lt;- log10((df.temp$RowSums+1)/df.temp$N.cells)\n  df.temp$cluster &lt;- cluster.name\n  df.temp$time.point &lt;- time.point\n  \n  df &lt;- rbind(df,df.temp)\n  \n}\n\n[1] \"Cl184e13.5_ForebrainDorsalRawData.RDS\"\nNULL\n[1] \"Cl187e13.5_ForebrainDorsalRawData.RDS\"\n[1] 13972   334\n[1] \"Cl428e15.0_ForebrainDorsalRawData.RDS\"\n[1] 13857   318\n[1] \"Cl432e13.5_ForebrainDorsalRawData.RDS\"\n[1] 13972   536\n[1] \"Cl432e15.0_ForebrainDorsalRawData.RDS\"\n[1] 13857   586\n[1] \"Cl434e13.5_ForebrainDorsalRawData.RDS\"\n[1] 13972   326\n[1] \"Cl434e15.0_ForebrainDorsalRawData.RDS\"\n[1] 13857   273\n[1] \"Cl437e13.5_ForebrainDorsalRawData.RDS\"\n[1] 13972   259\n[1] \"Cl437e15.0_ForebrainDorsalRawData.RDS\"\n[1] 13857   258\n[1] \"Cl505e17.5_ForebrainDorsalRawData.RDS\"\n[1] 13971   203\n[1] \"Cl508e15.0_ForebrainDorsalRawData.RDS\"\n[1] 13857   397\n[1] \"Cl509e15.0_ForebrainDorsalRawData.RDS\"\n[1] 13857   402\n[1] \"Cl510e13.5_ForebrainDorsalRawData.RDS\"\n[1] 13972   248\n[1] \"Cl510e15.0_ForebrainDorsalRawData.RDS\"\n[1] 13857   402\n[1] \"Cl516e17.5_ForebrainDorsalRawData.RDS\"\n[1] 13971   297\n\n df &lt;- df[2:nrow(df),]\n\ndf$cl_time &lt;- paste0(df$cluster,\"_\",df$time.point)\n\n\nd_bg &lt;- df[,-5] \n\nggplot(df[df$time.point == \"E13.5\",], \n       aes(x = log10_exp, fill = cluster)) +\n  geom_histogram(data = d_bg, \n                 fill = \"grey\", alpha = .8,binwidth = 0.1/6) +\n  geom_histogram(colour = \"black\",binwidth = 0.1) +\n  facet_wrap(~ cluster) + ylim(0,2500)+\n  guides(fill = FALSE) +  # to remove the legend\n  theme_bw()  \n\n\n\n\n\nggplot(df[df$time.point == \"E15.0\",], \n       aes(x = log10_exp, fill = cluster)) +\n  geom_histogram(data = d_bg, \n                 fill = \"grey\", alpha = .8,binwidth = 0.1/6) +\n  geom_histogram(colour = \"black\",binwidth = 0.1) +\n  facet_wrap(~ cluster) + ylim(0,2500)+\n  guides(fill = FALSE) +  # to remove the legend\n  theme_bw()  \n\n\n\n\n\nggplot(df[df$time.point == \"E17.5\",], \n       aes(x = log10_exp, fill = cluster)) +\n  geom_histogram(data = d_bg, \n                 fill = \"grey\", alpha = .8,binwidth = 0.1/6) +\n  geom_histogram(colour = \"black\") +\n  facet_wrap(~ cluster) +ylim(0,2500)+\n  guides(fill = FALSE) +  # to remove the legend\n  theme_bw()  \n\n\n\n\n\nvenn &lt;- list(\"Cl184\" = df[df$log10_exp &gt; -1 & df$time.point == \"E13.5\" & df$cluster == \"Cl184\",]$genes,\n             \"Cl187\" = df[df$log10_exp &gt; -1 & df$time.point == \"E13.5\" & df$cluster == \"Cl187\",]$genes,\n             \"Cl432\" = df[df$log10_exp &gt; -1 & df$time.point == \"E13.5\" & df$cluster == \"Cl432\",]$genes,\n             \"Cl434\" = df[df$log10_exp &gt; -1 & df$time.point == \"E13.5\" & df$cluster == \"Cl434\",]$genes,\n             \"Cl437\" = df[df$log10_exp &gt; -1 & df$time.point == \"E13.5\" & df$cluster == \"Cl437\",]$genes,\n             \"Cl510\" = df[df$log10_exp &gt; -1 & df$time.point == \"E13.5\" & df$cluster == \"Cl510\",]$genes)\nlibrary(ggVennDiagram)\n\nggVennDiagram(\n  venn,\n  #fill_color = c(\"#0073C2FF\", \"#EFC000FF\", \"#868686FF\",\"#009E73\",\"#993E83\",\"#007310FF\"),\n  stroke_size = 0.5, set_name_size = 4\n  )+ scale_fill_distiller(palette = \"RdBu\")\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggVennDiagram_1.5.0 Matrix_1.6-3        dplyr_1.1.2        \n[4] stringr_1.5.0       ggplot2_3.4.2      \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3        cli_3.6.1          knitr_1.43         rlang_1.1.1       \n [5] xfun_0.39          stringi_1.8.1      generics_0.1.3     jsonlite_1.8.7    \n [9] labeling_0.4.2     glue_1.6.2         colorspace_2.1-0   htmltools_0.5.7   \n[13] scales_1.3.0       fansi_1.0.4        rmarkdown_2.24     grid_4.3.2        \n[17] evaluate_0.21      munsell_0.5.0      tibble_3.2.1       fastmap_1.1.1     \n[21] yaml_2.3.7         lifecycle_1.0.3    compiler_4.3.2     RColorBrewer_1.1-3\n[25] htmlwidgets_1.6.2  pkgconfig_2.0.3    rstudioapi_0.15.0  farver_2.1.1      \n[29] lattice_0.22-5     digest_0.6.33      R6_2.5.1           tidyselect_1.2.0  \n[33] utf8_1.2.3         pillar_1.9.0       magrittr_2.0.3     withr_2.5.0       \n[37] tools_4.3.2        gtable_0.3.3"
  },
  {
    "objectID": "geneCoexAnalysisE17.5MouseBrain.html",
    "href": "geneCoexAnalysisE17.5MouseBrain.html",
    "title": "Gene Correlation Analysis E17.5 Mouse Brain",
    "section": "",
    "text": "library(COTAN)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nTo compare the ability of COTAN to asses the real correlation between genes we define some pools of genes:\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n    c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\",\"Ntf3\",\"Rasgrf2\",\"Pvrl3\", \"Cux2\",\"Slc17a6\", \"Sema3c\",\"Thsd7a\", \"Sulf2\", \"Kcnk2\",\"Grik3\", \"Etv1\", \"Tle4\", \"Tmem200a\", \"Glra2\", \"Etv1\",\"Htr1f\", \"Sulf1\",\"Rxfp1\", \"Syt6\") \n  # From https://www.science.org/doi/10.1126/science.aam8999\n)"
  },
  {
    "objectID": "geneCoexAnalysisE17.5MouseBrain.html#cotan",
    "href": "geneCoexAnalysisE17.5MouseBrain.html#cotan",
    "title": "Gene Correlation Analysis E17.5 Mouse Brain",
    "section": "COTAN",
    "text": "COTAN\n\nobj &lt;- readRDS(\"Data/MouseCortexFromLoom/e17.5_ForebrainDorsal.cotan.RDS\")\n\n\nint.genes &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)[c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers) %in% getGenes(obj)]\n\n\ncoexMat.big &lt;- getGenesCoex(obj)[int.genes,int.genes]\n\ncoexMat &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))\n                        ),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(coexMat),\n        #width = ncol(coexMat)*unit(2.5, \"mm\"), \n        height = nrow(coexMat)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"COTAN coex\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nGDIPlot(obj,genes = genesList,GDIThreshold = 1.4)"
  },
  {
    "objectID": "geneCoexAnalysisE17.5MouseBrain.html#seurat-correlation",
    "href": "geneCoexAnalysisE17.5MouseBrain.html#seurat-correlation",
    "title": "Gene Correlation Analysis E17.5 Mouse Brain",
    "section": "Seurat correlation",
    "text": "Seurat correlation\n\nlibrary(dplyr)\nlibrary(Hmisc)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(Rfast)\nlibrary(parallel)\nlibrary(doParallel)\n\n\nsrat&lt;- CreateSeuratObject(counts = getRawData(obj), project = \"E17.5\", min.cells = 3, min.features = 200)\nsrat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(srat, pattern = \"^mt-\")\nsrat &lt;- NormalizeData(srat)\nsrat &lt;- FindVariableFeatures(srat, selection.method = \"vst\", nfeatures = 2000)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(srat)\nLabelPoints(plot = plot1, points = c(genesList$NPGs,genesList$PNGs,genesList$layers), repel = TRUE)\n\n\n\n\n\nLabelPoints(plot = plot1, points = c(genesList$hk), repel = TRUE)\n\n\n\n\n\nall.genes &lt;- rownames(srat)\nsrat &lt;- ScaleData(srat, features = all.genes)\nseurat.data &lt;-  GetAssayData(srat,layer = \"data\")\n\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsrat &lt;-  SCTransform(srat, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\nseurat.data = srat[[\"SCT\"]]@data\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\ndiag(seurat.data.cor) &lt;- 0\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")"
  },
  {
    "objectID": "geneCoexAnalysisE17.5MouseBrain.html#monocle",
    "href": "geneCoexAnalysisE17.5MouseBrain.html#monocle",
    "title": "Gene Correlation Analysis E17.5 Mouse Brain",
    "section": "Monocle",
    "text": "Monocle\n\nlibrary(monocle3)\n\n\ncds &lt;- new_cell_data_set(getRawData(obj),\n                         cell_metadata = getMetadataCells(obj),\n                         gene_metadata = getMetadataGenes(obj)\n                         )\ncds &lt;- preprocess_cds(cds, num_dim = 100)\n\nnormalized_counts &lt;- normalized_counts(cds)\n\n\nint.genes &lt;- rownames(normalized_counts)[rownames(normalized_counts) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(normalized_counts)[int.genes,])\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nmonocle.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(monocle.data.cor.big) &lt;- 0\n\nmonocle.data.cor &lt;- monocle.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(monocle.data.cor),\n        #width = ncol(monocle.corMat)*unit(2.5, \"mm\"), \n        height = nrow(monocle.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"monocle corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\n\nSys.time()\n\n[1] \"2024-03-10 16:23:05 CET\"\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n [1] stats4    parallel  grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n [5] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n [7] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n [9] matrixStats_1.2.0           Biobase_2.60.0             \n[11] BiocGenerics_0.46.0         doParallel_1.0.17          \n[13] iterators_1.0.14            foreach_1.5.2              \n[15] Rfast_2.1.0                 RcppParallel_5.1.7         \n[17] RcppZiggurat_0.1.6          Rcpp_1.0.11                \n[19] patchwork_1.2.0             Seurat_5.0.0               \n[21] SeuratObject_5.0.0          sp_2.1-1                   \n[23] Hmisc_5.1-0                 dplyr_1.1.2                \n[25] circlize_0.4.15             ComplexHeatmap_2.16.0      \n[27] COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] rpart_4.1.23              fastDummies_1.7.3        \n  [9] lifecycle_1.0.3           globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] backports_1.4.1           dendextend_1.17.1        \n [15] magrittr_2.0.3            plotly_4.10.2            \n [17] rmarkdown_2.24            yaml_2.3.7               \n [19] httpuv_1.6.11             glmGamPoi_1.12.2         \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.35.0         minqa_1.2.5              \n [27] cowplot_1.1.1             pbapply_1.7-2            \n [29] RColorBrewer_1.1-3        zlibbioc_1.46.0          \n [31] abind_1.4-5               Rtsne_0.16               \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] nnet_7.3-19               GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] terra_1.7-39              umap_0.2.10.0            \n [43] goftest_1.2-3             RSpectra_0.16-1          \n [45] spatstat.random_3.2-1     dqrng_0.3.0              \n [47] fitdistrplus_1.1-11       parallelly_1.36.0        \n [49] DelayedMatrixStats_1.22.5 leiden_0.4.3             \n [51] codetools_0.2-19          DelayedArray_0.26.7      \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              lme4_1.1-34              \n [57] ScaledMatrix_1.8.1        viridis_0.6.4            \n [59] base64enc_0.1-3           spatstat.explore_3.2-1   \n [61] jsonlite_1.8.7            GetoptLong_1.0.5         \n [63] Formula_1.2-5             ellipsis_0.3.2           \n [65] progressr_0.14.0          ggridges_0.5.4           \n [67] survival_3.5-7            tools_4.3.2              \n [69] ica_1.0-3                 glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] scattermore_1.2           Cairo_1.6-1              \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] utf8_1.2.3                tidyr_1.3.0              \n [91] generics_0.1.3            data.table_1.15.0        \n [93] httr_1.4.6                htmlwidgets_1.6.2        \n [95] S4Arrays_1.2.0            uwot_0.1.16              \n [97] pkgconfig_2.0.3           gtable_0.3.3             \n [99] lmtest_0.9-40             XVector_0.40.0           \n[101] htmltools_0.5.7           dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] checkmate_2.3.0           nlme_3.1-163             \n[113] zoo_1.8-12                GlobalOptions_0.1.2      \n[115] stringr_1.5.0             KernSmooth_2.23-22       \n[117] miniUI_0.1.1.1            foreign_0.8-86           \n[119] pillar_1.9.0              vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] BiocSingular_1.16.0       beachmat_2.16.0          \n[125] xtable_1.8-4              cluster_2.1.6            \n[127] htmlTable_2.4.1           evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              future.apply_1.11.0      \n[135] labeling_0.4.2            plyr_1.8.8               \n[137] stringi_1.8.1             viridisLite_0.4.2        \n[139] deldir_2.0-2              BiocParallel_1.34.2      \n[141] assertthat_0.2.1          munsell_0.5.0            \n[143] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[145] PCAtools_2.14.0           Matrix_1.6-3             \n[147] RcppHNSW_0.6.0            sparseMatrixStats_1.12.2 \n[149] future_1.33.0             ggplot2_3.4.2            \n[151] shiny_1.8.0               ROCR_1.0-11              \n[153] igraph_1.6.0"
  },
  {
    "objectID": "geneCoexAnalysisE13.5Yuzwa.html",
    "href": "geneCoexAnalysisE13.5Yuzwa.html",
    "title": "Gene Correlation Analysis E13.5",
    "section": "",
    "text": "library(COTAN)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nTo compare the ability of COTAN to asses the real correlation between genes we define some pools of genes:\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n     c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\",\"Ntf3\",\"Rasgrf2\",\"Pvrl3\", \"Cux2\",\"Slc17a6\", \"Sema3c\",\"Thsd7a\", \"Sulf2\", \"Kcnk2\",\"Grik3\", \"Etv1\", \"Tle4\", \"Tmem200a\", \"Glra2\", \"Etv1\",\"Htr1f\", \"Sulf1\",\"Rxfp1\", \"Syt6\") \n  # From https://www.science.org/doi/10.1126/science.aam8999\n)"
  },
  {
    "objectID": "geneCoexAnalysisE13.5Yuzwa.html#cotan",
    "href": "geneCoexAnalysisE13.5Yuzwa.html#cotan",
    "title": "Gene Correlation Analysis E13.5",
    "section": "COTAN",
    "text": "COTAN\n\nobj &lt;- readRDS(\"Data/Yuzwa_MouseCortex/CorticalCells_GSM2861511_E135.cotan.RDS\")\n\n\nint.genes &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)[c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers) %in% getGenes(obj)]\n\ncoexMat.big &lt;- getGenesCoex(obj)[int.genes,int.genes]\n\ncoexMat &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))\n                        ),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(coexMat),\n        #width = ncol(coexMat)*unit(2.5, \"mm\"), \n        height = nrow(coexMat)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"COTAN coex\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nGDIPlot(obj,genes = genesList,GDIThreshold = 1.4)"
  },
  {
    "objectID": "geneCoexAnalysisE13.5Yuzwa.html#seurat-correlation",
    "href": "geneCoexAnalysisE13.5Yuzwa.html#seurat-correlation",
    "title": "Gene Correlation Analysis E13.5",
    "section": "Seurat correlation",
    "text": "Seurat correlation\n\nlibrary(dplyr)\nlibrary(Hmisc)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(Rfast)\nlibrary(parallel)\nlibrary(doParallel)\n\n\nsrat&lt;- CreateSeuratObject(counts = getRawData(obj), project = \"E14.5\", min.cells = 3, min.features = 200)\nsrat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(srat, pattern = \"^mt-\")\nsrat &lt;- NormalizeData(srat)\nsrat &lt;- FindVariableFeatures(srat, selection.method = \"vst\", nfeatures = 2000)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(srat)\nLabelPoints(plot = plot1, points = c(genesList$NPGs,genesList$PNGs,genesList$layers), repel = TRUE)\n\n\n\n\n\nLabelPoints(plot = plot1, points = c(genesList$hk), repel = TRUE)\n\n\n\n\n\nall.genes &lt;- rownames(srat)\nsrat &lt;- ScaleData(srat, features = all.genes)\nseurat.data &lt;- GetAssayData(srat,layer = \"data\")\n\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsrat &lt;-  SCTransform(srat, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\nseurat.data = srat[[\"SCT\"]]@data\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\ndiag(seurat.data.cor) &lt;- 0\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")"
  },
  {
    "objectID": "geneCoexAnalysisE13.5Yuzwa.html#monocle",
    "href": "geneCoexAnalysisE13.5Yuzwa.html#monocle",
    "title": "Gene Correlation Analysis E13.5",
    "section": "Monocle",
    "text": "Monocle\n\nlibrary(monocle3)\n\n\ncds &lt;- new_cell_data_set(getRawData(obj),\n                         cell_metadata = getMetadataCells(obj),\n                         gene_metadata = getMetadataGenes(obj)\n                         )\ncds &lt;- preprocess_cds(cds, num_dim = 100)\n\nnormalized_counts &lt;- normalized_counts(cds)\n\n\nint.genes &lt;- rownames(normalized_counts)[rownames(normalized_counts) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(normalized_counts)[int.genes,])\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nmonocle.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(monocle.data.cor.big) &lt;- 0\n\nmonocle.data.cor &lt;- monocle.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(monocle.data.cor),\n        #width = ncol(monocle.corMat)*unit(2.5, \"mm\"), \n        height = nrow(monocle.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"monocle corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\n\nSys.time()\n\n[1] \"2024-03-10 16:11:30 CET\"\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n [1] stats4    parallel  grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n [5] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n [7] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n [9] matrixStats_1.2.0           Biobase_2.60.0             \n[11] BiocGenerics_0.46.0         doParallel_1.0.17          \n[13] iterators_1.0.14            foreach_1.5.2              \n[15] Rfast_2.1.0                 RcppParallel_5.1.7         \n[17] RcppZiggurat_0.1.6          Rcpp_1.0.11                \n[19] patchwork_1.2.0             Seurat_5.0.0               \n[21] SeuratObject_5.0.0          sp_2.1-1                   \n[23] Hmisc_5.1-0                 dplyr_1.1.2                \n[25] circlize_0.4.15             ComplexHeatmap_2.16.0      \n[27] COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] rpart_4.1.23              fastDummies_1.7.3        \n  [9] lifecycle_1.0.3           globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] backports_1.4.1           dendextend_1.17.1        \n [15] magrittr_2.0.3            plotly_4.10.2            \n [17] rmarkdown_2.24            yaml_2.3.7               \n [19] httpuv_1.6.11             glmGamPoi_1.12.2         \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.35.0         minqa_1.2.5              \n [27] cowplot_1.1.1             pbapply_1.7-2            \n [29] RColorBrewer_1.1-3        zlibbioc_1.46.0          \n [31] abind_1.4-5               Rtsne_0.16               \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] nnet_7.3-19               GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] terra_1.7-39              umap_0.2.10.0            \n [43] goftest_1.2-3             RSpectra_0.16-1          \n [45] spatstat.random_3.2-1     dqrng_0.3.0              \n [47] fitdistrplus_1.1-11       parallelly_1.36.0        \n [49] DelayedMatrixStats_1.22.5 leiden_0.4.3             \n [51] codetools_0.2-19          DelayedArray_0.26.7      \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              lme4_1.1-34              \n [57] ScaledMatrix_1.8.1        viridis_0.6.4            \n [59] base64enc_0.1-3           spatstat.explore_3.2-1   \n [61] jsonlite_1.8.7            GetoptLong_1.0.5         \n [63] Formula_1.2-5             ellipsis_0.3.2           \n [65] progressr_0.14.0          ggridges_0.5.4           \n [67] survival_3.5-7            tools_4.3.2              \n [69] ica_1.0-3                 glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] scattermore_1.2           Cairo_1.6-1              \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] utf8_1.2.3                tidyr_1.3.0              \n [91] generics_0.1.3            data.table_1.15.0        \n [93] httr_1.4.6                htmlwidgets_1.6.2        \n [95] S4Arrays_1.2.0            uwot_0.1.16              \n [97] pkgconfig_2.0.3           gtable_0.3.3             \n [99] lmtest_0.9-40             XVector_0.40.0           \n[101] htmltools_0.5.7           dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] checkmate_2.3.0           nlme_3.1-163             \n[113] zoo_1.8-12                GlobalOptions_0.1.2      \n[115] stringr_1.5.0             KernSmooth_2.23-22       \n[117] miniUI_0.1.1.1            foreign_0.8-86           \n[119] pillar_1.9.0              vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] BiocSingular_1.16.0       beachmat_2.16.0          \n[125] xtable_1.8-4              cluster_2.1.6            \n[127] htmlTable_2.4.1           evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              future.apply_1.11.0      \n[135] labeling_0.4.2            plyr_1.8.8               \n[137] stringi_1.8.1             viridisLite_0.4.2        \n[139] deldir_2.0-2              BiocParallel_1.34.2      \n[141] assertthat_0.2.1          munsell_0.5.0            \n[143] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[145] PCAtools_2.14.0           Matrix_1.6-3             \n[147] RcppHNSW_0.6.0            sparseMatrixStats_1.12.2 \n[149] future_1.33.0             ggplot2_3.4.2            \n[151] shiny_1.8.0               ROCR_1.0-11              \n[153] igraph_1.6.0"
  },
  {
    "objectID": "geneCoexAnalysisDataset1.html",
    "href": "geneCoexAnalysisDataset1.html",
    "title": "Gene Correlation Analysis E14.5 Mouse Cortex",
    "section": "",
    "text": "library(COTAN)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nTo compare the ability of COTAN to asses the real correlation between genes we define some pools of genes:\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n    c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\")\n)"
  },
  {
    "objectID": "geneCoexAnalysisDataset1.html#cotan",
    "href": "geneCoexAnalysisDataset1.html#cotan",
    "title": "Gene Correlation Analysis E14.5 Mouse Cortex",
    "section": "COTAN",
    "text": "COTAN\n\nobj &lt;- readRDS(\"Data/MouseCortex/MouseCortex_E14.5.cotan.RDS\")\n\n\ncoexMat.big &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers),c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)]\n\ncoexMat &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))\n                        ),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(coexMat),\n        #width = ncol(coexMat)*unit(2.5, \"mm\"), \n        height = nrow(coexMat)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"COTAN coex\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nGDIPlot(obj,genes = genesList,GDIThreshold = 1.4)"
  },
  {
    "objectID": "geneCoexAnalysisDataset1.html#seurat-correlation",
    "href": "geneCoexAnalysisDataset1.html#seurat-correlation",
    "title": "Gene Correlation Analysis E14.5 Mouse Cortex",
    "section": "Seurat correlation",
    "text": "Seurat correlation\n\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(Rfast)\nlibrary(parallel)\nlibrary(doParallel)\n\n\nsrat&lt;- CreateSeuratObject(counts = getRawData(obj), project = \"E14.5\", min.cells = 3, min.features = 200)\nsrat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(srat, pattern = \"^mt-\")\nsrat &lt;- NormalizeData(srat)\nsrat &lt;- FindVariableFeatures(srat, selection.method = \"vst\", nfeatures = 2000)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(srat)\nLabelPoints(plot = plot1, points = c(genesList$NPGs,genesList$PNGs,genesList$layers), repel = TRUE)\n\n\n\n\n\nLabelPoints(plot = plot1, points = c(genesList$hk), repel = TRUE)\n\n\n\n\n\nall.genes &lt;- rownames(srat)\nsrat &lt;- ScaleData(srat, features = all.genes)\nseurat.data = GetAssayData(srat,layer = \"data\")\n\n\nseurat.data.cor.big = cora(t(as.matrix(seurat.data)[c(genesList$NPGs,genesList$hk,genesList$PNGs, genesList$layers),]), large = T)\n\nrownames(seurat.data.cor.big) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)\ncolnames(seurat.data.cor.big) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs, genesList$layers)\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsrat &lt;-  SCTransform(srat, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\nseurat.data = srat[[\"SCT\"]]@data\nseurat.data.cor.big = cora(t(as.matrix(seurat.data)[c(genesList$NPGs,genesList$hk,genesList$PNGs, genesList$layers),]), large = T)\n\nrownames(seurat.data.cor.big) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)\ncolnames(seurat.data.cor.big) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs, genesList$layers)\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\ndiag(seurat.data.cor) &lt;- 0\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")"
  },
  {
    "objectID": "geneCoexAnalysisDataset1.html#monocle",
    "href": "geneCoexAnalysisDataset1.html#monocle",
    "title": "Gene Correlation Analysis E14.5 Mouse Cortex",
    "section": "Monocle",
    "text": "Monocle\n\nlibrary(monocle3)\n\n\ncds &lt;- new_cell_data_set(getRawData(obj),\n                         cell_metadata = getMetadataCells(obj),\n                         gene_metadata = getMetadataGenes(obj)\n                         )\ncds &lt;- preprocess_cds(cds, num_dim = 100)\n\nnormalized_counts &lt;- normalized_counts(cds)\n\n\nint.genes &lt;- rownames(normalized_counts)[rownames(normalized_counts) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(normalized_counts)[int.genes,])\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nmonocle.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(monocle.data.cor.big) &lt;- 0\n\nmonocle.data.cor &lt;- monocle.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(monocle.data.cor),\n        #width = ncol(monocle.corMat)*unit(2.5, \"mm\"), \n        height = nrow(monocle.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"monocle corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n [1] stats4    parallel  grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n [5] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n [7] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n [9] matrixStats_1.2.0           Biobase_2.60.0             \n[11] BiocGenerics_0.46.0         doParallel_1.0.17          \n[13] iterators_1.0.14            foreach_1.5.2              \n[15] Rfast_2.1.0                 RcppParallel_5.1.7         \n[17] RcppZiggurat_0.1.6          Rcpp_1.0.11                \n[19] patchwork_1.2.0             Seurat_5.0.0               \n[21] SeuratObject_5.0.0          sp_2.1-1                   \n[23] dplyr_1.1.2                 circlize_0.4.15            \n[25] ComplexHeatmap_2.16.0       COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] globals_0.16.2            lattice_0.22-5           \n [11] MASS_7.3-60               dendextend_1.17.1        \n [13] magrittr_2.0.3            plotly_4.10.2            \n [15] rmarkdown_2.24            yaml_2.3.7               \n [17] httpuv_1.6.11             glmGamPoi_1.12.2         \n [19] sctransform_0.4.1         spam_2.10-0              \n [21] askpass_1.2.0             spatstat.sparse_3.0-2    \n [23] reticulate_1.35.0         minqa_1.2.5              \n [25] cowplot_1.1.1             pbapply_1.7-2            \n [27] RColorBrewer_1.1-3        zlibbioc_1.46.0          \n [29] abind_1.4-5               Rtsne_0.16               \n [31] purrr_1.0.1               RCurl_1.98-1.12          \n [33] GenomeInfoDbData_1.2.10   ggrepel_0.9.3            \n [35] irlba_2.3.5.1             listenv_0.9.0            \n [37] spatstat.utils_3.0-3      terra_1.7-39             \n [39] umap_0.2.10.0             goftest_1.2-3            \n [41] RSpectra_0.16-1           spatstat.random_3.2-1    \n [43] dqrng_0.3.0               fitdistrplus_1.1-11      \n [45] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [47] leiden_0.4.3              codetools_0.2-19         \n [49] DelayedArray_0.26.7       tidyselect_1.2.0         \n [51] shape_1.4.6               farver_2.1.1             \n [53] lme4_1.1-34               ScaledMatrix_1.8.1       \n [55] viridis_0.6.4             spatstat.explore_3.2-1   \n [57] jsonlite_1.8.7            GetoptLong_1.0.5         \n [59] ellipsis_0.3.2            progressr_0.14.0         \n [61] ggridges_0.5.4            survival_3.5-7           \n [63] tools_4.3.2               ica_1.0-3                \n [65] glue_1.7.0                gridExtra_2.3            \n [67] xfun_0.39                 ggthemes_5.0.0           \n [69] withr_3.0.0               fastmap_1.1.1            \n [71] boot_1.3-28               fansi_1.0.4              \n [73] openssl_2.1.0             digest_0.6.33            \n [75] rsvd_1.0.5                parallelDist_0.2.6       \n [77] R6_2.5.1                  mime_0.12                \n [79] colorspace_2.1-0          scattermore_1.2          \n [81] Cairo_1.6-1               tensor_1.5               \n [83] spatstat.data_3.0-1       utf8_1.2.3               \n [85] tidyr_1.3.0               generics_0.1.3           \n [87] data.table_1.15.0         httr_1.4.6               \n [89] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [91] uwot_0.1.16               pkgconfig_2.0.3          \n [93] gtable_0.3.3              lmtest_0.9-40            \n [95] XVector_0.40.0            htmltools_0.5.7          \n [97] dotCall64_1.1-0           clue_0.3-64              \n [99] scales_1.3.0              png_0.1-8                \n[101] knitr_1.43                rstudioapi_0.15.0        \n[103] reshape2_1.4.4            rjson_0.2.21             \n[105] nloptr_2.0.3              nlme_3.1-163             \n[107] zoo_1.8-12                GlobalOptions_0.1.2      \n[109] stringr_1.5.0             KernSmooth_2.23-22       \n[111] miniUI_0.1.1.1            pillar_1.9.0             \n[113] vctrs_0.6.3               RANN_2.6.1               \n[115] promises_1.2.0.1          BiocSingular_1.16.0      \n[117] beachmat_2.16.0           xtable_1.8-4             \n[119] cluster_2.1.6             evaluate_0.21            \n[121] zeallot_0.1.0             cli_3.6.1                \n[123] compiler_4.3.2            rlang_1.1.1              \n[125] crayon_1.5.2              future.apply_1.11.0      \n[127] labeling_0.4.2            plyr_1.8.8               \n[129] stringi_1.8.1             viridisLite_0.4.2        \n[131] deldir_2.0-2              BiocParallel_1.34.2      \n[133] assertthat_0.2.1          munsell_0.5.0            \n[135] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[137] PCAtools_2.14.0           Matrix_1.6-3             \n[139] RcppHNSW_0.6.0            sparseMatrixStats_1.12.2 \n[141] future_1.33.0             ggplot2_3.4.2            \n[143] shiny_1.8.0               ROCR_1.0-11              \n[145] igraph_1.6.0"
  },
  {
    "objectID": "cd14_clusterizations_comparisons.html",
    "href": "cd14_clusterizations_comparisons.html",
    "title": "CD14+ clusterizations comparisons with CellTypist",
    "section": "",
    "text": "#library(SingleCellExperiment)\n#library(DuoClustering2018)\n#library(tidyr)\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(ggsankey) # remotes::install_github(\"davidsjoberg/ggsankey\")\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(assertthat)\nlibrary(COTAN)\n#devtools::load_all(\"~/dev/COTAN/COTAN/\")\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"Results/Clusterization/\"\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"CD14_Monocytes_ClusterizationsComparisons.log\"))\n\n\ncd14Obj &lt;- readRDS(file = file.path(\"Data/CD14Cleaned/\", \"CD14_Monocytes.cotan.RDS\"))\n\nsampleCondition &lt;- getMetadataElement(cd14Obj, datasetTags()[[\"cond\"]])\n\nsampleCondition\n\n[1] \"CD14_Monocytes\"\n\ngetClusterizations(cd14Obj)\n\n[1] \"split\"           \"merge\"           \"majority-voting\"\n\nmetaC &lt;- getMetadataCells(cd14Obj)\n\n\nsplitClusters &lt;- getClusters(cd14Obj, \"split\")\nmergedClusters &lt;- getClusters(cd14Obj, \"merge\")\n\n\nlabelsDF &lt;- read.csv(file.path(\"Data/CD14Cleaned/\", \"CD14Cleaned_Immune_All_Low_predicted_labels.csv\"), header = TRUE)\nlabelsDF &lt;- column_to_rownames(labelsDF, var = \"X\")\nrownames(labelsDF) &lt;- gsub(\"[.]\", \"-\", rownames(labelsDF))\n\ncells_to_keep &lt;- rownames(labelsDF)[rownames(labelsDF) %in% getCells(cd14Obj)]\nassert_that(identical(cells_to_keep, getCells(cd14Obj)))\n\nmajorityVotingClusters &lt;- labelsDF[cells_to_keep, \"majority_voting\"]\nnames(majorityVotingClusters) &lt;- cells_to_keep\n\nmajorityVotingCoexDF &lt;- DEAOnClusters(cd14Obj, majorityVotingClusters)\n\ncd14Obj &lt;- addClusterization(cd14Obj, clName = \"majority-voting\",\n                             clusters = majorityVotingClusters,\n                             coexDF = majorityVotingCoexDF)\n\nSave the COTAN object\n\nsaveRDS(cd14Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nnlevels(splitClusters)\nhead(sort(table(splitClusters), decreasing = TRUE), 10L)\n\nnlevels(mergedClusters)\nhead(sort(table(mergedClusters), decreasing = TRUE), 10L)\n\nnlevels(majorityVotingClusters)\nhead(sort(table(majorityVotingClusters), decreasing = TRUE), 10L)\n\n\nsplitClustersDF &lt;- as.data.frame(splitClusters)\nsplitClustersDF[[\"cell\"]] &lt;- rownames(splitClustersDF)\ncolnames(splitClustersDF)[[1]] &lt;- \"COTAN.split.cluster\"\nsplitClustersDF &lt;- splitClustersDF[order(splitClustersDF[[\"COTAN.split.cluster\"]]), ]\n\nmergedClustersDF &lt;- as.data.frame(mergedClusters)\nmergedClustersDF[[\"cell\"]] &lt;- rownames(mergedClustersDF)\ncolnames(mergedClustersDF)[[1]] &lt;- \"COTAN.merged.cluster\"\nmergedClustersDF &lt;- mergedClustersDF[order(mergedClustersDF[[\"COTAN.merged.cluster\"]]), ]\n\nmajorityVotingClustersDF &lt;- as.data.frame(majorityVotingClusters)\nmajorityVotingClustersDF[[\"cell\"]] &lt;- rownames(majorityVotingClustersDF)\ncolnames(majorityVotingClustersDF)[[1]] &lt;- \"majority.voting.cluster\"\nmajorityVotingClustersDF &lt;- majorityVotingClustersDF[order(majorityVotingClustersDF[[\"majority.voting.cluster\"]]), ]\n\n\nmjvt_split.table &lt;- merge.data.frame(x = majorityVotingClustersDF, y = splitClustersDF,\n                                         by = \"cell\", all.x = TRUE, all.y = TRUE)\n\ntable(mjvt_split.table[,c(2L, 3L)])\n\n                       COTAN.split.cluster\nmajority.voting.cluster   1   2   3   4   5   6\n    Classical monocytes 879   1   1 589 889  36\n    NK cells              0  25   0   0   0   0\n    pDC                   3   0  10   1   0   0\n\n\n\nmjvt_split.table2 &lt;- mjvt_split.table %&gt;% make_long(majority.voting.cluster, COTAN.split.cluster)\n\nggplot(mjvt_split.table2,\n       aes(x = x,\n           next_x = next_x,\n           node = node,\n           next_node = next_node,\n           fill = factor(node),\n           label = node)) +\n  geom_sankey(flow.alpha = 0.75, node.color = 1) +\n  geom_sankey_label(size = 3.5, color = 1, fill = \"white\") +\n  scale_fill_viridis_d(option = \"A\", alpha = 0.95) +\n  theme_sankey(base_size = 16) +\n  theme(legend.position = \"none\")\n\n\n\n\n\nmjvt_merged.table &lt;- merge.data.frame(x = majorityVotingClustersDF, y = mergedClustersDF,\n                                         by = \"cell\", all.x = TRUE, all.y = TRUE)\n\ntable(mjvt_merged.table[,c(2L, 3L)])\n\n                       COTAN.merged.cluster\nmajority.voting.cluster    1    2    3\n    Classical monocytes 1514  879    2\n    NK cells               0    0   25\n    pDC                    1    3   10\n\n\n\nmjvt_merged.table2 &lt;- mjvt_merged.table %&gt;% make_long(majority.voting.cluster, COTAN.merged.cluster)\n\nggplot(mjvt_merged.table2,\n       aes(x = x,\n           next_x = next_x,\n           node = node,\n           next_node = next_node,\n           fill = factor(node),\n           label = node)) +\n  geom_sankey(flow.alpha = 0.75, node.color = 1) +\n  geom_sankey_label(size = 3.5, color = 1, fill = \"white\") +\n  scale_fill_viridis_d(option = \"A\", alpha = 0.95) +\n  theme_sankey(base_size = 16) +\n  theme(legend.position = \"none\")\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.1.7        assertthat_0.2.1   zeallot_0.1.0      tibble_3.2.1      \n[5] ggsankey_0.0.99999 ggplot2_3.4.2      rlang_1.1.1       \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.15.0      jsonlite_1.8.7        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.24        \n [10] GlobalOptions_0.1.2    vctrs_0.6.3            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-22    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.2          zoo_1.8-12             igraph_1.5.1          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.6-0           R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-11    future_1.33.0         \n [34] shiny_1.7.5            clue_0.3-64            digest_0.6.33         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.1      \n [40] Seurat_4.3.0.1         tensor_1.5             RSpectra_0.16-1       \n [43] irlba_2.3.5.1          labeling_0.4.2         progressr_0.14.0      \n [46] RcppZiggurat_0.1.6     fansi_1.0.4            spatstat.sparse_3.0-2 \n [49] httr_1.4.6             polyclip_1.10-4        abind_1.4-5           \n [52] compiler_4.3.1         withr_2.5.0            doParallel_1.0.17     \n [55] viridis_0.6.4          dendextend_1.17.1      MASS_7.3-60           \n [58] openssl_2.1.0          rjson_0.2.21           tools_4.3.1           \n [61] lmtest_0.9-40          httpuv_1.6.11          future.apply_1.11.0   \n [64] goftest_1.2-3          glue_1.6.2             nlme_3.1-162          \n [67] promises_1.2.0.1       grid_4.3.1             Rtsne_0.16            \n [70] cluster_2.1.4          reshape2_1.4.4         generics_0.1.3        \n [73] gtable_0.3.3           spatstat.data_3.0-1    tidyr_1.3.0           \n [76] data.table_1.14.8      sp_2.0-0               utf8_1.2.3            \n [79] BiocGenerics_0.46.0    spatstat.geom_3.2-4    RcppAnnoy_0.0.21      \n [82] ggrepel_0.9.3          RANN_2.6.1             foreach_1.5.2         \n [85] pillar_1.9.0           stringr_1.5.0          later_1.3.1           \n [88] circlize_0.4.15        splines_4.3.1          dplyr_1.1.2           \n [91] lattice_0.21-8         survival_3.5-5         deldir_1.0-9          \n [94] tidyselect_1.2.0       ComplexHeatmap_2.16.0  miniUI_0.1.1.1        \n [97] pbapply_1.7-2          knitr_1.43             gridExtra_2.3         \n[100] IRanges_2.34.1         scattermore_1.2        stats4_4.3.1          \n[103] xfun_0.39              factoextra_1.0.7       matrixStats_1.0.0     \n[106] stringi_1.7.12         lazyeval_0.2.2         yaml_2.3.7            \n[109] evaluate_0.21          codetools_0.2-19       cli_3.6.1             \n[112] RcppParallel_5.1.7     uwot_0.1.16            xtable_1.8-4          \n[115] reticulate_1.30        munsell_0.5.0          Rcpp_1.0.11           \n[118] globals_0.16.2         spatstat.random_3.1-5  png_0.1-8             \n[121] parallel_4.3.1         Rfast_2.0.8            ellipsis_0.3.2        \n[124] parallelDist_0.2.6     listenv_0.9.0          ggthemes_4.2.4        \n[127] viridisLite_0.4.2      scales_1.2.1           ggridges_0.5.4        \n[130] SeuratObject_4.1.3     leiden_0.4.3           purrr_1.0.1           \n[133] crayon_1.5.2           GetoptLong_1.0.5       cowplot_1.1.1"
  },
  {
    "objectID": "SubsettingDataSensitivityEvaluation.html",
    "href": "SubsettingDataSensitivityEvaluation.html",
    "title": "Subsetting data for sensitivity evaluation",
    "section": "",
    "text": "Import data\n\nlibrary(COTAN)\nobjE15 &lt;- readRDS(\"Data/MouseCortexFromLoom/e15.0_ForebrainDorsal.cotan.RDS\")\n\nCell types distribution across the dataset\n\ntable(objE15@metaCells$Class)\n\n\n                 Bad cells                      Blood \n                         7                          1 \n            Choroid plexus                 Fibroblast \n                         1                         71 \n                 Glioblast                     Immune \n                        91                         31 \n                Mesenchyme                 Neuroblast \n                         1                       2536 \n                    Neuron Olfactory ensheathing cell \n                      4801                          1 \n           Oligodendrocyte               Pineal gland \n                         1                          5 \n               Radial glia                   Vascular \n                       966                         49 \n\n\n\ntable(objE15@metaCells[objE15@metaCells$Class %in% c(\"Neuron\",\"Neuroblast\",\"Radial glia\"),]$Class,\n      objE15@metaCells[objE15@metaCells$Class %in% c(\"Neuron\",\"Neuroblast\",\"Radial glia\"),]$Subclass)\n\n             \n              Cajal-Retzius Cortical hem Cortical or hippocampal glutamatergic\n  Neuroblast              9            0                                     0\n  Neuron                145            0                                  3969\n  Radial glia             0           17                                     0\n             \n              Diencephalic roof plate Diencephalon Dorsal diencephalon\n  Neuroblast                        0            0                   0\n  Neuron                            0            0                   0\n  Radial glia                       5            4                   1\n             \n              Dorsal forebrain Dorsal midbrain glutamatergic Forebrain\n  Neuroblast                 0                             0         7\n  Neuron                     0                             1         0\n  Radial glia              909                             0        26\n             \n              Forebrain GABAergic Forebrain glutamatergic\n  Neuroblast                   59                     917\n  Neuron                      610                      15\n  Radial glia                   0                       0\n             \n              Hindbrain glutamatergic Hindbrain glycinergic Hypothalamus\n  Neuroblast                        0                     0            0\n  Neuron                            2                     2            8\n  Radial glia                       0                     0            0\n             \n              Hypothalamus glutamatergic Midbrain Mixed region\n  Neuroblast                           0        0            0\n  Neuron                               2        0            1\n  Radial glia                          0        1            2\n             \n              Mixed region and neurotransmitter Mixed region GABAergic\n  Neuroblast                                  0                      0\n  Neuron                                      4                     21\n  Radial glia                                 0                      0\n             \n              Mixed region glutamatergic Neuronal intermediate progenitor\n  Neuroblast                           8                             1534\n  Neuron                               5                                0\n  Radial glia                          0                                0\n             \n              Undefined\n  Neuroblast          2\n  Neuron             16\n  Radial glia         1\n\n\n\nneuron.CajalRCells &lt;- rownames(objE15@metaCells[objE15@metaCells$Class == \"Neuron\" & objE15@metaCells$Subclass == \"Cajal-Retzius\",])\nlength(neuron.CajalRCells)\n\n[1] 145\n\n\n\nneuron.CajalRCells &lt;- automaticCOTANObjectCreation(raw = getRawData(objE15)[,neuron.CajalRCells],\n  GEO = getMetadataDataset(e15)[1,2],\n  cores = 13,\n  saveObj = TRUE,\n  outDir = \"Data/MouseCortexFromLoom/\",\n  sequencingMethod = getMetadataDataset(e15)[2,2],\n  sampleCondition = \"E15.0_CajalRCells\"\n)\n\n\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n    c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\")\n)\n\nneuron.CajalRCells &lt;- readRDS(\"Data/MouseCortexFromLoom/E15.0_CajalRCells.cotan.RDS\")\n\nGDIPlot(neuron.CajalRCells,genes = genesList)"
  },
  {
    "objectID": "PBMC3_filtering.html",
    "href": "PBMC3_filtering.html",
    "title": "Filtering of PBMC3 using COTAN",
    "section": "",
    "text": "Library import\n\nlibrary(dplyr)\nlibrary(COTAN)\nlibrary(Seurat)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(DropletUtils)\n\nSettings\n\ndatasetName = 'PBMC3'\ndatasetFolder = './Data/'\n\ninDir  = paste(datasetFolder, datasetName, '/raw/10X/', sep='')\noutDir = paste(datasetFolder, datasetName, '/filtered/', sep='')\ndir10X = paste(outDir, '10X/', sep='')\n\nif (!dir.exists(outDir)) {\n  dir.create(outDir, recursive = TRUE, showWarnings = FALSE)\n}\n\nsetLoggingLevel(2)\nsetLoggingFile(paste(outDir, \"logfile.log\", sep=\"\"))\noptions(parallelly.fork.enable = TRUE)\n\nData loading\n\ndataset = Read10X(data.dir = inDir, strip.suffix = TRUE)\ndataset = dataset[[1]]\nsampleCond &lt;- datasetName\nPBMC3 &lt;- COTAN(raw = dataset)\nPBMC3 &lt;- initializeMetaDataset(\n  PBMC3,\n  GEO = paste(\"10X \", datasetName, sep=\"\"),\n  sequencingMethod = \"10X\",\n  sampleCond = sampleCond\n)\n\nInspect cells’ sizes\n\ncellSizePlot(PBMC3)\n\n\n\n\nDrop cells with too many reads as they are probably doublets\n\ncellsSizeThr &lt;- 20000\nPBMC3 &lt;- addElementToMetaDataset(PBMC3, \"Cells size threshold\", cellsSizeThr)\n\ncellsToRem &lt;- getCells(PBMC3)[getCellsSize(PBMC3) &gt; cellsSizeThr]\nPBMC3 &lt;- dropGenesCells(PBMC3, cells = cellsToRem)\n\ncellSizePlot(PBMC3, splitPattern = \"-\", numCol = 2)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(PBMC3, splitPattern = \"-\", numCol = 2)\n\n\n\n\nDrop cells with too high genes expression as they are probably doublets\n\ngeneSizeThr &lt;- 3500\nPBMC3 &lt;- addElementToMetaDataset(PBMC3, \"Num genes threshold\", geneSizeThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(PBMC3)\ncellsToRem &lt;- names(numExprGenes)[numExprGenes &gt; geneSizeThr]\nPBMC3 &lt;- dropGenesCells(PBMC3, cells = cellsToRem)\n\ngenesSizePlot(PBMC3, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCheck number of mithocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^[Mm][Tt]-\"\ngetGenes(PBMC3)[grep(mitGenesPattern, getGenes(PBMC3))]\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\n\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC3, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nWe drop cells with a too high percentage of mitocondrial genes (are likely dead)\n\nmitPercThr &lt;- 10\nPBMC3 &lt;- addElementToMetaDataset(PBMC3, \"Mitoc. perc. threshold\", mitPercThr)\n\ncellsToRem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\nPBMC3 &lt;- dropGenesCells(PBMC3, cells = cellsToRem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC3, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nCheck number of ribosomial genes expressed in each cell\n\nribGenesPattern &lt;- \"^RP[SL]\\\\d+\"\ngetGenes(PBMC3)[grep(ribGenesPattern, getGenes(PBMC3))]\n\n  [1] \"RPL22\"          \"RPL11\"          \"RPS6KA1\"        \"RPS8\"          \n  [5] \"RPL5\"           \"RPS27\"          \"RPS6KC1\"        \"RPS7\"          \n  [9] \"RPS27A\"         \"RPL31\"          \"RPL37A\"         \"RPL32\"         \n [13] \"RPL15\"          \"RPL14\"          \"RPL29\"          \"RPL24\"         \n [17] \"RPL22L1\"        \"RPL39L\"         \"RPL35A\"         \"RPL9\"          \n [21] \"RPL34-AS1\"      \"RPL34\"          \"RPS3A\"          \"RPL37\"         \n [25] \"RPS23\"          \"RPS14\"          \"RPL26L1\"        \"RPS18\"         \n [29] \"RPS10-NUDT3\"    \"RPS10\"          \"RPL10A\"         \"RPL7L1\"        \n [33] \"RPS12\"          \"RPS6KA2\"        \"RPS6KA2-AS1\"    \"RPS6KA3\"       \n [37] \"RPS4X\"          \"RPS6KA6\"        \"RPL36A\"         \"RPL36A-HNRNPH2\"\n [41] \"RPL39\"          \"RPL10\"          \"RPS20\"          \"RPL7\"          \n [45] \"RPL30\"          \"RPL8\"           \"RPS6\"           \"RPL35\"         \n [49] \"RPL12\"          \"RPL7A\"          \"RPL27A\"         \"RPS13\"         \n [53] \"RPS6KA4\"        \"RPS6KB2\"        \"RPS6KB2-AS1\"    \"RPS3\"          \n [57] \"RPS25\"          \"RPS24\"          \"RPS26\"          \"RPL41\"         \n [61] \"RPL6\"           \"RPL21\"          \"RPL10L\"         \"RPS29\"         \n [65] \"RPL36AL\"        \"RPS6KL1\"        \"RPS6KA5\"        \"RPS27L\"        \n [69] \"RPL4\"           \"RPS17\"          \"RPL3L\"          \"RPS2\"          \n [73] \"RPS15A\"         \"RPL13\"          \"RPL26\"          \"RPL23A\"        \n [77] \"RPL23\"          \"RPL19\"          \"RPL27\"          \"RPS6KB1\"       \n [81] \"RPL38\"          \"RPL17-C18orf32\" \"RPL17\"          \"RPS21\"         \n [85] \"RPS15\"          \"RPL36\"          \"RPS28\"          \"RPL18A\"        \n [89] \"RPS16\"          \"RPS19\"          \"RPL18\"          \"RPL13A\"        \n [93] \"RPS11\"          \"RPS9\"           \"RPL28\"          \"RPS5\"          \n [97] \"RPS4Y1\"         \"RPS4Y2\"         \"RPL3\"           \"RPS19BP1\"      \n\n\n\nc(ribPlot, ribSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC3, genePrefix = ribGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(ribPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(PBMC3, splitPattern = \"-\", numCol = 2)\n\n\n\n\n\ngenesSizePlot(PBMC3, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCleaning, round 1\n\nPBMC3 &lt;- clean(PBMC3)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC3)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nPBMC3 &lt;- addElementToMetaDataset(PBMC3, \"Num drop B group\", 0)\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)  \n\n\n\n\n\nyset=0.16\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(PBMC3)), \"n\" = seq_along(getNu(PBMC3)))\nPBMC3 &lt;- addElementToMetaDataset(PBMC3, \"Threshold low UDE cells:\", yset)\ncellsToRem &lt;-rownames(nuDf)[nuDf[[\"nu\"]] &lt; yset]\nPBMC3 &lt;- dropGenesCells(PBMC3, cells = cellsToRem)\n\nCleaning, round 2\n\nPBMC3 &lt;- clean(PBMC3)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC3)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(pcaCellsData)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\n\nplot(cellSizePlot(PBMC3, splitPattern = \"-\", numCol = 2))\n\n\n\n\n\nplot(genesSizePlot(PBMC3, splitPattern = \"-\", numCol = 2))\n\n\n\n\nSave the filtered dataset\n\nif (!dir.exists(dir10X)) {\n  write10xCounts(dir10X, getRawData(PBMC3))\n}\n\n\nsaveRDS(PBMC3, file = paste0(outDir, sampleCond, \".cotan.RDS\"))\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] DropletUtils_1.20.0         SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 Biobase_2.60.0             \n [5] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1        \n [7] IRanges_2.34.1              S4Vectors_0.38.1           \n [9] BiocGenerics_0.46.0         MatrixGenerics_1.12.3      \n[11] matrixStats_1.2.0           zeallot_0.1.0              \n[13] ggplot2_3.4.2               tibble_3.2.1               \n[15] Seurat_5.0.0                SeuratObject_5.0.0         \n[17] sp_2.1-1                    COTAN_2.3.0                \n[19] dplyr_1.1.2                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] R.oo_1.25.0               polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] edgeR_3.42.4              doParallel_1.0.17        \n [11] globals_0.16.2            lattice_0.22-5           \n [13] MASS_7.3-60               dendextend_1.17.1        \n [15] magrittr_2.0.3            limma_3.56.2             \n [17] plotly_4.10.2             rmarkdown_2.24           \n [19] yaml_2.3.7                httpuv_1.6.11            \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.34.0         cowplot_1.1.1            \n [27] pbapply_1.7-2             RColorBrewer_1.1-3       \n [29] zlibbioc_1.46.0           abind_1.4-5              \n [31] Rtsne_0.16                R.utils_2.12.2           \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] circlize_0.4.15           GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       scuttle_1.10.2           \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              ScaledMatrix_1.8.1       \n [57] viridis_0.6.4             spatstat.explore_3.2-1   \n [59] jsonlite_1.8.7            GetoptLong_1.0.5         \n [61] ellipsis_0.3.2            progressr_0.14.0         \n [63] ggridges_0.5.4            survival_3.5-7           \n [65] iterators_1.0.14          foreach_1.5.2            \n [67] tools_4.3.2               ica_1.0-3                \n [69] Rcpp_1.0.11               glue_1.6.2               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            HDF5Array_1.28.1         \n [75] withr_2.5.0               fastmap_1.1.1            \n [77] rhdf5filters_1.12.1       fansi_1.0.4              \n [79] openssl_2.1.0             digest_0.6.33            \n [81] rsvd_1.0.5                parallelDist_0.2.6       \n [83] R6_2.5.1                  mime_0.12                \n [85] colorspace_2.1-0          scattermore_1.2          \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] R.methodsS3_1.8.2         utf8_1.2.3               \n [91] tidyr_1.3.0               generics_0.1.3           \n [93] data.table_1.14.8         httr_1.4.6               \n [95] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [97] uwot_0.1.16               pkgconfig_2.0.3          \n [99] gtable_0.3.3              ComplexHeatmap_2.16.0    \n[101] lmtest_0.9-40             XVector_0.40.0           \n[103] htmltools_0.5.7           dotCall64_1.1-0          \n[105] clue_0.3-64               scales_1.3.0             \n[107] png_0.1-8                 knitr_1.43               \n[109] rstudioapi_0.15.0         reshape2_1.4.4           \n[111] rjson_0.2.21              nlme_3.1-163             \n[113] rhdf5_2.44.0              zoo_1.8-12               \n[115] GlobalOptions_0.1.2       stringr_1.5.0            \n[117] KernSmooth_2.23-22        parallel_4.3.2           \n[119] miniUI_0.1.1.1            RcppZiggurat_0.1.6       \n[121] pillar_1.9.0              grid_4.3.2               \n[123] vctrs_0.6.3               RANN_2.6.1               \n[125] promises_1.2.0.1          BiocSingular_1.16.0      \n[127] beachmat_2.16.0           xtable_1.8-4             \n[129] cluster_2.1.6             evaluate_0.21            \n[131] locfit_1.5-9.8            cli_3.6.1                \n[133] compiler_4.3.2            rlang_1.1.1              \n[135] crayon_1.5.2              future.apply_1.11.0      \n[137] labeling_0.4.2            plyr_1.8.8               \n[139] stringi_1.8.1             viridisLite_0.4.2        \n[141] deldir_2.0-2              BiocParallel_1.34.2      \n[143] assertthat_0.2.1          munsell_0.5.0            \n[145] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[147] PCAtools_2.14.0           Matrix_1.6-3             \n[149] RcppHNSW_0.5.0            patchwork_1.1.2          \n[151] sparseMatrixStats_1.12.2  future_1.33.0            \n[153] Rhdf5lib_1.22.0           shiny_1.8.0              \n[155] ROCR_1.0-11               Rfast_2.1.0              \n[157] igraph_1.6.0              RcppParallel_5.1.7"
  },
  {
    "objectID": "PBMC1_filtering.html",
    "href": "PBMC1_filtering.html",
    "title": "Filtering of PBMC1 using COTAN",
    "section": "",
    "text": "Library import\n\nlibrary(dplyr)\nlibrary(COTAN)\nlibrary(Seurat)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(DropletUtils)\n\nSettings\n\ndatasetName = 'PBMC1'\ndatasetFolder = './Data/'\n\ninDir  = paste(datasetFolder, datasetName, '/raw/10X/', sep='')\noutDir = paste(datasetFolder, datasetName, '/filtered/', sep='')\ndir10X = paste(outDir, '10X/', sep='')\n\nif (!dir.exists(outDir)) {\n  dir.create(outDir, recursive = TRUE, showWarnings = FALSE)\n}\n\nsetLoggingLevel(2)\nsetLoggingFile(paste(outDir, \"logfile.log\", sep=\"\"))\noptions(parallelly.fork.enable = TRUE)\n\nData loading\n\ndataset = Read10X(data.dir = inDir, strip.suffix = TRUE)\ndataset = dataset[[1]]\nsampleCond &lt;- datasetName\nPBMC1 &lt;- COTAN(raw = dataset)\nPBMC1 &lt;- initializeMetaDataset(\n  PBMC1,\n  GEO = paste(\"10X \", datasetName, sep=\"\"),\n  sequencingMethod = \"10X\",\n  sampleCond = sampleCond\n)\n\nInspect cells’ sizes\n\ncellSizePlot(PBMC1)\n\n\n\n\nDrop cells with too many reads as they are probably doublets\n\ncellsSizeThr &lt;- 25000\nPBMC1 &lt;- addElementToMetaDataset(PBMC1, \"Cells size threshold\", cellsSizeThr)\n\ncellsToRem &lt;- getCells(PBMC1)[getCellsSize(PBMC1) &gt; cellsSizeThr]\nPBMC1 &lt;- dropGenesCells(PBMC1, cells = cellsToRem)\n\ncellSizePlot(PBMC1, splitPattern = \"-\", numCol = 2)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(PBMC1, splitPattern = \"-\", numCol = 2)\n\n\n\n\nDrop cells with too high genes expression as they are probably doublets\n\ngeneSizeThr &lt;- 4500\nPBMC1 &lt;- addElementToMetaDataset(PBMC1, \"Num genes threshold\", geneSizeThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(PBMC1)\ncellsToRem &lt;- names(numExprGenes)[numExprGenes &gt; geneSizeThr]\nPBMC1 &lt;- dropGenesCells(PBMC1, cells = cellsToRem)\n\ngenesSizePlot(PBMC1, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCheck number of mithocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^[Mm][Tt]-\"\ngetGenes(PBMC1)[grep(mitGenesPattern, getGenes(PBMC1))]\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\n\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC1, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nWe drop cells with a too high percentage of mitocondrial genes (are likely dead)\n\nmitPercThr &lt;- 10\nPBMC1 &lt;- addElementToMetaDataset(PBMC1, \"Mitoc. perc. threshold\", mitPercThr)\n\ncellsToRem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\nPBMC1 &lt;- dropGenesCells(PBMC1, cells = cellsToRem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC1, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nCheck number of ribosomial genes expressed in each cell\n\nribGenesPattern &lt;- \"^RP[SL]\\\\d+\"\ngetGenes(PBMC1)[grep(ribGenesPattern, getGenes(PBMC1))]\n\n  [1] \"RPL22\"          \"RPL11\"          \"RPS6KA1\"        \"RPS8\"          \n  [5] \"RPL5\"           \"RPS27\"          \"RPS6KC1\"        \"RPS7\"          \n  [9] \"RPS27A\"         \"RPL31\"          \"RPL37A\"         \"RPL32\"         \n [13] \"RPL15\"          \"RPL14\"          \"RPL29\"          \"RPL24\"         \n [17] \"RPL22L1\"        \"RPL39L\"         \"RPL35A\"         \"RPL9\"          \n [21] \"RPL34-AS1\"      \"RPL34\"          \"RPS3A\"          \"RPL37\"         \n [25] \"RPS23\"          \"RPS14\"          \"RPL26L1\"        \"RPS18\"         \n [29] \"RPS10-NUDT3\"    \"RPS10\"          \"RPL10A\"         \"RPL7L1\"        \n [33] \"RPS12\"          \"RPS6KA2\"        \"RPS6KA2-AS1\"    \"RPS6KA3\"       \n [37] \"RPS4X\"          \"RPS6KA6\"        \"RPL36A\"         \"RPL36A-HNRNPH2\"\n [41] \"RPL39\"          \"RPL10\"          \"RPS20\"          \"RPL7\"          \n [45] \"RPL30\"          \"RPL8\"           \"RPS6\"           \"RPL35\"         \n [49] \"RPL12\"          \"RPL7A\"          \"RPL27A\"         \"RPS13\"         \n [53] \"RPS6KA4\"        \"RPS6KB2\"        \"RPS6KB2-AS1\"    \"RPS3\"          \n [57] \"RPS25\"          \"RPS24\"          \"RPS26\"          \"RPL41\"         \n [61] \"RPL6\"           \"RPL21\"          \"RPL10L\"         \"RPS29\"         \n [65] \"RPL36AL\"        \"RPS6KL1\"        \"RPS6KA5\"        \"RPS27L\"        \n [69] \"RPL4\"           \"RPS17\"          \"RPL3L\"          \"RPS2\"          \n [73] \"RPS15A\"         \"RPL13\"          \"RPL26\"          \"RPL23A\"        \n [77] \"RPL23\"          \"RPL19\"          \"RPL27\"          \"RPS6KB1\"       \n [81] \"RPL38\"          \"RPL17-C18orf32\" \"RPL17\"          \"RPS21\"         \n [85] \"RPS15\"          \"RPL36\"          \"RPS28\"          \"RPL18A\"        \n [89] \"RPS16\"          \"RPS19\"          \"RPL18\"          \"RPL13A\"        \n [93] \"RPS11\"          \"RPS9\"           \"RPL28\"          \"RPS5\"          \n [97] \"RPS4Y1\"         \"RPS4Y2\"         \"RPL3\"           \"RPS19BP1\"      \n\n\n\nc(ribPlot, ribSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC1, genePrefix = ribGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(ribPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(PBMC1, splitPattern = \"-\", numCol = 2)\n\n\n\n\n\ngenesSizePlot(PBMC1, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCleaning, round 1\n\nPBMC1 &lt;- clean(PBMC1)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC1)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nPBMC1 &lt;- addElementToMetaDataset(PBMC1, \"Num drop B group\", 0)\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)  \n\n\n\n\n\nyset=0.16\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(PBMC1)), \"n\" = seq_along(getNu(PBMC1)))\nPBMC1 &lt;- addElementToMetaDataset(PBMC1, \"Threshold low UDE cells:\", yset)\ncellsToRem &lt;-rownames(nuDf)[nuDf[[\"nu\"]] &lt; yset]\nPBMC1 &lt;- dropGenesCells(PBMC1, cells = cellsToRem)\n\nCleaning, round 2\n\nPBMC1 &lt;- clean(PBMC1)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC1)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(pcaCellsData)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\n\nplot(cellSizePlot(PBMC1, splitPattern = \"-\", numCol = 2))\n\n\n\n\n\nplot(genesSizePlot(PBMC1, splitPattern = \"-\", numCol = 2))\n\n\n\n\nSave the filtered dataset\n\nif (!dir.exists(dir10X)) {\n  write10xCounts(dir10X, getRawData(PBMC1))\n}\n\n\nsaveRDS(PBMC1, file = paste0(outDir, sampleCond, \".cotan.RDS\"))\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] DropletUtils_1.20.0         SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 Biobase_2.60.0             \n [5] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1        \n [7] IRanges_2.34.1              S4Vectors_0.38.1           \n [9] BiocGenerics_0.46.0         MatrixGenerics_1.12.3      \n[11] matrixStats_1.2.0           zeallot_0.1.0              \n[13] ggplot2_3.4.2               tibble_3.2.1               \n[15] Seurat_5.0.0                SeuratObject_5.0.0         \n[17] sp_2.1-1                    COTAN_2.3.0                \n[19] dplyr_1.1.2                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] R.oo_1.25.0               polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] edgeR_3.42.4              doParallel_1.0.17        \n [11] globals_0.16.2            lattice_0.22-5           \n [13] MASS_7.3-60               dendextend_1.17.1        \n [15] magrittr_2.0.3            limma_3.56.2             \n [17] plotly_4.10.2             rmarkdown_2.24           \n [19] yaml_2.3.7                httpuv_1.6.11            \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.34.0         cowplot_1.1.1            \n [27] pbapply_1.7-2             RColorBrewer_1.1-3       \n [29] zlibbioc_1.46.0           abind_1.4-5              \n [31] Rtsne_0.16                R.utils_2.12.2           \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] circlize_0.4.15           GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       scuttle_1.10.2           \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              ScaledMatrix_1.8.1       \n [57] viridis_0.6.4             spatstat.explore_3.2-1   \n [59] jsonlite_1.8.7            GetoptLong_1.0.5         \n [61] ellipsis_0.3.2            progressr_0.14.0         \n [63] ggridges_0.5.4            survival_3.5-7           \n [65] iterators_1.0.14          foreach_1.5.2            \n [67] tools_4.3.2               ica_1.0-3                \n [69] Rcpp_1.0.11               glue_1.6.2               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            HDF5Array_1.28.1         \n [75] withr_2.5.0               fastmap_1.1.1            \n [77] rhdf5filters_1.12.1       fansi_1.0.4              \n [79] openssl_2.1.0             digest_0.6.33            \n [81] rsvd_1.0.5                parallelDist_0.2.6       \n [83] R6_2.5.1                  mime_0.12                \n [85] colorspace_2.1-0          scattermore_1.2          \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] R.methodsS3_1.8.2         utf8_1.2.3               \n [91] tidyr_1.3.0               generics_0.1.3           \n [93] data.table_1.14.8         httr_1.4.6               \n [95] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [97] uwot_0.1.16               pkgconfig_2.0.3          \n [99] gtable_0.3.3              ComplexHeatmap_2.16.0    \n[101] lmtest_0.9-40             XVector_0.40.0           \n[103] htmltools_0.5.7           dotCall64_1.1-0          \n[105] clue_0.3-64               scales_1.3.0             \n[107] png_0.1-8                 knitr_1.43               \n[109] rstudioapi_0.15.0         reshape2_1.4.4           \n[111] rjson_0.2.21              nlme_3.1-163             \n[113] rhdf5_2.44.0              zoo_1.8-12               \n[115] GlobalOptions_0.1.2       stringr_1.5.0            \n[117] KernSmooth_2.23-22        parallel_4.3.2           \n[119] miniUI_0.1.1.1            RcppZiggurat_0.1.6       \n[121] pillar_1.9.0              grid_4.3.2               \n[123] vctrs_0.6.3               RANN_2.6.1               \n[125] promises_1.2.0.1          BiocSingular_1.16.0      \n[127] beachmat_2.16.0           xtable_1.8-4             \n[129] cluster_2.1.6             evaluate_0.21            \n[131] locfit_1.5-9.8            cli_3.6.1                \n[133] compiler_4.3.2            rlang_1.1.1              \n[135] crayon_1.5.2              future.apply_1.11.0      \n[137] labeling_0.4.2            plyr_1.8.8               \n[139] stringi_1.8.1             viridisLite_0.4.2        \n[141] deldir_2.0-2              BiocParallel_1.34.2      \n[143] assertthat_0.2.1          munsell_0.5.0            \n[145] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[147] PCAtools_2.14.0           Matrix_1.6-3             \n[149] RcppHNSW_0.5.0            patchwork_1.1.2          \n[151] sparseMatrixStats_1.12.2  future_1.33.0            \n[153] Rhdf5lib_1.22.0           shiny_1.8.0              \n[155] ROCR_1.0-11               Rfast_2.1.0              \n[157] igraph_1.6.0              RcppParallel_5.1.7"
  },
  {
    "objectID": "GDI_Increment_From_Mixing.html",
    "href": "GDI_Increment_From_Mixing.html",
    "title": "GDI Increment From Mixing",
    "section": "",
    "text": "library(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(parallelDist)\nlibrary(tidyr)\nlibrary(tidyverse)\n#library(COTAN)\n\n#options(parallelly.fork.enable = TRUE)\n\ninDir &lt;- file.path(\"Results\")\n\n#setLoggingLevel(2)\n#setLoggingFile(file.path(inDir, \"MixingClustersGDI_ForebrainDorsal.log\"))\n\noutDir &lt;- file.path(inDir, \"GDI_Sensitivity\")\nif (!file.exists(outDir)) {\n  dir.create(outDir)\n}"
  },
  {
    "objectID": "GDI_Increment_From_Mixing.html#preamble",
    "href": "GDI_Increment_From_Mixing.html#preamble",
    "title": "GDI Increment From Mixing",
    "section": "",
    "text": "library(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(parallelDist)\nlibrary(tidyr)\nlibrary(tidyverse)\n#library(COTAN)\n\n#options(parallelly.fork.enable = TRUE)\n\ninDir &lt;- file.path(\"Results\")\n\n#setLoggingLevel(2)\n#setLoggingFile(file.path(inDir, \"MixingClustersGDI_ForebrainDorsal.log\"))\n\noutDir &lt;- file.path(inDir, \"GDI_Sensitivity\")\nif (!file.exists(outDir)) {\n  dir.create(outDir)\n}"
  },
  {
    "objectID": "GDI_Increment_From_Mixing.html#load-calculated-data-for-analysis",
    "href": "GDI_Increment_From_Mixing.html#load-calculated-data-for-analysis",
    "title": "GDI Increment From Mixing",
    "section": "Load calculated data for analysis",
    "text": "Load calculated data for analysis"
  },
  {
    "objectID": "GDI_Increment_From_Mixing.html#recall-cluster-distance-and-add-it-to-the-results",
    "href": "GDI_Increment_From_Mixing.html#recall-cluster-distance-and-add-it-to-the-results",
    "title": "GDI Increment From Mixing",
    "section": "Recall cluster distance and add it to the results",
    "text": "Recall cluster distance and add it to the results\n\nzeroOneAvg &lt;- readRDS(file.path(outDir, \"allZeroOne.RDS\"))\ndistZeroOne &lt;- as.matrix(parDist(t(zeroOneAvg), method = \"hellinger\", diag = TRUE, upper = TRUE))^2\n\ndistZeroOneLong &lt;- rownames_to_column(as.data.frame(distZeroOne), var = \"MainCluster\")\ndistZeroOneLong &lt;-pivot_longer(distZeroOneLong,\n                               cols = !MainCluster,\n                               names_to = \"OtherCluster\", \n                               values_to = \"Distance\")\n\ndistZeroOneLong &lt;- as.data.frame(distZeroOneLong[distZeroOneLong[[\"Distance\"]] != 0.0, ])\n\nassert_that(identical(distZeroOneLong[, 1:2], resMix20[, 1:2]))\n\n[1] TRUE\n\nperm &lt;- order(distZeroOneLong[[\"Distance\"]])\n\n\n# Scatter plot of the effective increment at 40% mixing [Y]\n# against estimated distance [X]\ndistDF &lt;- cbind(distZeroOneLong[, \"Distance\", drop = FALSE],\n                sqrt(distZeroOneLong[, \"Distance\", drop = FALSE]))\ncolnames(distDF) &lt;- c(\"Distance\", \"DistanceSqrt\")\n\nD2IPlot &lt;- ggplot(cbind(resMix40, distDF),\n                  aes(x=Distance, y=GDIIncrement)) +\n             geom_point() +\n             geom_smooth(method=lm, formula = y ~ x) \n           # +  xlim(0, 1.5) + ylim(0, 1.5) + coord_fixed()\n\nplot(D2IPlot)"
  },
  {
    "objectID": "GDI_Increment_From_Mixing.html#merge-all-data-and-plot-it-using-the-distance-as-discriminant",
    "href": "GDI_Increment_From_Mixing.html#merge-all-data-and-plot-it-using-the-distance-as-discriminant",
    "title": "GDI Increment From Mixing",
    "section": "Merge all data and plot it using the distance as discriminant",
    "text": "Merge all data and plot it using the distance as discriminant\n\nallRes &lt;- rbind(resMix05[perm, ], resMix10[perm, ], resMix20[perm, ], resMix40[perm, ], resMix80[perm, ])\nallRes &lt;- cbind(allRes, \"Distance\" = rep(distZeroOneLong[[\"Distance\"]][perm], 5))\nrownames(allRes) &lt;- NULL\nallRes &lt;- cbind(allRes, \"ClusterPair\" = rep.int(c(1:210),5))\n\n\nallResWithBase &lt;- cbind(resMix00[perm, ], \"Distance\" = distZeroOneLong[[\"Distance\"]][perm])\nrownames(allResWithBase) &lt;- NULL\nallResWithBase &lt;- cbind(allResWithBase, \"ClusterPair\" = c(1:210))\nallResWithBase &lt;- rbind(allResWithBase, allRes)\n\nassert_that(identical(allRes[, 4], allResWithBase[211:1260, 4]))\n\n[1] TRUE\n\n\n\ndim(allRes)\n\n[1] 1050    7\n\n\n\nIScPlot &lt;- ggplot(allRes, aes(x=MixingFraction, y=GDIIncrement, color=Distance,)) +\n  geom_point() +\n  scale_color_continuous(type = \"viridis\") +\n  scale_x_log10()\n\nplot(IScPlot)\n\n\n\nGScPlot &lt;- ggplot(allResWithBase, aes(x=MixingFraction, y=GDI, color=Distance,)) +\n  geom_point() +\n  scale_color_continuous(type = \"viridis\")\n\nplot(GScPlot)\n\n\n\n\n\nreOrder &lt;- function(df, numBlocks) {\n  blockLength &lt;- nrow(df) / numBlocks\n  permut &lt;- rep(1:blockLength, each = numBlocks) +\n              rep(seq(0, nrow(df) - 1, by = blockLength), times = numBlocks)\n  return(df[permut, ])\n}\n\nallRes2 &lt;- reOrder(allRes, 5)\nallResWithBase2 &lt;- reOrder(allResWithBase, 6)\n\n\nrng &lt;- c(1,210)\n#rng &lt;- c(1,42)\n#rng &lt;- c(43,84)\n#rng &lt;- c(85,126)\n#rng &lt;- c(127,168)\n#rng &lt;- c(169,210)\n\nILinesPLot &lt;- ggplot(allRes2[allRes2[[\"ClusterPair\"]] %between% rng, ],\n                     aes(x = MixingFraction, y = GDIIncrement,\n                         color = (ClusterPair - 1) %/% 35 + 0.5)) + \n  geom_path(aes(group = ClusterPair)) +\n  theme(legend.position = \"none\") +\n  #scale_x_log10() + \n  scale_colour_stepsn(colours = hcl.colors(6, palette = \"Dark 2\")[6:1])\n\nplot(ILinesPLot)\n\n\n\nGLinesPLot &lt;- ggplot(allResWithBase2[allResWithBase2[[\"ClusterPair\"]] %between% rng, ],\n                     aes(x = MixingFraction, y = GDI,\n                         color = (ClusterPair - 1) %/% 35 + 0.5)) + \n  geom_path(aes(group = ClusterPair)) +\n  theme(legend.position = \"none\") +\n  #scale_x_log10() + \n  scale_colour_stepsn(colours = hcl.colors(6, palette = \"Dark 2\")[6:1]) \n#  geom_line(data = data.frame(cbind(MixingFraction = c(0,0.8), GDI = c(1.4,1.4))),\n#            aes(x = MixingFraction, y = GDI))\n\n\nplot(GLinesPLot)\n\n\n\n\n\nmg &lt;- function(mixings) {\n  res &lt;- mixings\n  res[res !=0 ] &lt;- ceiling(log2(round(res[res !=0 ] * 40)))\n  return(res)\n}\n\nrng &lt;- c(1,35)\n#rng &lt;- c(43,84)\n#rng &lt;- c(85,126)\n#rng &lt;- c(127,168)\n#rng &lt;- c(169,210)\n\nallRes$Group &lt;- factor((allRes$ClusterPair - 1) %/% 35 + 1)\nlevels(allRes$Group) &lt;- paste0(\"Distance bin \",c(1:6))\n\nallRes$discreteMixing &lt;- factor(mg(allRes$MixingFraction))\nlevels(allRes$discreteMixing) &lt;- c(\"0%\",\"5%\",\"10%\",\"20%\",\"40%\",\"80%\")\n\nIBoxPlot &lt;- ggplot(allRes, aes(x=discreteMixing, \n                       y=GDIIncrement, \n                       fill=Group,\n                       group = discreteMixing)) +\n  geom_boxplot()+\n  geom_jitter(width=0.25, alpha=0.5) +\n  scale_colour_stepsn(colours = hcl.colors(6, palette = \"Dark 2\")[6:1]) +\n  facet_wrap(. ~ Group, ncol = 3)+\n  theme(legend.position = \"none\") \n\n\nplot(IBoxPlot)\n\n\n\nallResWithBase$Group &lt;- factor((allResWithBase$ClusterPair - 1) %/% 35 + 1)\nlevels(allResWithBase$Group) &lt;- paste0(\"Distance bin \",c(1:6))\n\n\nallResWithBase$discreteMixing &lt;- factor(mg(allResWithBase$MixingFraction))\nlevels(allResWithBase$discreteMixing) &lt;- c(\"0%\",\"5%\",\"10%\",\"20%\",\"40%\",\"80%\")\n\nGBoxPlot &lt;- ggplot(allResWithBase,\n                   aes(x=discreteMixing, y=GDI, fill=Group,\n                              group = discreteMixing))+\n  geom_boxplot() +\n  geom_jitter(width=0.25, alpha=0.5) +\n  scale_colour_stepsn(colours = hcl.colors(6, palette = \"Dark 2\")[6:1]) +\n  facet_wrap(. ~ Group, ncol = 3)+\n  theme(legend.position = \"none\") \n\nplot(GBoxPlot)"
  },
  {
    "objectID": "GDI_Increment_From_Mixing.html#load-calculated-data-about-multi-clusters-cases-for-analysis",
    "href": "GDI_Increment_From_Mixing.html#load-calculated-data-about-multi-clusters-cases-for-analysis",
    "title": "GDI Increment From Mixing",
    "section": "Load calculated data about multi clusters cases for analysis",
    "text": "Load calculated data about multi clusters cases for analysis"
  },
  {
    "objectID": "GDI_Increment_From_Mixing.html#compare-estimated-vs-real-gdi-increment",
    "href": "GDI_Increment_From_Mixing.html#compare-estimated-vs-real-gdi-increment",
    "title": "GDI Increment From Mixing",
    "section": "Compare estimated vs real GDI increment",
    "text": "Compare estimated vs real GDI increment\n\n# Scatter plot of the effective increment [Y] against estimated increment [X]\npg &lt;- ggplot(resMix20_2, aes(x=PredictedGDIIncrement, y=GDIIncrement)) +\n  geom_point() +\n  geom_smooth(method=lm, formula = y ~ x + 0) +\n  coord_fixed() +\n  xlim(0, 1.5) + ylim(0, 1.5)\n  #scale_x_log10() + scale_y_log10() \n\nplot(pg)\n\n\n\n\nThe plot shows that having the 20% extraneous cells in the mixture coming from multiple clusters does not affect significantly the sensitivity of the GDI to score cluster uniformity.\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] lubridate_1.9.2    forcats_1.0.0      stringr_1.5.0      dplyr_1.1.2       \n [5] purrr_1.0.1        readr_2.1.4        tibble_3.2.1       tidyverse_2.0.0   \n [9] tidyr_1.3.0        parallelDist_0.2.6 data.table_1.14.8  zeallot_0.1.0     \n[13] ggplot2_3.4.2      scales_1.3.0       rlang_1.1.1        assertthat_0.2.1  \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.3         generics_0.1.3     lattice_0.22-5     stringi_1.8.1     \n [5] hms_1.1.3          digest_0.6.33      magrittr_2.0.3     evaluate_0.21     \n [9] grid_4.3.2         timechange_0.2.0   fastmap_1.1.1      Matrix_1.6-3      \n[13] jsonlite_1.8.7     mgcv_1.9-1         fansi_1.0.4        viridisLite_0.4.2 \n[17] cli_3.6.1          munsell_0.5.0      splines_4.3.2      withr_2.5.0       \n[21] yaml_2.3.7         tools_4.3.2        tzdb_0.4.0         colorspace_2.1-0  \n[25] vctrs_0.6.3        R6_2.5.1           lifecycle_1.0.3    htmlwidgets_1.6.2 \n[29] pkgconfig_2.0.3    RcppParallel_5.1.7 pillar_1.9.0       gtable_0.3.3      \n[33] glue_1.6.2         Rcpp_1.0.11        xfun_0.39          tidyselect_1.2.0  \n[37] rstudioapi_0.15.0  knitr_1.43         farver_2.1.1       htmltools_0.5.7   \n[41] nlme_3.1-163       labeling_0.4.2     rmarkdown_2.24     compiler_4.3.2"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "",
    "text": "library(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\nlibrary(parallelDist)\nlibrary(tibble)\nlibrary(tidyr)\n\noptions(parallelly.fork.enable = TRUE)\n\ninDir &lt;- file.path(\"Data/MouseCortexFromLoom/\")\n\noutDir &lt;- file.path(\"Results/GDI_Sensitivity\")\nif (!file.exists(outDir)) {\n  dir.create(outDir)\n}\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"MixingClustersGDI_ForebrainDorsal.log\"))"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#preamble",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#preamble",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "",
    "text": "library(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\nlibrary(parallelDist)\nlibrary(tibble)\nlibrary(tidyr)\n\noptions(parallelly.fork.enable = TRUE)\n\ninDir &lt;- file.path(\"Data/MouseCortexFromLoom/\")\n\noutDir &lt;- file.path(\"Results/GDI_Sensitivity\")\nif (!file.exists(outDir)) {\n  dir.create(outDir)\n}\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"MixingClustersGDI_ForebrainDorsal.log\"))"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#loading-all-cotan-objects",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#loading-all-cotan-objects",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Loading all COTAN Objects",
    "text": "Loading all COTAN Objects\n\nfb135Obj &lt;- readRDS(file = file.path(inDir, \"e13.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nfb150Obj &lt;- readRDS(file = file.path(inDir, \"e15.0_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\n\nfb175Obj &lt;- readRDS(file = file.path(inDir, \"e17.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#relevant-clusters-lists",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#relevant-clusters-lists",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Relevant clusters lists",
    "text": "Relevant clusters lists"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#merge-clusters-from-different-datasets",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#merge-clusters-from-different-datasets",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Merge clusters from different datasets",
    "text": "Merge clusters from different datasets\n\nallGenes &lt;- union(union(getGenes(fb135Obj), getGenes(fb150Obj)), getGenes(fb175Obj))\n\n# This function completes the raw data so that the genes list\n# matches the `allGenes` above\nfillGenes &lt;- function(m, prefixName) {\n  # find the missing genes in the given matrix m\n  missingGenes &lt;- !(allGenes %in% rownames(m))\n  # create a matrix with the right sizes for the missing genes\n  # and set their values all to zero\n  fillM &lt;- matrix(0, nrow = sum(missingGenes), ncol = ncol(m))\n  rownames(fillM) &lt;- allGenes[missingGenes]\n  # append the new matrix to the original and reorder the rows\n  # to match overall genes order\n  retM &lt;- rbind(m, fillM)\n  retM &lt;- retM[allGenes, ]\n  # assign unique identifiers to the columns, so that one can discriminate\n  # the source even after merging with other matrices\n  colnames(retM) &lt;- paste0(prefixName, \"_\", colnames(retM))\n  return(retM)\n}"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#create-all-raw-data-for-each-cluster-compatible-with-the-full-genes-list",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#create-all-raw-data-for-each-cluster-compatible-with-the-full-genes-list",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Create all raw data for each cluster compatible with the full genes’ list",
    "text": "Create all raw data for each cluster compatible with the full genes’ list\n\nallClustersRawData &lt;- list()\nfor (dsName in names(selected)) {\n  clList &lt;- toClustersList(getClusters(objSelector(dsName),\n                                       clName = \"original.clusters\"))\n  for (clName in selected[[dsName]]) {\n    fullName &lt;- paste0(dsName, \":\", clName)\n    fullRawData &lt;- fillGenes(getRawData(objSelector(dsName))[, clList[[clName]]],\n                             fullName)\n    allClustersRawData &lt;- append(allClustersRawData, list(fullRawData))\n    names(allClustersRawData)[length(allClustersRawData)] &lt;- fullName\n  }\n}\n\nassert_that(identical(rownames(allClustersRawData[[1]]), allGenes))\n\n# delete the COTAN objects\nrm(fb135Obj, fb150Obj, fb175Obj)"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#collect-size-and-gdi-for-all-selected-clusters-baseline-data",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#collect-size-and-gdi-for-all-selected-clusters-baseline-data",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Collect size and GDI for all selected clusters (baseline data)",
    "text": "Collect size and GDI for all selected clusters (baseline data)\n\nclDataFB135 &lt;- readRDS(file.path(inDir, \"e13.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\nclDataFB150 &lt;- readRDS(file.path(inDir, \"e15.0_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\nclDataFB175 &lt;- readRDS(file.path(inDir, \"e17.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\n\ndf1 &lt;- clDataFB135[selected[[\"E13.5\"]], c(\"size\", \"X1stPercentile\"), drop = FALSE]\nrownames(df1) &lt;- paste0(\"E13.5:\", rownames(df1))\n\ndf2 &lt;- clDataFB150[selected[[\"E15.0\"]], c(\"size\", \"X1stPercentile\"), drop = FALSE]\nrownames(df2) &lt;- paste0(\"E15.0:\", rownames(df2))\n\ndf3 &lt;- clDataFB175[selected[[\"E17.5\"]], c(\"size\", \"X1stPercentile\"), drop = FALSE]\nrownames(df3) &lt;- paste0(\"E17.5:\", rownames(df3))\n\nbaselineGDI &lt;- rbind(df1, df2, df3)\ncolnames(baselineGDI) &lt;- c(\"size\", \"GDI\")\n\nrm(clDataFB135, clDataFB150, clDataFB175)\nrm(df1, df2, df3)\n\nsaveRDS(baselineGDI,\n        file = file.path(outDir, \"ForebrainDorsal_ClusterizationMixing_BaselineGDI.RDS\"))"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#load-baseline-data",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#load-baseline-data",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Load baseline data",
    "text": "Load baseline data\n\nbaselineGDI &lt;- readRDS(file.path(outDir, \"ForebrainDorsal_ClusterizationMixing_BaselineGDI.RDS\"))\n\n# check good alignment of data\nassert_that(identical(rownames(baselineGDI), names(allClustersRawData)))\nassert_that(identical(baselineGDI[, \"size\"],\n                      vapply(allClustersRawData, ncol,\n                             FUN.VALUE = integer(1L), USE.NAMES = FALSE)))"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#calculate-the-gdi-of-the-mixtures-of-clusters",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#calculate-the-gdi-of-the-mixtures-of-clusters",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Calculate the GDI of the mixtures of clusters",
    "text": "Calculate the GDI of the mixtures of clusters\n\nThis is to be run once per wanted mixing-fraction\n\n# small run\n# \nset.seed(137)\n\nmixingFraction &lt;- 0.80\nmixingStr &lt;- str_pad(scales::label_percent()(mixingFraction), 3, pad = \"0\")\n\nresults &lt;- data.frame()\n\nfor (mainName in rownames(baselineGDI)) {\n  mainSize &lt;- baselineGDI[mainName, \"size\"]\n  mainGDI  &lt;- baselineGDI[mainName, \"GDI\"]\n\n  for (clName in rownames(baselineGDI)) {\n    if (clName == mainName) next\n\n    logThis(paste(\"Mixing\", mainName, \"with extra\",\n                  mixingStr, \"cells from\", clName), logLevel = 1)\n\n    clSize &lt;- baselineGDI[clName, \"size\"]\n    actuallyMixedCells &lt;- min(ceiling(mixingFraction * mainSize), clSize)\n    actualFraction &lt;- actuallyMixedCells / mainSize\n    sampleRawData &lt;- allClustersRawData[[clName]][, sample(clSize, actuallyMixedCells)]\n    mergedRawData &lt;- cbind(allClustersRawData[[mainName]], sampleRawData)\n    rm(sampleRawData)\n\n    # Calculate the merged COEX\n    cond &lt;- paste0(mainName, \"|\", mixingStr, \"|\", clName)\n    mergedObj &lt;- automaticCOTANObjectCreation(raw = mergedRawData,\n                                              GEO = \"MergedClusters\",\n                                              sequencingMethod = \"10X\",\n                                              sampleCondition = cond,\n                                              calcCoex = TRUE, cores = 10L,\n                                              saveObj = FALSE, outDir = outDir)\n    rm(mergedRawData)\n\n    # Extract the GDI quantile\n    mergedGDIData &lt;- calculateGDI(mergedObj)\n    rm(mergedObj)\n\n    gdi &lt;- mergedGDIData[[\"GDI\"]]\n    names(gdi) &lt;- rownames(mergedGDIData)\n    rm(mergedGDIData)\n\n    gdi &lt;- sort(gdi, decreasing = TRUE)\n    lastPercentile &lt;- quantile(gdi, probs = 0.99)\n    rm(gdi)\n\n    results &lt;- rbind(results,\n                     data.frame(\"MainCluster\" = mainName, \"OtherCluster\" = clName,\n                                \"MixingFraction\" = actualFraction, \"GDI\" = lastPercentile,\n                                \"GDIIncrement\" = lastPercentile - mainGDI))\n\n    logThis(paste(\"Mixing\", mainName, \"with\", clName,\n                  \"accomplished with GDI\", lastPercentile), logLevel = 1)\n  }\n}\n\nrownames(results) &lt;- NULL\n\nsaveRDS(results, file.path(outDir, paste0(\"GDI_with_\", mixingStr, \"_Mixing.RDS\")))"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#load-calculated-data-for-analysis",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#load-calculated-data-for-analysis",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Load calculated data for analysis",
    "text": "Load calculated data for analysis"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#merge-all-results-and-calculate-the-fitting-regression-for-each-cluster-pair",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#merge-all-results-and-calculate-the-fitting-regression-for-each-cluster-pair",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Merge all results and calculate the fitting regression for each cluster pair",
    "text": "Merge all results and calculate the fitting regression for each cluster pair"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#recall-cluster-distance-and-add-it-to-the-results",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#recall-cluster-distance-and-add-it-to-the-results",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Recall cluster distance and add it to the results",
    "text": "Recall cluster distance and add it to the results\n\n#zeroOneAvg &lt;- readRDS(file.path(inDir, \"ClustersDistances\", \"allZeroOne.RDS\"))\nzeroOneAvg &lt;- readRDS(file.path(outDir, \"distanceZeroOne.RDS\"))\ndistZeroOne &lt;- as.matrix(parDist(t(zeroOneAvg), method = \"hellinger\", diag = TRUE, upper = TRUE))^2\n\ndistZeroOneLong &lt;- rownames_to_column(as.data.frame(distZeroOne), var = \"MainCluster\")\ndistZeroOneLong &lt;-pivot_longer(distZeroOneLong,\n                               cols = !MainCluster,\n                               names_to = \"OtherCluster\", \n                               values_to = \"Distance\")\n\ndistZeroOneLong &lt;- as.data.frame(distZeroOneLong[distZeroOneLong[[\"Distance\"]] != 0.0, ])\n\n#assert_that(identical(distZeroOneLong[, 1:2], resMix20[, 1:2]))\n\nperm &lt;- order(distZeroOneLong[[\"Distance\"]])\n\n\n# Scatter plot of the effective increment [Y] against estimated increment [X]\ndistDF &lt;- cbind(distZeroOneLong[, \"Distance\", drop = FALSE],\n                sqrt(distZeroOneLong[, \"Distance\", drop = FALSE]))\ncolnames(distDF) &lt;- c(\"Distance\", \"DistanceSqrt\")\n\nD2IPlot &lt;- ggplot(cbind(resMix40, distDF),\n                  aes(x=Distance, y=GDIIncrement)) +\n             geom_point() +\n             geom_smooth(method=lm, formula = y ~ x) \n           # +  xlim(0, 1.5) + ylim(0, 1.5) + coord_fixed()\n\nplot(D2IPlot)"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#merge-all-data-and-plot-it-using-a-priory-squared-distance-as-discriminant",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#merge-all-data-and-plot-it-using-a-priory-squared-distance-as-discriminant",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Merge all data and plot it using a-priory (squared) distance as discriminant",
    "text": "Merge all data and plot it using a-priory (squared) distance as discriminant\n\nallRes &lt;- rbind(resMix05[perm, ], resMix10[perm, ], resMix20[perm, ], resMix40[perm, ], resMix80[perm, ])\nrownames(allRes) &lt;- NULL\nallRes &lt;- cbind(allRes, \"ClusterPair\" = rep.int(c(1:210),5))\nallRes &lt;- cbind(allRes, \"Distance\" = rep(distZeroOneLong[[\"Distance\"]][perm], 5))\n\n\nmg &lt;- function(mixing) { ceiling(log2(round(mixing*40))) }\nIScPlot &lt;- ggplot(allRes, aes(x=mg(MixingFraction), y=GDIIncrement, color=Distance,\n                              group = mg(MixingFraction))) +\n#  geom_point() +\n  geom_boxplot()\n#  scale_color_continuous(type = \"viridis\") +\n# geom_point(aes(size=log10(GDIIncrement+10))) +\n#  scale_x_log10()\n\nplot(IScPlot)\n\n\n\n\n\nperm2 &lt;- rep(1:210, each = 5) + rep(seq(1, 5 * 210, by = 210), times = 5) - 1\nallRes2 &lt;- allRes[perm2, ]\n# c(1,44) - c(84,127) - c(167,210)\nILinesPLot &lt;- ggplot(allRes2[allRes2[[\"ClusterPair\"]] %between% c(1,210), ],\n                     aes(x = MixingFraction, y = GDIIncrement,\n                         color = (ClusterPair - 1) %/% 42 + 0.5)) + \n  geom_path(aes(group = ClusterPair)) +\n  theme(legend.position = \"none\") +\n  #scale_x_log10() + \n  scale_colour_stepsn(colours = hcl.colors(5, palette = \"Dark 2\")[5:1])\n\n\nplot(ILinesPLot)"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#calculate-the-gdi-of-the-mixtures-of-three-clusters",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#calculate-the-gdi-of-the-mixtures-of-three-clusters",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Calculate the GDI of the mixtures of three clusters",
    "text": "Calculate the GDI of the mixtures of three clusters\n\nthe total mixture is 20%\n\n# small run\n# \nset.seed(137)\n\nnumPairsPerCluster &lt;- 10\n\nmixingFraction &lt;- 0.20\n\nresults &lt;- data.frame()\n\nfor (mainName in rownames(baselineGDI)) {\n  mainSize &lt;- baselineGDI[mainName, \"size\"]\n  mainGDI  &lt;- baselineGDI[mainName, \"GDI\"]\n\n  executedPairs &lt;- NULL\n  \n  for (i in c(1:numPairsPerCluster)) {\n    repeat {\n      clPair &lt;- rownames(baselineGDI)[sample(nrow(baselineGDI), 2)]\n      clPair &lt;- clPair[order(clPair)]\n      clPairName &lt;- paste0(clPair[[1L]], \":\", clPair[[2L]])\n      if (!(mainName %in% clPair) && !(clPairName %in% executedPairs)) break\n    }\n\n    logThis(paste(\"Mixing\", mainName, \"with extra 20% cells from\",\n                  clPair[[1L]], \"and\", clPair[[2L]]), logLevel = 1)\n\n    mixingFraction1 &lt;- runif(1L, 0.25 * mixingFraction, 0.75 * mixingFraction)\n    mixingFraction2 &lt;- mixingFraction - mixingFraction1\n    \n    clSize1 &lt;- baselineGDI[clPair[[1L]], \"size\"]\n    clSize2 &lt;- baselineGDI[clPair[[2L]], \"size\"]\n    actuallyMixedCells1 &lt;- min(ceiling(mixingFraction1 * mainSize), clSize1)\n    actuallyMixedCells2 &lt;- min(ceiling(mixingFraction2 * mainSize), clSize2)\n    actualFraction1 &lt;- actuallyMixedCells1 / mainSize\n    actualFraction2 &lt;- actuallyMixedCells2 / mainSize\n    sampleRawData1 &lt;- allClustersRawData[[clPair[[1L]]]][, sample(clSize1, actuallyMixedCells1)]\n    sampleRawData2 &lt;- allClustersRawData[[clPair[[2L]]]][, sample(clSize2, actuallyMixedCells2)]\n    mergedRawData &lt;- cbind(allClustersRawData[[mainName]], sampleRawData1, sampleRawData2)\n    rm(sampleRawData1, sampleRawData2)\n\n    # Calculate the merged COEX\n    cond &lt;- paste0(mainName, \"|20%|\", clPairName)\n    mergedObj &lt;- automaticCOTANObjectCreation(raw = mergedRawData,\n                                              GEO = \"MergedClusters\",\n                                              sequencingMethod = \"10X\",\n                                              sampleCondition = cond,\n                                              calcCoex = TRUE, cores = 10L,\n                                              saveObj = FALSE, outDir = outDir)\n    rm(mergedRawData)\n\n    # Extract the GDI quantile\n    mergedGDIData &lt;- calculateGDI(mergedObj)\n    rm(mergedObj)\n\n    gdi &lt;- mergedGDIData[[\"GDI\"]]\n    names(gdi) &lt;- rownames(mergedGDIData)\n    rm(mergedGDIData)\n\n    gdi &lt;- sort(gdi, decreasing = TRUE)\n    lastPercentile &lt;- quantile(gdi, probs = 0.99)\n    rm(gdi)\n\n    results &lt;- rbind(results,\n                     data.frame(\"MainCluster\" = mainName,\n                                \"OtherCluster1\" = clPair[[1L]],\n                                \"MixingFraction1\" = actualFraction1,\n                                \"OtherCluster2\" = clPair[[2L]],\n                                \"MixingFraction2\" = actualFraction2,\n                                \"GDI\" = lastPercentile,\n                                \"GDIIncrement\" = lastPercentile - mainGDI))\n\n    logThis(paste(\"Mixing\", mainName, \"with\", clPairName,\n                  \"accomplished with GDI\", lastPercentile), logLevel = 1)\n  }\n}\n\nrownames(results) &lt;- NULL\n\nsaveRDS(results, file.path(outDir, paste0(\"GDI_with_20%_Mixing_from_Pairs.RDS\")))"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#estimate-predicted-gdi-increment-using-resultts-from-two-clusters-mixings",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#estimate-predicted-gdi-increment-using-resultts-from-two-clusters-mixings",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Estimate predicted GDI increment using resultts from two-clusters mixings",
    "text": "Estimate predicted GDI increment using resultts from two-clusters mixings\n\nThe estimates assume GDI increment proportional to mixture\n\nresMix20_2 &lt;- readRDS(file.path(outDir, paste0(\"GDI_with_20%_Mixing_from_Pairs.RDS\")))\n\nresMix20_2 &lt;- cbind(resMix20_2, NA)\ncolnames(resMix20_2)[ncol(resMix20_2)] &lt;- \"PredictedGDIIncrement\"\n\nfor (r in c(1:nrow(resMix20_2))) {\n  mainName &lt;- resMix20_2[r, \"MainCluster\"]\n  \n  mainMatch20 &lt;- resMix20[resMix20[, \"MainCluster\"] == mainName, ]\n\n  pos1 &lt;- which(mainMatch20[, \"OtherCluster\"] == resMix20_2[r, \"OtherCluster1\"])\n  pos2 &lt;- which(mainMatch20[, \"OtherCluster\"] == resMix20_2[r, \"OtherCluster2\"])\n  \n  GDIIncr1 &lt;- mainMatch20[pos1, \"GDIIncrement\"]\n  GDIIncr2 &lt;- mainMatch20[pos2, \"GDIIncrement\"]\n\n  w1 &lt;- resMix20_2[r, \"MixingFraction1\"] / mainMatch20[pos1, \"MixingFraction\"]\n  w2 &lt;- resMix20_2[r, \"MixingFraction2\"] / mainMatch20[pos2, \"MixingFraction\"]\n  \n  predictedGDIIncr &lt;- (w1 * GDIIncr1 + w2 * GDIIncr2)\n\n  resMix20_2[r, \"PredictedGDIIncrement\"] &lt;- predictedGDIIncr\n}\n\nsaveRDS(resMix20_2, file.path(outDir, paste0(\"GDI_with_20%_Mixing_from_Pairs.RDS\")))"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#load-calculated-data-for-analysis-1",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#load-calculated-data-for-analysis-1",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Load calculated data for analysis",
    "text": "Load calculated data for analysis"
  },
  {
    "objectID": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#compare-estimated-vs-real-gdi-increment",
    "href": "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity.html#compare-estimated-vs-real-gdi-increment",
    "title": "Mixing Uniform Clusters To Estimate GDI Sensitivity",
    "section": "Compare estimated vs real GDI increment",
    "text": "Compare estimated vs real GDI increment\n\n# Scatter plot of the effective increment [Y] against estimated increment [X]\npg &lt;- ggplot(resMix20_2, aes(x=PredictedGDIIncrement, y=GDIIncrement)) +\n  geom_point() +\n  geom_smooth(method=lm, formula = y ~ x + 0) +\n  coord_fixed() +\n  xlim(0, 1.5) + ylim(0, 1.5)\n  #scale_x_log10() + scale_y_log10() \n\nplot(pg)\n\n\n\n\nThe plot shows that having the 20% extraneous cells in the mixture coming from multiple clusters does not affect significantly the sensitivity of the GDI to score cluster uniformity.\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] tidyr_1.3.0        tibble_3.2.1       parallelDist_0.2.6 COTAN_2.3.0       \n [5] data.table_1.14.8  zeallot_0.1.0      ggplot2_3.4.2      scales_1.3.0      \n [9] rlang_1.1.1        assertthat_0.2.1  \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               polyclip_1.10-4          \n  [5] fastDummies_1.7.3         lifecycle_1.0.3          \n  [7] doParallel_1.0.17         globals_0.16.2           \n  [9] lattice_0.22-5            MASS_7.3-60              \n [11] dendextend_1.17.1         magrittr_2.0.3           \n [13] plotly_4.10.2             rmarkdown_2.24           \n [15] yaml_2.3.7                httpuv_1.6.11            \n [17] Seurat_5.0.0              sctransform_0.4.1        \n [19] spam_2.10-0               askpass_1.2.0            \n [21] sp_2.1-1                  spatstat.sparse_3.0-2    \n [23] reticulate_1.34.0         cowplot_1.1.1            \n [25] pbapply_1.7-2             RColorBrewer_1.1-3       \n [27] abind_1.4-5               Rtsne_0.16               \n [29] purrr_1.0.1               BiocGenerics_0.46.0      \n [31] circlize_0.4.15           IRanges_2.34.1           \n [33] S4Vectors_0.38.1          ggrepel_0.9.3            \n [35] irlba_2.3.5.1             listenv_0.9.0            \n [37] spatstat.utils_3.0-3      umap_0.2.10.0            \n [39] goftest_1.2-3             RSpectra_0.16-1          \n [41] spatstat.random_3.2-1     dqrng_0.3.0              \n [43] fitdistrplus_1.1-11       parallelly_1.36.0        \n [45] DelayedMatrixStats_1.22.5 leiden_0.4.3             \n [47] codetools_0.2-19          DelayedArray_0.26.7      \n [49] tidyselect_1.2.0          shape_1.4.6              \n [51] farver_2.1.1              ScaledMatrix_1.8.1       \n [53] viridis_0.6.4             matrixStats_1.2.0        \n [55] stats4_4.3.2              spatstat.explore_3.2-1   \n [57] jsonlite_1.8.7            GetoptLong_1.0.5         \n [59] ellipsis_0.3.2            progressr_0.14.0         \n [61] ggridges_0.5.4            survival_3.5-7           \n [63] iterators_1.0.14          foreach_1.5.2            \n [65] tools_4.3.2               ica_1.0-3                \n [67] Rcpp_1.0.11               glue_1.6.2               \n [69] gridExtra_2.3             xfun_0.39                \n [71] mgcv_1.9-1                MatrixGenerics_1.12.3    \n [73] ggthemes_5.0.0            dplyr_1.1.2              \n [75] withr_2.5.0               fastmap_1.1.1            \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] R6_2.5.1                  mime_0.12                \n [83] colorspace_2.1-0          scattermore_1.2          \n [85] tensor_1.5                spatstat.data_3.0-1      \n [87] utf8_1.2.3                generics_0.1.3           \n [89] httr_1.4.6                htmlwidgets_1.6.2        \n [91] S4Arrays_1.2.0            uwot_0.1.16              \n [93] pkgconfig_2.0.3           gtable_0.3.3             \n [95] ComplexHeatmap_2.16.0     lmtest_0.9-40            \n [97] htmltools_0.5.7           dotCall64_1.1-0          \n [99] clue_0.3-64               SeuratObject_5.0.0       \n[101] png_0.1-8                 knitr_1.43               \n[103] rstudioapi_0.15.0         reshape2_1.4.4           \n[105] rjson_0.2.21              nlme_3.1-163             \n[107] zoo_1.8-12                GlobalOptions_0.1.2      \n[109] stringr_1.5.0             KernSmooth_2.23-22       \n[111] parallel_4.3.2            miniUI_0.1.1.1           \n[113] RcppZiggurat_0.1.6        pillar_1.9.0             \n[115] grid_4.3.2                vctrs_0.6.3              \n[117] RANN_2.6.1                promises_1.2.0.1         \n[119] BiocSingular_1.16.0       beachmat_2.16.0          \n[121] xtable_1.8-4              cluster_2.1.6            \n[123] evaluate_0.21             cli_3.6.1                \n[125] compiler_4.3.2            crayon_1.5.2             \n[127] future.apply_1.11.0       labeling_0.4.2           \n[129] plyr_1.8.8                stringi_1.8.1            \n[131] viridisLite_0.4.2         deldir_2.0-2             \n[133] BiocParallel_1.34.2       munsell_0.5.0            \n[135] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[137] PCAtools_2.14.0           Matrix_1.6-3             \n[139] RcppHNSW_0.5.0            patchwork_1.1.2          \n[141] sparseMatrixStats_1.12.2  future_1.33.0            \n[143] shiny_1.8.0               ROCR_1.0-11              \n[145] Rfast_2.1.0               igraph_1.6.0             \n[147] RcppParallel_5.1.7"
  },
  {
    "objectID": "ForebrainDorsal_E150-analysis.html",
    "href": "ForebrainDorsal_E150-analysis.html",
    "title": "Forebrain Dorsal E15.0 Data-set Anaysis",
    "section": "",
    "text": "library(ggplot2)\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"Data/MouseCortexFromLoom/\"\n\nsetLoggingLevel(1)\nsetLoggingFile(file.path(outDir, \"ForebrainDorsal_E150-analysis.log\"))"
  },
  {
    "objectID": "ForebrainDorsal_E150-analysis.html#cleaning",
    "href": "ForebrainDorsal_E150-analysis.html#cleaning",
    "title": "Forebrain Dorsal E15.0 Data-set Anaysis",
    "section": "Cleaning",
    "text": "Cleaning\nRead the already created COTAN object\n\nfb150Obj &lt;- readRDS(\"Data/MouseCortexFromLoom/SourceData/e15.0_ForebrainDorsal.cotan.RDS\")\nsampleCondition &lt;- getMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\nsampleCondition\n\n[1] \"e15.0_ForebrainDorsal\"\n\n\nInspect cells’ sizes\n\ncellSizePlot(fb150Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nDrop cells with too many ritz reads as they are probably duplets\n\ncellsSizeThr &lt;- 10000\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Cells size threshold\", cellsSizeThr)\n\ncells_to_rem &lt;- getCells(fb150Obj)[getCellsSize(fb150Obj) &gt; cellsSizeThr]\nfb150Obj &lt;- dropGenesCells(fb150Obj, cells = cells_to_rem)\n\ncellSizePlot(fb150Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(fb150Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nDrop cells with too low genes expession as they are probably dead\n\ngenesSizeLowThr &lt;- 700\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Num genes low threshold\", genesSizeLowThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(fb150Obj)\ncells_to_rem &lt;- names(numExprGenes)[numExprGenes &lt; genesSizeLowThr]\nfb150Obj &lt;- dropGenesCells(fb150Obj, cells = cells_to_rem)\n\ngenesSizePlot(fb150Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nCheck number of mitocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^mt.\"\ngetGenes(fb150Obj)[grep(mitGenesPattern, getGenes(fb150Obj))]\n\n[1] \"mt.Co1\"  \"mt.Nd4\"  \"mt.Nd5\"  \"mt.Nd1\"  \"mt.Nd2\"  \"mt.Atp6\"\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(fb150Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \":\", numCol = 1)\n\nplot(mitPlot)\n\n\n\n\nCells with a too high percentage of mitocondrial genes are likely dead (or at the last problematic) cells. So we drop them!\n\nmitPercThr &lt;- 1.0\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Mitoc. perc. threshold\", mitPercThr)\n\ncells_to_rem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\nfb150Obj &lt;- dropGenesCells(fb150Obj, cells = cells_to_rem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(fb150Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \":\", numCol = 1)\n\nplot(mitPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(fb150Obj, splitPattern = \":\", numCol = 1)\n\n\n\ngenesSizePlot(fb150Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\n\nClean: round 1\n\nfb150Obj &lt;- clean(fb150Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb150Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Num drop B group\", 0)\n\nB group contains highly diverse cells: drop them!\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\nfb150Obj &lt;- dropGenesCells(fb150Obj, cells = cells_to_rem)\n\n\n\nClean: round 2\n\nfb150Obj &lt;- clean(fb150Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb150Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Num drop B group\", 1)\n\nB group contains one cell with high diversity in the higher components\n\nplot(pcaCellsData)\n\n\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\nfb150Obj &lt;- dropGenesCells(fb150Obj, cells = cells_to_rem)\n\n\n\nClean: round 3\n\nfb150Obj &lt;- clean(fb150Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb150Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Num drop B group\", 2)\n\nB group contains one cell with high diversity in the higher components\n\nplot(pcaCellsData)\n\n\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\nfb150Obj &lt;- dropGenesCells(fb150Obj, cells = cells_to_rem)\n\n\n\nClean: round 4\n\nfb150Obj &lt;- clean(fb150Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb150Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Num drop B group\", 3)\n\nB group contains few cell with high diversity\n\nplot(pcaCellsData)\n\n\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\nfb150Obj &lt;- dropGenesCells(fb150Obj, cells = cells_to_rem)\n\n\n\nClean: round 5\n\nfb150Obj &lt;- clean(fb150Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb150Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb150Obj &lt;- addElementToMetaDataset(fb150Obj, \"Num drop B group\", 4)\n\nVisualize if all is ok:\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nlowUDEThr &lt;- 0.4 # the threshold to remove low UDE cells\n\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(fb150Obj)), \"n\" = seq_along(getNu(fb150Obj)))\nUDEPlot_zoomed &lt;- ggplot(nuDf, aes(x = n, y = nu)) +\n            geom_point(colour = \"#8491B4B2\", size = 1.0) +\n            xlim(0L, 400L) +\n            ylim(0.0, 1.0) +\n            geom_hline(yintercept = lowUDEThr, linetype = \"dashed\",\n                       color = \"darkred\") +\n            annotate(geom = \"text\", x = 200L, y = 0.25,\n                     label = paste0(\"to remove cells with nu &lt; \", lowUDEThr),\n                     color = \"darkred\", size = 4.5)\n\nplot(UDEPlot_zoomed)\n\n\n\n\nFinal cleaning to check all is OK\n\nfb150Obj &lt;- clean(fb150Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb150Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(cellSizePlot(fb150Obj, splitPattern = \":\", numCol = 1))\n\n\n\nplot(genesSizePlot(fb150Obj, splitPattern = \":\", numCol = 1))\n\n\n\n\nCalculate genes’ COEX\n\nSys.time()\n\nfb150Obj &lt;- proceedToCoex(fb150Obj, calcCoex = TRUE, cores = 12,\n                          saveObj = TRUE, outDir = outDir)\n\nSys.time()\n\nSave the COTAN object\n\nsaveRDS(fb150Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nfb150Obj &lt;- readRDS(file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))"
  },
  {
    "objectID": "ForebrainDorsal_E150-analysis.html#gdi",
    "href": "ForebrainDorsal_E150-analysis.html#gdi",
    "title": "Forebrain Dorsal E15.0 Data-set Anaysis",
    "section": "GDI",
    "text": "GDI\n\ngdiData &lt;- calculateGDI(fb150Obj)\n\ngenesToLabel &lt;- head(rownames(gdiData[order(gdiData[[\"GDI\"]],\n                                            decreasing = TRUE), ]), n = 10L)\n\ngenesToLabel\n\n [1] \"Myt1l\"   \"Aldoc\"   \"Rbfox1\"  \"Gas1\"    \"Zfp36l1\" \"Mapt\"    \"Ank3\"   \n [8] \"Stmn3\"   \"Tubb3\"   \"Pclaf\"  \n\ngdiPlot &lt;- GDIPlot(fb150Obj, GDIIn = gdiData, GDIThreshold = 1.4,\n                   genes = list(\"Top 10 GDI genes\" = genesToLabel))\n\nplot(gdiPlot)\n\n\n\n\n\nsplitClusters &lt;- cellsUniformClustering(fb150Obj, GDIThreshold = 1.4, cores = 13,\n                                        saveObj = TRUE, outDir = outDir)\n\nc(splitCoexDF, splitPValueDF) %&lt;-% DEAOnClusters(fb150Obj, clusters = splitClusters)\n\nfb150Obj &lt;- addClusterization(fb150Obj, clName = \"split\",\n                              clusters = splitClusters,\n                              coexDF = splitCoexDF, override = TRUE)\n\ntable(splitClusters)"
  },
  {
    "objectID": "ForebrainDorsal_E150-analysis.html#consistent-transcript-cohorts-clustering",
    "href": "ForebrainDorsal_E150-analysis.html#consistent-transcript-cohorts-clustering",
    "title": "Forebrain Dorsal E15.0 Data-set Anaysis",
    "section": "Consistent Transcript Cohorts (clustering)",
    "text": "Consistent Transcript Cohorts (clustering)\n\nc(mergedClusters, mergedCoexDF, mergedPValueDF) %&lt;-%\n  mergeUniformCellsClusters(fb150Obj, clusters = splitClusters,\n                            GDIThreshold = 1.4, cores = 13,\n                            saveObj = TRUE, outDir = outDir)\n\nfb150Obj &lt;- addClusterization(fb150Obj, clName = \"merge\",\n                              clusters = mergedClusters,\n                              coexDF = mergedCoexDF,\n                              override = TRUE)\n\ntable(mergedClusters)\n\n\n\nSys.time()\n\n[1] \"2023-11-17 12:57:25 CET\"\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.3.0   zeallot_0.1.0 tibble_3.2.1  ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3        rstudioapi_0.15.0        \n  [3] jsonlite_1.8.7            shape_1.4.6              \n  [5] umap_0.2.10.0             magrittr_2.0.3           \n  [7] spatstat.utils_3.0-3      farver_2.1.1             \n  [9] rmarkdown_2.24            GlobalOptions_0.1.2      \n [11] vctrs_0.6.3               ROCR_1.0-11              \n [13] spatstat.explore_3.2-1    DelayedMatrixStats_1.22.5\n [15] askpass_1.2.0             htmltools_0.5.5          \n [17] S4Arrays_1.2.0            sctransform_0.4.1        \n [19] parallelly_1.36.0         KernSmooth_2.23-22       \n [21] htmlwidgets_1.6.2         ica_1.0-3                \n [23] plyr_1.8.8                plotly_4.10.2            \n [25] zoo_1.8-12                igraph_1.5.1             \n [27] mime_0.12                 lifecycle_1.0.3          \n [29] iterators_1.0.14          pkgconfig_2.0.3          \n [31] rsvd_1.0.5                Matrix_1.6-2             \n [33] R6_2.5.1                  fastmap_1.1.1            \n [35] MatrixGenerics_1.12.3     fitdistrplus_1.1-11      \n [37] future_1.33.0             shiny_1.7.5              \n [39] clue_0.3-64               digest_0.6.33            \n [41] colorspace_2.1-0          patchwork_1.1.2          \n [43] S4Vectors_0.38.1          tensor_1.5               \n [45] Seurat_5.0.0              dqrng_0.3.0              \n [47] RSpectra_0.16-1           irlba_2.3.5.1            \n [49] beachmat_2.16.0           labeling_0.4.2           \n [51] PCAtools_2.14.0           progressr_0.14.0         \n [53] RcppZiggurat_0.1.6        spatstat.sparse_3.0-2    \n [55] fansi_1.0.4               polyclip_1.10-4          \n [57] httr_1.4.6                abind_1.4-5              \n [59] compiler_4.3.2            withr_2.5.0              \n [61] doParallel_1.0.17         BiocParallel_1.34.2      \n [63] viridis_0.6.4             fastDummies_1.7.3        \n [65] dendextend_1.17.1         MASS_7.3-60              \n [67] openssl_2.1.0             DelayedArray_0.26.7      \n [69] rjson_0.2.21              tools_4.3.2              \n [71] lmtest_0.9-40             httpuv_1.6.11            \n [73] future.apply_1.11.0       goftest_1.2-3            \n [75] glue_1.6.2                nlme_3.1-163             \n [77] promises_1.2.0.1          grid_4.3.2               \n [79] Rtsne_0.16                cluster_2.1.4            \n [81] reshape2_1.4.4            generics_0.1.3           \n [83] spatstat.data_3.0-1       gtable_0.3.3             \n [85] tidyr_1.3.0               data.table_1.14.8        \n [87] BiocSingular_1.16.0       ScaledMatrix_1.8.1       \n [89] sp_2.1-1                  utf8_1.2.3               \n [91] spatstat.geom_3.2-4       BiocGenerics_0.46.0      \n [93] RcppAnnoy_0.0.21          ggrepel_0.9.3            \n [95] RANN_2.6.1                foreach_1.5.2            \n [97] pillar_1.9.0              stringr_1.5.0            \n [99] spam_2.10-0               RcppHNSW_0.5.0           \n[101] later_1.3.1               circlize_0.4.15          \n[103] splines_4.3.2             dplyr_1.1.2              \n[105] lattice_0.22-5            deldir_1.0-9             \n[107] survival_3.5-7            tidyselect_1.2.0         \n[109] ComplexHeatmap_2.16.0     miniUI_0.1.1.1           \n[111] pbapply_1.7-2             knitr_1.43               \n[113] gridExtra_2.3             IRanges_2.34.1           \n[115] scattermore_1.2           stats4_4.3.2             \n[117] xfun_0.39                 matrixStats_1.1.0        \n[119] stringi_1.8.1             lazyeval_0.2.2           \n[121] yaml_2.3.7                evaluate_0.21            \n[123] codetools_0.2-19          cli_3.6.1                \n[125] uwot_0.1.16               RcppParallel_5.1.7       \n[127] xtable_1.8-4              reticulate_1.34.0        \n[129] munsell_0.5.0             Rcpp_1.0.11              \n[131] spatstat.random_3.2-1     globals_0.16.2           \n[133] png_0.1-8                 parallel_4.3.2           \n[135] Rfast_2.1.0               ellipsis_0.3.2           \n[137] assertthat_0.2.1          dotCall64_1.1-0          \n[139] parallelDist_0.2.6        sparseMatrixStats_1.12.2 \n[141] listenv_0.9.0             ggthemes_4.2.4           \n[143] viridisLite_0.4.2         scales_1.2.1             \n[145] ggridges_0.5.4            SeuratObject_5.0.0       \n[147] leiden_0.4.3              purrr_1.0.1              \n[149] crayon_1.5.2              GetoptLong_1.0.5         \n[151] rlang_1.1.1               cowplot_1.1.1"
  },
  {
    "objectID": "FindUniformOrigCluster.html",
    "href": "FindUniformOrigCluster.html",
    "title": "Find uniform given cluster in Forebrain Dorsal E15.0",
    "section": "",
    "text": "library(ggplot2)\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"./e15.0_FD_CheckClustersUniformity\"\n\nsetLoggingLevel(1)\nsetLoggingFile(file.path(outDir, \"FindUniformGivenClustersInForebrainDorsal_E150.log\"))\n\nRelevant genes lists\n\ngenesList &lt;- list(\n  \"NPGs\"   = c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"   = c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"     = c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n               \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n               \"Tars\", \"Amacr\"),\n  \"layers\" = c(\"Reln\", \"Lhx5\", \"Cux1\", \"Satb2\", \"Tle1\", \"Mef2c\", \"Rorb\",\n               \"Sox5\", \"Bcl11b\", \"Fezf2\", \"Foxp2\")\n)\n\nThis is a version of the function checkClusterUniformity() adapted to be used in this markdown document\n\nclusterIsUniform &lt;- function(objCOTAN, cluster, cells, GDIThreshold = 1.4) {\n\n  cores &lt;- 14L\n  \n  cellsToDrop &lt;- getCells(objCOTAN)[!getCells(objCOTAN) %in% cells]\n\n  objCOTAN &lt;- dropGenesCells(objCOTAN, cells = cellsToDrop)\n\n  objCOTAN &lt;- proceedToCoex(objCOTAN, cores = cores, saveObj = FALSE)\n  gc()\n\n  GDIData &lt;- calculateGDI(objCOTAN)\n\n  gdi &lt;- GDIData[[\"GDI\"]]\n  names(gdi) &lt;- rownames(GDIData)\n  gdi &lt;- sort(gdi, decreasing = TRUE)\n  \n  # Plot GDI\n  genesToRemark = list(\"Top 10 GDI genes\" = names(gdi)[1L:5L])\n  genesToRemark &lt;- append(genesToRemark, genesList)\n  plot &lt;- GDIPlot(objCOTAN, GDIIn = GDIData,\n                  GDIThreshold = GDIThreshold,\n                  genes = genesToRemark,\n                  condition = paste0(\"e15.0 cluster \", cluster))\n\n  rm(objCOTAN)\n  rm(GDIData)\n  gc()\n\n  # A cluster is deemed uniform if the number of genes\n  # with [GDI &gt; GDIThreshold] is not more than 1%\n  \n  highGDIRatio &lt;- sum(gdi &gt;= GDIThreshold) / length(gdi)\n  \n  lastPercentile &lt;- quantile(gdi, probs = 0.99)\n  \n  isUniform &lt;- highGDIRatio &lt;= 0.01\n\n  plot(plot)\n  \n  print(paste0(\"The cluster '\", cluster, \"' is \",\n               (if(isUniform) {\"\"} else {\"not \"}), \"uniform\"))\n  print(paste0(\"The percentage of genes with GDI above \", GDIThreshold, \" is: \",\n               round(highGDIRatio * 100.0, digits = 2), \"%\"))\n  print(paste0(\"The last percentile (99%) of the GDI values is: \",\n               round(lastPercentile, digits = 4)))\n  \n  return(list(\"isUniform\" = isUniform, \"highGDIRatio\" = highGDIRatio,\n              \"lastPercentile\" = lastPercentile, \"GDIPlot\" = plot))\n}\n\n\nfb150ObjRaw &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/SourceData/\", \"e15.0_ForebrainDorsal.cotan.RDS\"))\n\nfb150Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e15.0_ForebrainDorsal.cotan.RDS\"))\n\nAlign to cleaned cells’ list\n\nmetaC &lt;- getMetadataCells(fb150ObjRaw)[getCells(fb150Obj), ]\n\nmetaCDrop &lt;- getMetadataCells(fb150ObjRaw)[!getCells(fb150ObjRaw) %in% getCells(fb150Obj), ]\n\nExtract the cells of class ‘Neuron’\n\nmetaNeuron &lt;- metaC[metaC[[\"Class\"]] == \"Neuron\", ]\n\nsort(table(metaNeuron[[\"Subclass\"]]), decreasing = TRUE)\n\n\nCortical or hippocampal glutamatergic                   Forebrain GABAergic \n                                 3969                                   610 \n                        Cajal-Retzius                Mixed region GABAergic \n                                  145                                    21 \n                            Undefined               Forebrain glutamatergic \n                                   16                                    15 \n                         Hypothalamus            Mixed region glutamatergic \n                                    8                                     5 \n    Mixed region and neurotransmitter               Hindbrain glutamatergic \n                                    4                                     2 \n                Hindbrain glycinergic            Hypothalamus glutamatergic \n                                    2                                     2 \n        Dorsal midbrain glutamatergic                          Mixed region \n                                    1                                     1 \n\nsort(table(metaNeuron[[\"ClusterName\"]]), decreasing = TRUE)\n\n\nNeur525 Neur511 Neur509 Neur510 Neur508 Neur507 Neur568 Neur504 Neur505 Neur516 \n    826     540     402     402     397     183     181     174     147     137 \nNeur565 Neur524 Neur679 Neur493 Neur498 Neur497 Neur506 Neur502 Neur494 Neur574 \n    133     108     105      93      79      51      46      42      41      41 \nNeur575 Neur492 Neur519 Neur526 Neur566 Neur501 Neur573 Neur499 Neur518 Neur560 \n     41      38      31      28      28      24      24      23      22      20 \nNeur514 Neur523 Neur569 Neur557 Neur495 Neur520 Neur535 Neur542 Neur677 Neur527 \n     19      19      18      16      15      15      14      14      14      13 \nNeur496 Neur512 Neur676 Neur517 Neur558 Neur503 Neur739 Neur559 Neur564 Neur538 \n     11      11      11      10       9       8       8       7       7       6 \nNeur549 Neur561 Neur671 Neur695 Neur738 Neur747 Neur500 Neur536 Neur678 Neur534 \n      6       6       6       6       6       6       5       5       5       4 \nNeur550 Neur570 Neur686 Neur731 Neur737 Neur513 Neur515 Neur528 Neur533 Neur539 \n      4       4       4       4       4       3       3       3       3       3 \nNeur544 Neur571 Neur674 Neur675 Neur732 Neur531 Neur543 Neur548 Neur552 Neur554 \n      3       3       3       3       3       2       2       2       2       2 \nNeur562 Neur670 Neur689 Neur740 Neur529 Neur530 Neur532 Neur537 Neur540 Neur553 \n      2       2       2       2       1       1       1       1       1       1 \nNeur567 Neur572 Neur601 Neur614 Neur634 Neur647 Neur649 Neur672 Neur680 Neur681 \n      1       1       1       1       1       1       1       1       1       1 \nNeur684 Neur693 Neur696 Neur726 Neur734 Neur749 Neur750 Neur751 Neur760 Neur771 \n      1       1       1       1       1       1       1       1       1       1 \n\n\nCheck uniformity of sub-class: Cajal-Retzius\n\nFB_CaRe_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"Subclass\"]] == \"Cajal-Retzius\"]\n\ntable(metaNeuron[FB_CaRe_Cells, \"ClusterName\"])\n\n\nNeur674 Neur675 Neur676 Neur677 Neur678 Neur679 Neur686 \n      3       3      11      14       5     105       4 \n\nc(FB_CaRe_IsUniform, FB_CaRe_HighGDIRatio,\n  FB_CaRe_LastPercentile, FB_CaRe_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Cajal-Retzius\",\n                   cells = FB_CaRe_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Cajal-Retzius' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0.82%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3896\"\n\n\nCheck uniformity of sub-class: Forebrain GABAergic\n\nFB_GABA_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"Subclass\"]] == \"Forebrain GABAergic\"]\n\ntable(metaNeuron[FB_GABA_Cells, \"ClusterName\"])\n\n\nNeur529 Neur530 Neur531 Neur532 Neur533 Neur534 Neur535 Neur536 Neur537 Neur538 \n      1       1       2       1       3       4      14       5       1       6 \nNeur539 Neur540 Neur542 Neur543 Neur544 Neur548 Neur549 Neur550 Neur552 Neur553 \n      3       1      14       2       3       2       6       4       2       1 \nNeur554 Neur558 Neur559 Neur560 Neur561 Neur562 Neur564 Neur565 Neur566 Neur567 \n      2       9       7      20       6       2       7     133      28       1 \nNeur568 Neur569 Neur570 Neur571 Neur572 Neur573 Neur574 Neur575 Neur747 \n    181      18       4       3       1      24      41      41       6 \n\nc(FB_GABA_isUniform, FB_GABA_HighGDIRatio,\n  FB_GABA_LastPercentile, FB_GABA_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Forebrain_GABAergic\",\n                   cells = FB_GABA_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Forebrain_GABAergic' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 12.68%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.6987\"\n\n\nCheck uniformity of sub-class: Cortical or hippocampal glutamatergic\n\nFB_CHGl_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"Subclass\"]] == \"Cortical or hippocampal glutamatergic\"]\n\ntable(metaNeuron[FB_CHGl_Cells, \"ClusterName\"])\n\n\nNeur492 Neur493 Neur494 Neur495 Neur496 Neur497 Neur498 Neur499 Neur500 Neur501 \n     38      93      41      15      11      51      79      23       5      24 \nNeur502 Neur503 Neur504 Neur505 Neur506 Neur507 Neur508 Neur509 Neur510 Neur511 \n     42       8     174     147      46     183     397     402     402     540 \nNeur512 Neur513 Neur514 Neur515 Neur516 Neur517 Neur518 Neur519 Neur520 Neur523 \n     11       3      19       3     137      10      22      31      15      19 \nNeur524 Neur525 Neur526 Neur527 Neur528 \n    108     826      28      13       3 \n\nc(FB_CHGl_IsUniform, FB_CHGl_HighGDIRatio,\n  FB_CHGl_LastPercentile, FB_CHGl_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Cortical or hippocampal glutamatergic\",\n                   cells = FB_CHGl_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Cortical or hippocampal glutamatergic' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 61.17%\"\n[1] \"The last percentile (99%) of the GDI values is: 3.0064\"\n\n\nCheck uniformity of Cajal-Retzius cluster: Neur679\n\nFB_Neur679_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur679\"]\n\nc(FB_Neur679_IsUniform, FB_Neur679_HighGDIRatio,\n  FB_Neur679_LastPercentile, FB_Neur679_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur679\",\n                   cells = FB_Neur679_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur679' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0.24%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3392\"\n\n\nCheck uniformity of Forebrain GABAergic cluster: Neur568\n\nFB_Neur568_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"]\n\nc(FB_Neur568_IsUniform, FB_Neur568_HighGDIRatio,\n  FB_Neur568_LastPercentile, FB_Neur568_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur568\",\n                   cells = FB_Neur568_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur568' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3058\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur525\n\nFB_Neur525_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur525\"]\n\nc(FB_Neur525_IsUniform, FB_Neur525_HighGDIRatio,\n  FB_Neur525_LastPercentile, FB_Neur525_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur525\",\n                   cells = FB_Neur525_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur525' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 30.16%\"\n[1] \"The last percentile (99%) of the GDI values is: 2.3522\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508\n\nFB_Neur508_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"]\n\nc(FB_Neur508_IsUniform, FB_Neur508_HighGDIRatio,\n  FB_Neur508_LastPercentile, FB_Neur508_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508\",\n                   cells = FB_Neur508_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0.46%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3701\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur509\n\nFB_Neur509_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur509\"]\n\nc(FB_Neur509_IsUniform, FB_Neur509_HighGDIRatio,\n  FB_Neur509_LastPercentile, FB_Neur509_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur509\",\n                   cells = FB_Neur509_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur509' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0.67%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3811\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur507\n\nFB_Neur507_Cells &lt;-\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur507\"]\n\nc(FB_Neur507_IsUniform, FB_Neur507_HighGDIRatio,\n  FB_Neur507_LastPercentile, FB_Neur507_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur507\",\n                   cells = FB_Neur507_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur507' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0.94%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3939\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and Neur509\n\nFB_Neur508.Neur509_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur509\"]\n)\n\nc(FB_Neur508.Neur509_IsUniform, FB_Neur508.Neur509_HighGDIRatio,\n  FB_Neur508.Neur509_LastPercentile, FB_Neur508.Neur509_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.Neur509\",\n                   cells = FB_Neur508.Neur509_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.Neur509' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 2.63%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.4529\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and Neur507\n\nFB_Neur508.Neur507_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur507\"]\n)\n\nc(FB_Neur508.Neur507_IsUniform, FB_Neur508.Neur507_HighGDIRatio,\n  FB_Neur508.Neur507_LastPercentile, FB_Neur508.Neur507_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.Neur507\",\n                   cells = FB_Neur508.Neur507_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.Neur507' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 3.76%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.5202\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and Cajal-Retzius cluster: Neur679\n\nFB_Neur508.Neur679_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur679\"]\n)\n\nc(FB_Neur508.Neur679_IsUniform, FB_Neur508.Neur679_HighGDIRatio,\n  FB_Neur508.Neur679_LastPercentile, FB_Neur508.Neur679_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.Neur679\",\n                   cells = FB_Neur508.Neur679_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.Neur679' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 15.95%\"\n[1] \"The last percentile (99%) of the GDI values is: 2.1736\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and Forebrain GABAergic cluster: Neur568\n\nFB_Neur508.Neur568_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"]\n)\n\nc(FB_Neur508.Neur568_IsUniform, FB_Neur508.Neur568_HighGDIRatio,\n  FB_Neur508.Neur568_LastPercentile, FB_Neur508.Neur568_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.Neur568\",\n                   cells = FB_Neur508.Neur568_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.Neur568' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 21.27%\"\n[1] \"The last percentile (99%) of the GDI values is: 2.1539\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur509 and Cajal-Retzius cluster: Neur679\n\nFB_Neur509.Neur679_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur509\"],\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur679\"]\n)\n\nc(FB_Neur509.Neur679_IsUniform, FB_Neur509.Neur679_HighGDIRatio,\n  FB_Neur509.Neur679_LastPercentile, FB_Neur509.Neur679_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur509.Neur679\",\n                   cells = FB_Neur509.Neur679_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur509.Neur679' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 14.34%\"\n[1] \"The last percentile (99%) of the GDI values is: 2.1308\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur507 and Cajal-Retzius cluster: Neur679\n\nFB_Neur507.Neur679_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur507\"],\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur679\"]\n)\n\nc(FB_Neur507.Neur679_IsUniform, FB_Neur507.Neur679_HighGDIRatio,\n  FB_Neur507.Neur679_LastPercentile, FB_Neur507.Neur679_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur507.Neur679\",\n                   cells = FB_Neur507.Neur679_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur507.Neur679' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 8.6%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.8754\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and 40 cells taken from Cajal-Retzius cluster: Neur679\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur508 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur508\")))\n\n[1] \"Cluser Neur508 size: 397\"\n\nFB_Neur508.s40oNeur679_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur679\"], 40)\n)\n\nc(FB_Neur508.s40oNeur679_IsUniform, FB_Neur508.s40oNeur679_HighGDIRatio,\n  FB_Neur508.s40oNeur679_LastPercentile, FB_Neur508.s40oNeur679_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.s40oNeur679\",\n                   cells = FB_Neur508.s40oNeur679_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.s40oNeur679' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 6.95%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.8052\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and 20 cells taken from Cajal-Retzius cluster: Neur679\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur508 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur508\")))\n\n[1] \"Cluser Neur508 size: 397\"\n\nFB_Neur508.s20oNeur679_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur679\"], 20)\n)\n\nc(FB_Neur508.s20oNeur679_IsUniform, FB_Neur508.s20oNeur679_HighGDIRatio,\n  FB_Neur508.s20oNeur679_LastPercentile, FB_Neur508.s20oNeur679_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.s20oNeur679\",\n                   cells = FB_Neur508.s20oNeur679_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.s20oNeur679' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 4.3%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.61\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and 10 cells taken from Cajal-Retzius cluster: Neur679\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur508 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur508\")))\n\n[1] \"Cluser Neur508 size: 397\"\n\nFB_Neur508.s10oNeur679_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur679\"], 10)\n)\n\nc(FB_Neur508.s10oNeur679_IsUniform, FB_Neur508.s10oNeur679_HighGDIRatio,\n  FB_Neur508.s10oNeur679_LastPercentile, FB_Neur508.s10oNeur679_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.s10oNeur679\",\n                   cells = FB_Neur508.s10oNeur679_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.s10oNeur679' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 1.92%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.4542\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and 40 cells taken from all Neuron - non Cortical or hippocampal glutamatergic cells\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur508 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur508\")))\n\n[1] \"Cluser Neur508 size: 397\"\n\nFB_Neur508.s40oNonCHGl_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"Subclass\"]] != \"Cortical or hippocampal glutamatergic\"], 40)\n)\n\nc(FB_Neur508.s40oNonCHGl_IsUniform, FB_Neur508.s40oNonCHGl_HighGDIRatio,\n  FB_Neur508.s40oNonCHGl_LastPercentile, FB_Neur508.s40oNonCHGl_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.s40oNonCHGl\",\n                   cells = FB_Neur508.s40oNonCHGl_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.s40oNonCHGl' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 3.05%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.514\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and 20 cells taken from all Neuron - non Cortical or hippocampal glutamatergic cells\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur508 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur508\")))\n\n[1] \"Cluser Neur508 size: 397\"\n\nFB_Neur508.s20oNonCHGl_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"Subclass\"]] != \"Cortical or hippocampal glutamatergic\"], 20)\n)\n\nc(FB_Neur508.s20oNonCHGl_IsUniform, FB_Neur508.s20oNonCHGl_HighGDIRatio,\n  FB_Neur508.s20oNonCHGl_LastPercentile, FB_Neur508.s20oNonCHGl_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.s20oNonCHGl\",\n                   cells = FB_Neur508.s20oNonCHGl_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.s20oNonCHGl' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 1.15%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.4091\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur508 and 10 cells taken from all Neuron - non Cortical or hippocampal glutamatergic cells\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur508 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur508\")))\n\n[1] \"Cluser Neur508 size: 397\"\n\nFB_Neur508.s10oNonCHGl_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur508\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"Subclass\"]] != \"Cortical or hippocampal glutamatergic\"], 10)\n)\n\nc(FB_Neur508.s10oNonCHGl_IsUniform, FB_Neur508.s10oNonCHGl_HighGDIRatio,\n  FB_Neur508.s10oNonCHGl_LastPercentile, FB_Neur508.s10oNonCHGl_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur508.s10oNonCHGl\",\n                   cells = FB_Neur508.s10oNonCHGl_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur508.s10oNonCHGl' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0.67%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3853\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur509 and 40 cells taken from Forebrain GABAergic cluster: Neur568\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur509 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur509\")))\n\n[1] \"Cluser Neur509 size: 402\"\n\nFB_Neur509.s40oNeur568_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur509\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"], 40)\n)\n\nc(FB_Neur509.s40oNeur568_IsUniform, FB_Neur509.s40oNeur568_HighGDIRatio,\n  FB_Neur509.s40oNeur568_LastPercentile, FB_Neur509.s40oNeur568_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur509.s40oNeur568\",\n                   cells = FB_Neur509.s40oNeur568_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur509.s40oNeur568' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 4.59%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.5904\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur509 and 20 cells taken from Forebrain GABAergic cluster: Neur568\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur509 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur509\")))\n\n[1] \"Cluser Neur509 size: 402\"\n\nFB_Neur509.s20oNeur568_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur509\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"], 20)\n)\n\nc(FB_Neur509.s20oNeur568_IsUniform, FB_Neur509.s20oNeur568_HighGDIRatio,\n  FB_Neur509.s20oNeur568_LastPercentile, FB_Neur509.s20oNeur568_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur509.s20oNeur568\",\n                   cells = FB_Neur509.s20oNeur568_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur509.s20oNeur568' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 2.43%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.4661\"\n\n\nCheck uniformity of Cortical or hippocampal glutamatergic cluster: Neur509 and 10 cells taken from Forebrain GABAergic cluster: Neur568\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur509 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur509\")))\n\n[1] \"Cluser Neur509 size: 402\"\n\nFB_Neur509.s10oNeur568_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur509\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"], 10)\n)\n\nc(FB_Neur509.s10oNeur568_IsUniform, FB_Neur509.s10oNeur568_HighGDIRatio,\n  FB_Neur509.s10oNeur568_LastPercentile, FB_Neur509.s10oNeur568_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur509.s10oNeur568\",\n                   cells = FB_Neur509.s10oNeur568_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur509.s10oNeur568' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 1.14%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.4103\"\n\n\nCheck uniformity of Forebrain GABAergic cluster: Neur568 and 20 cells taken from Cortical or hippocampal glutamatergic cluster: Neur507\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur568 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur568\")))\n\n[1] \"Cluser Neur568 size: 181\"\n\nFB_Neur568.s20oNeur507_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur507\"], 20)\n)\n\nc(FB_Neur568.s20oNeur507_IsUniform, FB_Neur568.s20oNeur507_HighGDIRatio,\n  FB_Neur568.s20oNeur507_LastPercentile, FB_Neur568.s20oNeur507_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur568.s20oNeur507\",\n                   cells = FB_Neur568.s20oNeur507_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur568.s20oNeur507' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 7.46%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.7445\"\n\n\nCheck uniformity of Forebrain GABAergic cluster: Neur568 and 10 cells taken from Cortical or hippocampal glutamatergic cluster: Neur507\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur568 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur568\")))\n\n[1] \"Cluser Neur568 size: 181\"\n\nFB_Neur568.s10oNeur507_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur507\"], 10)\n)\n\nc(FB_Neur568.s10oNeur507_IsUniform, FB_Neur568.s10oNeur507_HighGDIRatio,\n  FB_Neur568.s10oNeur507_LastPercentile, FB_Neur568.s10oNeur507_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur568.s10oNeur507\",\n                   cells = FB_Neur568.s10oNeur507_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur568.s10oNeur507' is not uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 1.9%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.4669\"\n\n\nCheck uniformity of Forebrain GABAergic cluster: Neur568 and 5 cells taken from Cortical or hippocampal glutamatergic cluster: Neur507\n\nset.seed(639245)\n\nprint(paste0(\"Cluser Neur568 size: \", sum(metaNeuron[[\"ClusterName\"]] == \"Neur568\")))\n\n[1] \"Cluser Neur568 size: 181\"\n\nFB_Neur568.s5oNeur507_Cells &lt;- c(\n  rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur568\"],\n  sample(rownames(metaNeuron)[metaNeuron[[\"ClusterName\"]] == \"Neur507\"], 5)\n)\n\nc(FB_Neur568.s5oNeur507_IsUniform, FB_Neur568.s5oNeur507_HighGDIRatio,\n  FB_Neur568.s5oNeur507_LastPercentile, FB_Neur568.s5oNeur507_GDIPlot) %&lt;-%\n  clusterIsUniform(fb150Obj, cluster = \"Neur568.s5oNeur507\",\n                   cells = FB_Neur568.s5oNeur507_Cells, GDIThreshold = 1.4)\n\n\n\n\n[1] \"The cluster 'Neur568.s5oNeur507' is uniform\"\n[1] \"The percentage of genes with GDI above 1.4 is: 0.48%\"\n[1] \"The last percentile (99%) of the GDI values is: 1.3517\"\n\n\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Berlin\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.1.5   zeallot_0.1.0 tibble_3.2.1  ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.14        jsonlite_1.8.4        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.21        \n [10] GlobalOptions_0.1.2    vctrs_0.6.1            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-20    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.1          zoo_1.8-12             igraph_1.4.2          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.5-4.1         R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-8     future_1.32.0         \n [34] shiny_1.7.4            clue_0.3-64            digest_0.6.31         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.0      \n [40] Seurat_4.3.0           tensor_1.5             RSpectra_0.16-1       \n [43] irlba_2.3.5.1          labeling_0.4.2         progressr_0.13.0      \n [46] RcppZiggurat_0.1.6     fansi_1.0.4            spatstat.sparse_3.0-1 \n [49] httr_1.4.5             polyclip_1.10-4        abind_1.4-5           \n [52] compiler_4.3.0         withr_2.5.0            doParallel_1.0.17     \n [55] viridis_0.6.2          dendextend_1.17.1      MASS_7.3-59           \n [58] openssl_2.0.6          rjson_0.2.21           tools_4.3.0           \n [61] lmtest_0.9-40          httpuv_1.6.9           future.apply_1.11.0   \n [64] goftest_1.2-3          glue_1.6.2             nlme_3.1-162          \n [67] promises_1.2.0.1       grid_4.3.0             Rtsne_0.16            \n [70] cluster_2.1.4          reshape2_1.4.4         generics_0.1.3        \n [73] gtable_0.3.3           spatstat.data_3.0-1    tidyr_1.3.0           \n [76] data.table_1.14.8      sp_1.6-0               utf8_1.2.3            \n [79] BiocGenerics_0.46.0    spatstat.geom_3.2-1    RcppAnnoy_0.0.20      \n [82] ggrepel_0.9.3          RANN_2.6.1             foreach_1.5.2         \n [85] pillar_1.9.0           stringr_1.5.0          later_1.3.0           \n [88] circlize_0.4.15        splines_4.3.0          dplyr_1.1.2           \n [91] lattice_0.21-8         survival_3.5-5         deldir_1.0-6          \n [94] tidyselect_1.2.0       ComplexHeatmap_2.16.0  miniUI_0.1.1.1        \n [97] pbapply_1.7-0          knitr_1.42             gridExtra_2.3         \n[100] IRanges_2.34.0         scattermore_1.2        stats4_4.3.0          \n[103] xfun_0.39              factoextra_1.0.7       matrixStats_1.0.0     \n[106] stringi_1.7.12         lazyeval_0.2.2         yaml_2.3.7            \n[109] evaluate_0.20          codetools_0.2-19       cli_3.6.1             \n[112] RcppParallel_5.1.7     uwot_0.1.14            xtable_1.8-4          \n[115] reticulate_1.30        munsell_0.5.0          Rcpp_1.0.10           \n[118] globals_0.16.2         spatstat.random_3.1-4  png_0.1-8             \n[121] parallel_4.3.0         Rfast_2.0.7            ellipsis_0.3.2        \n[124] assertthat_0.2.1       parallelDist_0.2.6     listenv_0.9.0         \n[127] ggthemes_4.2.4         viridisLite_0.4.1      scales_1.2.1          \n[130] ggridges_0.5.4         SeuratObject_4.1.3     leiden_0.4.3          \n[133] purrr_1.0.1            crayon_1.5.2           GetoptLong_1.0.5      \n[136] rlang_1.1.0            cowplot_1.1.1"
  },
  {
    "objectID": "FDR_analisysResults5_20.html",
    "href": "FDR_analisysResults5_20.html",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\""
  },
  {
    "objectID": "FDR_analisysResults5_20.html#preamble",
    "href": "FDR_analisysResults5_20.html#preamble",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\""
  },
  {
    "objectID": "FDR_analisysResults5_20.html#dataset-composition",
    "href": "FDR_analisysResults5_20.html#dataset-composition",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "Dataset composition",
    "text": "Dataset composition\n\ndatasets_csv &lt;- read.csv(file.path(dataSetDir,\"Cells_Usage_DataFrame.csv\"),\n                         row.names = 1\n                        ) \n\ndatasets_csv[1:3,]\n\n                 Group            Collection E13.5.432 E13.5.187 E13.5.434\n1 2_Clusters_even_near E13.5-434_+_E15.0-428         0         0       318\n2 2_Clusters_even_near E15.0-432_+_E13.5-432       536         0         0\n3 2_Clusters_even_near E15.0-508_+_E15.0-509         0         0         0\n  E13.5.184 E13.5.437 E13.5.510 E15.0.432 E15.0.509 E15.0.510 E15.0.508\n1         0         0         0         0         0         0         0\n2         0         0         0       536         0         0         0\n3         0         0         0         0       397         0       397\n  E15.0.428 E15.0.434 E15.0.437 E17.5.516 E17.5.505\n1       318         0         0         0         0\n2         0         0         0         0         0\n3         0         0         0         0         0\n\n\n\nDefine which genes are expressed\nFor each data set we need to define, independently from the DEA methods, which genes are specific for each cluster. So we need to define first which genes are expressed and which are not expressed. To do so we can take advantage from the fact that we have the original clusters from which the cells were sampled to create the artificial datasets. So looking to the original cluster we define as expressed all genes present in at least the 20% of cells and we define as not expressed the genes completely absent or expressed in less than 5% of cells.\nSince these two thresholds can have a big influence on the tools performances we will test also others in other pages.\n\nfile.presence &lt;- readRDS(\"Data/MouseCortexFromLoom/FDR/Results/GenePresence_PerCluster.RDS\")\n\nfor (file in list.files(\"Data/MouseCortexFromLoom/SingleClusterRawData/\")) {\n#  print(file)\n  Code &lt;- str_split(file,pattern = \"_\",simplify = T)[1]\n  Time &lt;- str_split(Code,pattern = \"e\",simplify = T)[2]\n  Cluster &lt;- str_split(Code,pattern = \"e\",simplify = T)[1]\n  Cluster &lt;- str_remove(Cluster,pattern = \"Cl\")\n  Cluster &lt;- paste0(\"E\",Time,\"-\",Cluster)\n  file.presence[,Cluster] &lt;- \"Absent\"\n  dataset.cl &lt;- readRDS(file.path(\"Data/MouseCortexFromLoom/SingleClusterRawData/\",\n                                         file))\n  number.cell.expressing &lt;- rowSums(dataset.cl &gt; 0)\n  AbsentThreshold &lt;- round(0.05*dim(dataset.cl)[2],digits = 0)\n  PresenceThreshold &lt;- round(0.2*dim(dataset.cl)[2],digits = 0)\n  file.presence[names(number.cell.expressing[number.cell.expressing &gt; AbsentThreshold]),Cluster] &lt;- \"Uncertain\" \n  \n  file.presence[names(number.cell.expressing[number.cell.expressing &gt;= PresenceThreshold]),Cluster] &lt;- \"Present\"\n  print(Cluster)\n  print(table(file.presence[,Cluster]))\n  \n  }\n\n[1] \"E13.5-184\"\n\n   Absent   Present Uncertain \n     6719      3476      4500 \n[1] \"E13.5-187\"\n\n   Absent   Present Uncertain \n     5930      4609      4156 \n[1] \"E15.0-428\"\n\n   Absent   Present Uncertain \n     7470      2864      4361 \n[1] \"E13.5-432\"\n\n   Absent   Present Uncertain \n     6847      3640      4208 \n[1] \"E15.0-432\"\n\n   Absent   Present Uncertain \n     6951      3514      4230 \n[1] \"E13.5-434\"\n\n   Absent   Present Uncertain \n     7191      3185      4319 \n[1] \"E15.0-434\"\n\n   Absent   Present Uncertain \n     7554      3028      4113 \n[1] \"E13.5-437\"\n\n   Absent   Present Uncertain \n     7024      3430      4241 \n[1] \"E15.0-437\"\n\n   Absent   Present Uncertain \n     7090      3419      4186 \n[1] \"E17.5-505\"\n\n   Absent   Present Uncertain \n     7141      3154      4400 \n[1] \"E15.0-508\"\n\n   Absent   Present Uncertain \n     6637      3892      4166 \n[1] \"E15.0-509\"\n\n   Absent   Present Uncertain \n     6495      4039      4161 \n[1] \"E13.5-510\"\n\n   Absent   Present Uncertain \n     5961      4541      4193 \n[1] \"E15.0-510\"\n\n   Absent   Present Uncertain \n     6082      4480      4133 \n[1] \"E17.5-516\"\n\n   Absent   Present Uncertain \n     6931      3496      4268"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_even_near",
    "href": "FDR_analisysResults5_20.html#clusters_even_near",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "2_Clusters_even_near",
    "text": "2_Clusters_even_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_near\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set             set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                     &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_even_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_even_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_even_near          1\n4 Lamc1 E15.0-428 FALSE 2_Clusters_even_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_even_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_even_near          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 8\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_even_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_even_nearPL &lt;- TwoClusters_even_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_even_nearPL"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_even_medium",
    "href": "FDR_analisysResults5_20.html#clusters_even_medium",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "2_Clusters_even_medium",
    "text": "2_Clusters_even_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_medium\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_even_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_even_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_even_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_even_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_even_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_even_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 447\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_even_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_even_mediumPL &lt;- Two_Clusters_even_medium + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_even_mediumPL"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_even_far",
    "href": "FDR_analisysResults5_20.html#clusters_even_far",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "2_Clusters_even_far",
    "text": "2_Clusters_even_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_far\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set            set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                    &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_even_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_even_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_even_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_even_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_even_far          1\n6 Lama1 E13.5-187 FALSE 2_Clusters_even_far          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 1359\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_even_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_even_farPL &lt;- Two_Clusters_even_far + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_even_farPL"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_uneven_near",
    "href": "FDR_analisysResults5_20.html#clusters_uneven_near",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "2_Clusters_uneven_near",
    "text": "2_Clusters_uneven_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_near\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_uneven_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_uneven_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n4 Lamc1 E15.0-428 FALSE 2_Clusters_uneven_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_uneven_near          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 8\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\nplot(roc_resultSeurat)\n\n\n\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_nearPL &lt;- Two_Clusters_uneven_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_uneven_nearPL"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_uneven_medium",
    "href": "FDR_analisysResults5_20.html#clusters_uneven_medium",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "2_Clusters_uneven_medium",
    "text": "2_Clusters_uneven_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_medium\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set                 set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                         &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 447\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_mediumPL &lt;- Two_Clusters_uneven_medium + xlab(\"FPR\") + ylab(\"TPR\")\n\nTwo_Clusters_uneven_mediumPL"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_uneven_far",
    "href": "FDR_analisysResults5_20.html#clusters_uneven_far",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "2_Clusters_uneven_far",
    "text": "2_Clusters_uneven_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_far\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set              set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                      &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_uneven_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_uneven_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n6 Lama1 E13.5-187 FALSE 2_Clusters_uneven_far          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 1359\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_farPL &lt;- Two_Clusters_uneven_far + xlab(\"FPR\") + ylab(\"TPR\")\n\nTwo_Clusters_uneven_farPL"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_even",
    "href": "FDR_analisysResults5_20.html#clusters_even",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "3_Clusters_even",
    "text": "3_Clusters_even\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_even\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set        set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                &lt;int&gt;\n1 Neil2 E15.0-437 FALSE 3_Clusters_even          1\n2 Neil2 E13.5-510 FALSE 3_Clusters_even          1\n3 Neil2 E13.5-437 FALSE 3_Clusters_even          1\n4 Lamc1 E15.0-437 FALSE 3_Clusters_even          1\n5 Lamc1 E13.5-510 FALSE 3_Clusters_even          1\n6 Lamc1 E13.5-437 FALSE 3_Clusters_even          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 1305\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E17.5-516\"\n[1] \"E13.5-437\"\n[1] \"E17.5-505\"\n[1] \"E15.0-510\"\n[1] \"E15.0-428\"\n[1] \"E13.5-510\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThree_Clusters_even &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThree_Clusters_evenPL &lt;- Three_Clusters_even + \n  xlab(\"FPR\") + ylab(\"TPR\")+theme(legend.position=\"none\")\nThree_Clusters_even"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_uneven",
    "href": "FDR_analisysResults5_20.html#clusters_uneven",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "3_Clusters_uneven",
    "text": "3_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_uneven\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E15.0-428 FALSE 3_Clusters_uneven          1\n2 Neil2 E13.5-434 FALSE 3_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 3_Clusters_uneven          1\n4 Lamc1 E15.0-428 FALSE 3_Clusters_uneven          1\n5 Lamc1 E13.5-434 FALSE 3_Clusters_uneven          1\n6 Lamc1 E15.0-510 FALSE 3_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 1577\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E15.0-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E13.5-187\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThree_Clusters_uneven &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThree_Clusters_unevenPL &lt;- Three_Clusters_uneven + xlab(\"FPR\") + ylab(\"TPR\")+theme(legend.position=\"none\")\n\nThree_Clusters_uneven"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters_uneven-1",
    "href": "FDR_analisysResults5_20.html#clusters_uneven-1",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "5_Clusters_uneven",
    "text": "5_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"5_Clusters_uneven\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E13.5-510 FALSE 5_Clusters_uneven          1\n2 Neil2 E15.0-437 FALSE 5_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 5_Clusters_uneven          1\n4 Neil2 E13.5-432 FALSE 5_Clusters_uneven          1\n5 Neil2 E13.5-437 FALSE 5_Clusters_uneven          1\n6 Lamc1 E13.5-510 FALSE 5_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 1862\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-432\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E13.5-184\"\n[1] \"E15.0-434\"\n[1] \"E17.5-505\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-187\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nFive_Clusters &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\n \nFive_Clusters_unevenPL &lt;- Five_Clusters + xlab(\"FPR\") + ylab(\"TPR\")\n\nFive_Clusters_unevenPL"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#clusters-2",
    "href": "FDR_analisysResults5_20.html#clusters-2",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "2 Clusters",
    "text": "2 Clusters\n\nggarrange(TwoClusters_even_nearPL,Two_Clusters_even_mediumPL, Two_Clusters_even_farPL,Two_Clusters_uneven_nearPL, Two_Clusters_uneven_mediumPL,Two_Clusters_uneven_farPL,\n          labels = c(\"Even_Near\", \"Even_Medium\", \"Even_Far\", \"Uneven_Near\",\"Uneven_Medium\",\"Uneven_Far\"),\n          ncol = 3, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#and-5-clusters",
    "href": "FDR_analisysResults5_20.html#and-5-clusters",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "3 and 5 Clusters",
    "text": "3 and 5 Clusters\n\nggarrange(Three_Clusters_evenPL,Three_Clusters_unevenPL, NULL, Five_Clusters_unevenPL,\n          labels = c(\"3_Even\", \"3_Uneven\", \"\", \"5_Uneven\"),\n          ncol = 2, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analisysResults5_20.html#footer",
    "href": "FDR_analisysResults5_20.html#footer",
    "title": "FDR analysis - Results - thresholds true 5% 20%",
    "section": "Footer",
    "text": "Footer\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ggpubr_0.6.0                ggplot2_3.4.2              \n [3] tidyr_1.3.0                 dplyr_1.1.2                \n [5] stringr_1.5.0               reticulate_1.35.0          \n [7] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [9] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n[11] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n[13] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n[15] matrixStats_1.2.0           Biobase_2.60.0             \n[17] BiocGenerics_0.46.0         Seurat_5.0.0               \n[19] SeuratObject_5.0.0          sp_2.1-1                   \n[21] pROC_1.18.4                 COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] rstatix_0.7.2             doParallel_1.0.17        \n [11] globals_0.16.2            lattice_0.22-5           \n [13] MASS_7.3-60               backports_1.4.1          \n [15] dendextend_1.17.1         magrittr_2.0.3           \n [17] plotly_4.10.2             rmarkdown_2.24           \n [19] yaml_2.3.7                httpuv_1.6.11            \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] minqa_1.2.5               cowplot_1.1.1            \n [27] pbapply_1.7-2             RColorBrewer_1.1-3       \n [29] zlibbioc_1.46.0           abind_1.4-5              \n [31] Rtsne_0.16                purrr_1.0.1              \n [33] RCurl_1.98-1.12           GenomeInfoDbData_1.2.10  \n [35] circlize_0.4.15           ggrepel_0.9.3            \n [37] irlba_2.3.5.1             listenv_0.9.0            \n [39] spatstat.utils_3.0-3      terra_1.7-39             \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       tidyselect_1.2.0         \n [53] shape_1.4.6               farver_2.1.1             \n [55] lme4_1.1-34               ScaledMatrix_1.8.1       \n [57] viridis_0.6.4             spatstat.explore_3.2-1   \n [59] jsonlite_1.8.7            GetoptLong_1.0.5         \n [61] ellipsis_0.3.2            progressr_0.14.0         \n [63] ggridges_0.5.4            survival_3.5-7           \n [65] iterators_1.0.14          foreach_1.5.2            \n [67] tools_4.3.2               ica_1.0-3                \n [69] Rcpp_1.0.11               glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] scattermore_1.2           tensor_1.5               \n [87] spatstat.data_3.0-1       utf8_1.2.3               \n [89] generics_0.1.3            data.table_1.15.0        \n [91] httr_1.4.6                htmlwidgets_1.6.2        \n [93] S4Arrays_1.2.0            uwot_0.1.16              \n [95] pkgconfig_2.0.3           gtable_0.3.3             \n [97] ComplexHeatmap_2.16.0     lmtest_0.9-40            \n [99] XVector_0.40.0            htmltools_0.5.7          \n[101] carData_3.0-5             dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] nlme_3.1-163              zoo_1.8-12               \n[113] GlobalOptions_0.1.2       KernSmooth_2.23-22       \n[115] parallel_4.3.2            miniUI_0.1.1.1           \n[117] RcppZiggurat_0.1.6        pillar_1.9.0             \n[119] grid_4.3.2                vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] car_3.1-2                 BiocSingular_1.16.0      \n[125] beachmat_2.16.0           xtable_1.8-4             \n[127] cluster_2.1.6             evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              ggsignif_0.6.4           \n[135] future.apply_1.11.0       labeling_0.4.2           \n[137] plyr_1.8.8                stringi_1.8.1            \n[139] viridisLite_0.4.2         deldir_2.0-2             \n[141] BiocParallel_1.34.2       assertthat_0.2.1         \n[143] munsell_0.5.0             lazyeval_0.2.2           \n[145] spatstat.geom_3.2-4       PCAtools_2.14.0          \n[147] Matrix_1.6-3              RcppHNSW_0.6.0           \n[149] patchwork_1.2.0           sparseMatrixStats_1.12.2 \n[151] future_1.33.0             shiny_1.8.0              \n[153] ROCR_1.0-11               Rfast_2.1.0              \n[155] broom_1.0.5               igraph_1.6.0             \n[157] RcppParallel_5.1.7"
  },
  {
    "objectID": "FDR_analisysResults3_10.html",
    "href": "FDR_analisysResults3_10.html",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\""
  },
  {
    "objectID": "FDR_analisysResults3_10.html#preamble",
    "href": "FDR_analisysResults3_10.html#preamble",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\""
  },
  {
    "objectID": "FDR_analisysResults3_10.html#dataset-composition",
    "href": "FDR_analisysResults3_10.html#dataset-composition",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "Dataset composition",
    "text": "Dataset composition\n\ndatasets_csv &lt;- read.csv(file.path(dataSetDir,\"Cells_Usage_DataFrame.csv\"),\n                         row.names = 1\n                        ) \n\ndatasets_csv[1:3,]\n\n                 Group            Collection E13.5.432 E13.5.187 E13.5.434\n1 2_Clusters_even_near E13.5-434_+_E15.0-428         0         0       318\n2 2_Clusters_even_near E15.0-432_+_E13.5-432       536         0         0\n3 2_Clusters_even_near E15.0-508_+_E15.0-509         0         0         0\n  E13.5.184 E13.5.437 E13.5.510 E15.0.432 E15.0.509 E15.0.510 E15.0.508\n1         0         0         0         0         0         0         0\n2         0         0         0       536         0         0         0\n3         0         0         0         0       397         0       397\n  E15.0.428 E15.0.434 E15.0.437 E17.5.516 E17.5.505\n1       318         0         0         0         0\n2         0         0         0         0         0\n3         0         0         0         0         0\n\n\n\nDefine which genes are expressed\nFor each data set we need to define, independently from the DEA methods, which genes are specific for each cluster. So we need to define first which genes are expressed and which are not expressed. To do so we can take advantage from the fact that we have the original clusters from which the cells were sampled to create the artificial datasets. So looking to the original cluster we define as expressed all genes present in at least the 10% of cells and we define as not expressed the genes completely absent or expressed in less than 3% of cells.\nSince these two thresholds can have a big influence on the tools performances we will test also others in other pages.\n\nfile.presence &lt;- readRDS(\"Data/MouseCortexFromLoom/FDR/Results/GenePresence_PerCluster.RDS\")\n\nfor (file in list.files(\"Data/MouseCortexFromLoom/SingleClusterRawData/\")) {\n#  print(file)\n  Code &lt;- str_split(file,pattern = \"_\",simplify = T)[1]\n  Time &lt;- str_split(Code,pattern = \"e\",simplify = T)[2]\n  Cluster &lt;- str_split(Code,pattern = \"e\",simplify = T)[1]\n  Cluster &lt;- str_remove(Cluster,pattern = \"Cl\")\n  Cluster &lt;- paste0(\"E\",Time,\"-\",Cluster)\n  file.presence[,Cluster] &lt;- \"Absent\"\n  dataset.cl &lt;- readRDS(file.path(\"Data/MouseCortexFromLoom/SingleClusterRawData/\",\n                                         file))\n  number.cell.expressing &lt;- rowSums(dataset.cl &gt; 0)\n  AbsentThreshold &lt;- round(0.03*dim(dataset.cl)[2],digits = 0)\n  PresenceThreshold &lt;- round(0.1*dim(dataset.cl)[2],digits = 0)\n  file.presence[names(number.cell.expressing[number.cell.expressing &gt; AbsentThreshold]),Cluster] &lt;- \"Uncertain\" \n  \n  file.presence[names(number.cell.expressing[number.cell.expressing &gt;= PresenceThreshold]),Cluster] &lt;- \"Present\"\n  print(Cluster)\n  print(table(file.presence[,Cluster]))\n  \n  }\n\n[1] \"E13.5-184\"\n\n   Absent   Present Uncertain \n     5519      6027      3149 \n[1] \"E13.5-187\"\n\n   Absent   Present Uncertain \n     4926      7151      2618 \n[1] \"E15.0-428\"\n\n   Absent   Present Uncertain \n     6386      5253      3056 \n[1] \"E13.5-432\"\n\n   Absent   Present Uncertain \n     5765      5975      2955 \n[1] \"E15.0-432\"\n\n   Absent   Present Uncertain \n     5912      5843      2940 \n[1] \"E13.5-434\"\n\n   Absent   Present Uncertain \n     6124      5487      3084 \n[1] \"E15.0-434\"\n\n   Absent   Present Uncertain \n     6301      5396      2998 \n[1] \"E13.5-437\"\n\n   Absent   Present Uncertain \n     5943      5783      2969 \n[1] \"E15.0-437\"\n\n   Absent   Present Uncertain \n     6017      5713      2965 \n[1] \"E17.5-505\"\n\n   Absent   Present Uncertain \n     6048      5662      2985 \n[1] \"E15.0-508\"\n\n   Absent   Present Uncertain \n     5625      6240      2830 \n[1] \"E15.0-509\"\n\n   Absent   Present Uncertain \n     5452      6454      2789 \n[1] \"E13.5-510\"\n\n   Absent   Present Uncertain \n     4924      6958      2813 \n[1] \"E15.0-510\"\n\n   Absent   Present Uncertain \n     5070      6952      2673 \n[1] \"E17.5-516\"\n\n   Absent   Present Uncertain \n     5821      5847      3027"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_even_near",
    "href": "FDR_analisysResults3_10.html#clusters_even_near",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "2_Clusters_even_near",
    "text": "2_Clusters_even_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_near\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set             set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                     &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_even_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_even_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_even_near          1\n4 Lamc1 E15.0-428 FALSE 2_Clusters_even_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_even_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_even_near          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 24\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_even_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_even_nearPL &lt;- TwoClusters_even_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_even_nearPL"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_even_medium",
    "href": "FDR_analisysResults3_10.html#clusters_even_medium",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "2_Clusters_even_medium",
    "text": "2_Clusters_even_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_medium\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_even_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_even_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_even_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_even_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_even_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_even_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 771\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_even_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_even_mediumPL &lt;- Two_Clusters_even_medium + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_even_mediumPL"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_even_far",
    "href": "FDR_analisysResults3_10.html#clusters_even_far",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "2_Clusters_even_far",
    "text": "2_Clusters_even_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_far\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set            set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                    &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_even_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_even_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_even_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_even_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_even_far          1\n6 Lama1 E13.5-187 TRUE  2_Clusters_even_far          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 2325\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_even_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_even_farPL &lt;- Two_Clusters_even_far + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_even_farPL"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_uneven_near",
    "href": "FDR_analisysResults3_10.html#clusters_uneven_near",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "2_Clusters_uneven_near",
    "text": "2_Clusters_uneven_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_near\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_uneven_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_uneven_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n4 Lamc1 E15.0-428 FALSE 2_Clusters_uneven_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_uneven_near          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 24\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\nplot(roc_resultSeurat)\n\n\n\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_nearPL &lt;- Two_Clusters_uneven_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_uneven_nearPL"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_uneven_medium",
    "href": "FDR_analisysResults3_10.html#clusters_uneven_medium",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "2_Clusters_uneven_medium",
    "text": "2_Clusters_uneven_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_medium\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set                 set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                         &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 771\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_mediumPL &lt;- Two_Clusters_uneven_medium + xlab(\"FPR\") + ylab(\"TPR\")\n\nTwo_Clusters_uneven_mediumPL"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_uneven_far",
    "href": "FDR_analisysResults3_10.html#clusters_uneven_far",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "2_Clusters_uneven_far",
    "text": "2_Clusters_uneven_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_far\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set              set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                      &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_uneven_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_uneven_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n6 Lama1 E13.5-187 TRUE  2_Clusters_uneven_far          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 2325\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_farPL &lt;- Two_Clusters_uneven_far + xlab(\"FPR\") + ylab(\"TPR\")\n\nTwo_Clusters_uneven_farPL"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_even",
    "href": "FDR_analisysResults3_10.html#clusters_even",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "3_Clusters_even",
    "text": "3_Clusters_even\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_even\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set        set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                &lt;int&gt;\n1 Neil2 E15.0-437 FALSE 3_Clusters_even          1\n2 Neil2 E13.5-510 FALSE 3_Clusters_even          1\n3 Neil2 E13.5-437 FALSE 3_Clusters_even          1\n4 Lamc1 E15.0-437 FALSE 3_Clusters_even          1\n5 Lamc1 E13.5-510 FALSE 3_Clusters_even          1\n6 Lamc1 E13.5-437 FALSE 3_Clusters_even          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 2512\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E17.5-516\"\n[1] \"E13.5-437\"\n[1] \"E17.5-505\"\n[1] \"E15.0-510\"\n[1] \"E15.0-428\"\n[1] \"E13.5-510\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThree_Clusters_even &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThree_Clusters_evenPL &lt;- Three_Clusters_even + \n  xlab(\"FPR\") + ylab(\"TPR\")+theme(legend.position=\"none\")\nThree_Clusters_even"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_uneven",
    "href": "FDR_analisysResults3_10.html#clusters_uneven",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "3_Clusters_uneven",
    "text": "3_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_uneven\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E15.0-428 FALSE 3_Clusters_uneven          1\n2 Neil2 E13.5-434 FALSE 3_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 3_Clusters_uneven          1\n4 Lamc1 E15.0-428 FALSE 3_Clusters_uneven          1\n5 Lamc1 E13.5-434 FALSE 3_Clusters_uneven          1\n6 Lamc1 E15.0-510 FALSE 3_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 2816\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E15.0-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E13.5-187\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThree_Clusters_uneven &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThree_Clusters_unevenPL &lt;- Three_Clusters_uneven + xlab(\"FPR\") + ylab(\"TPR\")+theme(legend.position=\"none\")\n\nThree_Clusters_uneven"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters_uneven-1",
    "href": "FDR_analisysResults3_10.html#clusters_uneven-1",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "5_Clusters_uneven",
    "text": "5_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"5_Clusters_uneven\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E13.5-510 FALSE 5_Clusters_uneven          1\n2 Neil2 E15.0-437 FALSE 5_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 5_Clusters_uneven          1\n4 Neil2 E13.5-432 FALSE 5_Clusters_uneven          1\n5 Neil2 E13.5-437 FALSE 5_Clusters_uneven          1\n6 Lamc1 E13.5-510 FALSE 5_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 3544\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-432\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E13.5-184\"\n[1] \"E15.0-434\"\n[1] \"E17.5-505\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-187\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nFive_Clusters &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\n \nFive_Clusters_unevenPL &lt;- Five_Clusters + xlab(\"FPR\") + ylab(\"TPR\")\n\nFive_Clusters_unevenPL"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#clusters-2",
    "href": "FDR_analisysResults3_10.html#clusters-2",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "2 Clusters",
    "text": "2 Clusters\n\nggarrange(TwoClusters_even_nearPL,Two_Clusters_even_mediumPL, Two_Clusters_even_farPL,Two_Clusters_uneven_nearPL, Two_Clusters_uneven_mediumPL,Two_Clusters_uneven_farPL,\n          labels = c(\"Even_Near\", \"Even_Medium\", \"Even_Far\", \"Uneven_Near\",\"Uneven_Medium\",\"Uneven_Far\"),\n          ncol = 3, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#and-5-clusters",
    "href": "FDR_analisysResults3_10.html#and-5-clusters",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "3 and 5 Clusters",
    "text": "3 and 5 Clusters\n\nggarrange(Three_Clusters_evenPL,Three_Clusters_unevenPL, NULL, Five_Clusters_unevenPL,\n          labels = c(\"3_Even\", \"3_Uneven\", \"\", \"5_Uneven\"),\n          ncol = 2, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analisysResults3_10.html#footer",
    "href": "FDR_analisysResults3_10.html#footer",
    "title": "FDR analysis - Results - thresholds true 3% 10%",
    "section": "Footer",
    "text": "Footer\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ggpubr_0.6.0                ggplot2_3.4.2              \n [3] tidyr_1.3.0                 dplyr_1.1.2                \n [5] stringr_1.5.0               reticulate_1.35.0          \n [7] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [9] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n[11] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n[13] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n[15] matrixStats_1.2.0           Biobase_2.60.0             \n[17] BiocGenerics_0.46.0         Seurat_5.0.0               \n[19] SeuratObject_5.0.0          sp_2.1-1                   \n[21] pROC_1.18.4                 COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] rstatix_0.7.2             doParallel_1.0.17        \n [11] globals_0.16.2            lattice_0.22-5           \n [13] MASS_7.3-60               backports_1.4.1          \n [15] dendextend_1.17.1         magrittr_2.0.3           \n [17] plotly_4.10.2             rmarkdown_2.24           \n [19] yaml_2.3.7                httpuv_1.6.11            \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] minqa_1.2.5               cowplot_1.1.1            \n [27] pbapply_1.7-2             RColorBrewer_1.1-3       \n [29] zlibbioc_1.46.0           abind_1.4-5              \n [31] Rtsne_0.16                purrr_1.0.1              \n [33] RCurl_1.98-1.12           GenomeInfoDbData_1.2.10  \n [35] circlize_0.4.15           ggrepel_0.9.3            \n [37] irlba_2.3.5.1             listenv_0.9.0            \n [39] spatstat.utils_3.0-3      terra_1.7-39             \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       tidyselect_1.2.0         \n [53] shape_1.4.6               farver_2.1.1             \n [55] lme4_1.1-34               ScaledMatrix_1.8.1       \n [57] viridis_0.6.4             spatstat.explore_3.2-1   \n [59] jsonlite_1.8.7            GetoptLong_1.0.5         \n [61] ellipsis_0.3.2            progressr_0.14.0         \n [63] ggridges_0.5.4            survival_3.5-7           \n [65] iterators_1.0.14          foreach_1.5.2            \n [67] tools_4.3.2               ica_1.0-3                \n [69] Rcpp_1.0.11               glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] scattermore_1.2           tensor_1.5               \n [87] spatstat.data_3.0-1       utf8_1.2.3               \n [89] generics_0.1.3            data.table_1.15.0        \n [91] httr_1.4.6                htmlwidgets_1.6.2        \n [93] S4Arrays_1.2.0            uwot_0.1.16              \n [95] pkgconfig_2.0.3           gtable_0.3.3             \n [97] ComplexHeatmap_2.16.0     lmtest_0.9-40            \n [99] XVector_0.40.0            htmltools_0.5.7          \n[101] carData_3.0-5             dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] nlme_3.1-163              zoo_1.8-12               \n[113] GlobalOptions_0.1.2       KernSmooth_2.23-22       \n[115] parallel_4.3.2            miniUI_0.1.1.1           \n[117] RcppZiggurat_0.1.6        pillar_1.9.0             \n[119] grid_4.3.2                vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] car_3.1-2                 BiocSingular_1.16.0      \n[125] beachmat_2.16.0           xtable_1.8-4             \n[127] cluster_2.1.6             evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              ggsignif_0.6.4           \n[135] future.apply_1.11.0       labeling_0.4.2           \n[137] plyr_1.8.8                stringi_1.8.1            \n[139] viridisLite_0.4.2         deldir_2.0-2             \n[141] BiocParallel_1.34.2       assertthat_0.2.1         \n[143] munsell_0.5.0             lazyeval_0.2.2           \n[145] spatstat.geom_3.2-4       PCAtools_2.14.0          \n[147] Matrix_1.6-3              RcppHNSW_0.6.0           \n[149] patchwork_1.2.0           sparseMatrixStats_1.12.2 \n[151] future_1.33.0             shiny_1.8.0              \n[153] ROCR_1.0-11               Rfast_2.1.0              \n[155] broom_1.0.5               igraph_1.6.0             \n[157] RcppParallel_5.1.7"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html",
    "href": "FDR_DataSetCreation_ByClusterMerging.html",
    "title": "False Discovery Rate: data-sets creation",
    "section": "",
    "text": "# Load the libraries\nlibrary(stringr)\nlibrary(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\n\n\nassert_that(packageVersion(\"COTAN\") &gt;= package_version(\"2.3.3\"),\n            msg = \"Error: The required version of the 'COTAN' library is 2.3.3\")\n\n[1] TRUE\n\ninDir &lt;- file.path(\"Data/MouseCortexFromLoom/\")\ninRawDataDir &lt;- file.path(inDir, \"SingleClusterRawData/\")\n\noutDir &lt;- file.path(\"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\")\nif (!dir.exists(outDir)) {\n  dir.create(outDir)\n}\n\noutMergedRawDataDir &lt;- outDir\nif (!dir.exists(outMergedRawDataDir)) {\n  dir.create(outMergedRawDataDir)\n}\n\noptions(parallelly.fork.enable = TRUE)\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"MixingClusters_FDR_ForebrainDorsal.log\"))"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#preamble",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#preamble",
    "title": "False Discovery Rate: data-sets creation",
    "section": "",
    "text": "# Load the libraries\nlibrary(stringr)\nlibrary(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\n\n\nassert_that(packageVersion(\"COTAN\") &gt;= package_version(\"2.3.3\"),\n            msg = \"Error: The required version of the 'COTAN' library is 2.3.3\")\n\n[1] TRUE\n\ninDir &lt;- file.path(\"Data/MouseCortexFromLoom/\")\ninRawDataDir &lt;- file.path(inDir, \"SingleClusterRawData/\")\n\noutDir &lt;- file.path(\"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\")\nif (!dir.exists(outDir)) {\n  dir.create(outDir)\n}\n\noutMergedRawDataDir &lt;- outDir\nif (!dir.exists(outMergedRawDataDir)) {\n  dir.create(outMergedRawDataDir)\n}\n\noptions(parallelly.fork.enable = TRUE)\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"MixingClusters_FDR_ForebrainDorsal.log\"))"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#loading-all-cotan-objects",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#loading-all-cotan-objects",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Loading all COTAN Objects",
    "text": "Loading all COTAN Objects\n\nfb135Obj &lt;- readRDS(file = file.path(inRawDataDir, \"e13.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nfb150Obj &lt;- readRDS(file = file.path(inRawDataDir, \"e15.0_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\nfb175Obj &lt;- readRDS(file = file.path(inRawDataDir, \"e17.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#relevant-clusters-lists",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#relevant-clusters-lists",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Relevant clusters lists",
    "text": "Relevant clusters lists"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#align-clusters-from-different-datasets",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#align-clusters-from-different-datasets",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Align clusters from different datasets",
    "text": "Align clusters from different datasets\n\nallGenes &lt;- union(union(getGenes(fb135Obj), getGenes(fb150Obj)), getGenes(fb175Obj))\n\n# This function completes the raw data so that the genes list\n# matches the `allGenes` above\nfillGenes &lt;- function(m, prefixName) {\n  # find the missing genes in the given matrix m\n  missingGenes &lt;- !(allGenes %in% rownames(m))\n  # create a matrix with the right sizes for the missing genes\n  # and set their values all to zero\n  fillM &lt;- matrix(0, nrow = sum(missingGenes), ncol = ncol(m))\n  rownames(fillM) &lt;- allGenes[missingGenes]\n  # append the new matrix to the original and reorder the rows\n  # to match overall genes order\n  retM &lt;- rbind(m, fillM)\n  retM &lt;- retM[allGenes, ]\n  # assign unique identifiers to the columns, so that one can discriminate\n  # the source even after merging with other matrices\n  colnames(retM) &lt;- paste0(prefixName, \"_\", colnames(retM))\n  return(retM)\n}"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#create-all-raw-data-for-each-cluster-compatible-with-the-full-genes-list",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#create-all-raw-data-for-each-cluster-compatible-with-the-full-genes-list",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Create all raw data for each cluster compatible with the full genes’ list",
    "text": "Create all raw data for each cluster compatible with the full genes’ list\n\nallClustersRawData &lt;- list()\nfor (dsName in names(relevant)) {\n  clList &lt;- toClustersList(getClusters(objSelector(dsName),\n                                       clName = \"original.clusters\"))\n  for (clName in relevant[[dsName]]) {\n    fullName &lt;- fullClusterName(dsName = dsName, clName = clName)\n    fullRawData &lt;- fillGenes(getRawData(objSelector(dsName))[, clList[[clName]]],\n                             fullName)\n    allClustersRawData &lt;- append(allClustersRawData, list(fullRawData))\n    names(allClustersRawData)[length(allClustersRawData)] &lt;- fullName\n  }\n}\n\nassert_that(identical(rownames(allClustersRawData[[1]]), allGenes))\n\n# delete the COTAN objects\nrm(fb135Obj, fb150Obj, fb175Obj)"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#calculate-ritz-average-for-each-cluster",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#calculate-ritz-average-for-each-cluster",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Calculate ritz average for each cluster",
    "text": "Calculate ritz average for each cluster"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#parse-selected-clusters-collections",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#parse-selected-clusters-collections",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Parse selected clusters’ collections",
    "text": "Parse selected clusters’ collections"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#create-merged-clusters-cells-collections",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#create-merged-clusters-cells-collections",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Create merged clusters cells’ collections",
    "text": "Create merged clusters cells’ collections\n\nset.seed(137L)\n\ncellsUsed &lt;- as.data.frame(x = matrix(list(), ncol = 2 + length(allClustersRawData)))\n\nfor (i in (1:length(allComb))) {\n  metaGroup &lt;- allComb[[i]]\n  metaMix &lt;- allMixtures[[i]]\n  metaGroupName &lt;- names(allComb)[[i]]\n  print(paste0(\"Meta: \", metaGroupName))\n  \n  for (j in 1:length(metaGroup)) {\n    group &lt;- metaGroup[[j]]\n    groupMix &lt;- metaMix[[j]]\n    groupName &lt;- paste0(metaGroupName, \"_\", names(metaGroup)[[j]])\n    print(paste0(\"Group: \", groupName))\n\n    for (k in 1:length(group)) {\n      coll &lt;- group[[k]]\n      mix &lt;- groupMix[[k]]\n      collName &lt;- paste0(groupName, \"_\", k)\n      print(paste0(\"Coll: \", collName))\n      \n      pos &lt;- names(allClustersRawData) %in% coll\n      collRawData &lt;- allClustersRawData[pos]\n      \n      len &lt;- unlist(lapply(collRawData, ncol))\n      perm &lt;- order(len, decreasing = TRUE)\n\n      ratios &lt;- len[perm] / mix\n      \n      cellsToPickUp &lt;- set_names(ceiling(mix * min(ratios)),\n                                 nm = names(len)[perm])\n\n      collAsStr &lt;- paste0(coll[perm], collapse = \"_+_\")\n      \n      numUsedCells &lt;- set_names(rep(0L, length(allClustersRawData)),\n                             nm = names(allClustersRawData))\n      numUsedCells[names(cellsToPickUp)] &lt;- cellsToPickUp\n      \n      cellsUsed &lt;- rbind(cellsUsed, c(groupName, collAsStr, numUsedCells))\n\n      mergedRawData &lt;- data.frame(row.names = allGenes)\n      mergedClusters &lt;- c()\n      for (clName in names(cellsToPickUp)) {\n        cells &lt;- sample(colnames(allClustersRawData[[clName]]),\n                        size = cellsToPickUp[[clName]],\n                        replace = FALSE)\n        mergedClusters &lt;- c(mergedClusters,\n                            rep.int(max(0, mergedClusters) + 1L,\n                                    times = length(cells)))\n        mergedRawData &lt;- cbind(mergedRawData,\n                               as.data.frame(allClustersRawData[[clName]][, cells]))\n      }\n      names(mergedClusters) &lt;- colnames(mergedRawData)\n      mergedClusters &lt;- niceFactorLevels(mergedClusters)\n      \n      mergedObj &lt;- automaticCOTANObjectCreation(mergedRawData,\n                                         GEO = groupName,\n                                         sequencingMethod = \"10X\",\n                                         sampleCondition = collAsStr,\n                                         calcCoex = FALSE,\n                                         cores = 5L,\n                                         saveObj = FALSE)\n      mergedObj &lt;- addClusterization(mergedObj, clName = \"mergedClusters\",\n                                     clusters = mergedClusters,\n                                     override = FALSE)\n\n      lfcDF &lt;- logFoldChangeOnClusters(mergedObj, clusters = mergedClusters)\n      mergedObj &lt;- addClusterization(mergedObj,\n                                     clName = \"Contains_LogFoldChange\",\n                                     clusters = mergedClusters,\n                                     coexDF = lfcDF, override = FALSE)\n\n      outFileName &lt;- file.path(outMergedRawDataDir,\n                               paste0(collName, \"_\", collAsStr, \".RDS\"))\n      print(outFileName)\n      saveRDS(mergedObj, file = outFileName)\n    }\n  }\n}\ncolnames(cellsUsed) &lt;- c(\"Group\", \"Collection\", names(allClustersRawData))\n\nhead(cellsUsed, n = 10)\n\nwrite.csv(cellsUsed, file = file.path(outMergedRawDataDir, \"Cells_Usage_DataFrame.csv\"))"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#loader",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#loader",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Loader",
    "text": "Loader\n\ncellsUsed &lt;- read.csv(file = file.path(outMergedRawDataDir, \"Cells_Usage_DataFrame.csv\"))\n\nnumTopGenes &lt;- 100\n\nfor(i in (1:nrow(cellsUsed))) {\n  collName &lt;- cellsUsed[i, \"Group\"]\n  collAsStr &lt;- cellsUsed[i, \"Collection\"]\n  fileName &lt;- file.path(outMergedRawDataDir,\n                        paste0(collName, \"_\", (i - 1) %% 3 + 1,\n                               \"_\", collAsStr, \".RDS\"))\n  print(paste(\"Analisys of\", collName, \"consisting of clusters\", collAsStr))\n  \n  obj &lt;- readRDS(fileName)\n  \n  cm1DF &lt;- findClustersMarkers(obj, n = numTopGenes, clName = \"mergedClusters\")\n  \n  lfcDF &lt;- getClusterizationData(obj, clName = \"Contains_LogFoldChange\")[[\"coex\"]]\n\n  cm2DF &lt;- as.data.frame(matrix(data = NA, nrow = 0L, ncol = 3L))\n  colnames(cm2DF) &lt;- c(\"CL\", \"Gene\", \"LFC\")\n\n  for(cl in colnames(lfcDF)) {\n    for (type in c(\"min\", \"max\")) {\n        tmpDF &lt;- as.data.frame(matrix(data = NA, nrow = numTopGenes, ncol = ncol(cm2DF)))\n        colnames(tmpDF) &lt;- colnames(cm2DF)\n\n        # Get the first numTopGenes minimum/maximum scores for each cluster\n        sortedPos &lt;- order(lfcDF[, cl], decreasing = (type == \"max\"))[1L:numTopGenes]\n  \n        tmpDF[[\"CL\"]]   &lt;- cl\n        tmpDF[[\"Gene\"]] &lt;- rownames(lfcDF)[sortedPos]\n        tmpDF[[\"LFC\"]]  &lt;- lfcDF[sortedPos, cl]\n\n        cm2DF &lt;- rbind(cm2DF, tmpDF)\n        rm(tmpDF)\n    }\n  }\n\n  assert_that(identical(cm1DF$CL, cm2DF$CL))\n  \n  print(\"fraction of matching genes per cluster\")\n  \n  ## to be finished, debugged...\n  for (bl in c(0:(nrow(cm1DF) %/% numTopGenes -1))) {\n    r &lt;- bl * numTopGenes\n    genes1 &lt;- cm1DF[(r + 1):(r + numTopGenes), \"Gene\"]\n    genes2 &lt;- cm2DF[(r + 1):(r + numTopGenes), \"Gene\"]\n\n    msg &lt;- paste0(\"Cluster \", cm1DF[r + 1, \"CL\"], \": \", \n                 100.0 * length(intersect(genes1, genes2)) / numTopGenes, \"%\")\n    print(msg)\n  }\n}"
  },
  {
    "objectID": "FDR_DataSetCreation_ByClusterMerging.html#footer",
    "href": "FDR_DataSetCreation_ByClusterMerging.html#footer",
    "title": "False Discovery Rate: data-sets creation",
    "section": "Footer",
    "text": "Footer\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.3.3       data.table_1.15.0 zeallot_0.1.0     ggplot2_3.4.2    \n[5] scales_1.3.0      rlang_1.1.1       assertthat_0.2.1  stringr_1.5.0    \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3        rstudioapi_0.15.0        \n  [3] jsonlite_1.8.7            shape_1.4.6              \n  [5] umap_0.2.10.0             magrittr_2.0.3           \n  [7] spatstat.utils_3.0-3      rmarkdown_2.24           \n  [9] GlobalOptions_0.1.2       vctrs_0.6.3              \n [11] ROCR_1.0-11               spatstat.explore_3.2-1   \n [13] DelayedMatrixStats_1.22.5 askpass_1.2.0            \n [15] htmltools_0.5.7           S4Arrays_1.2.0           \n [17] sctransform_0.4.1         parallelly_1.36.0        \n [19] KernSmooth_2.23-22        htmlwidgets_1.6.2        \n [21] ica_1.0-3                 plyr_1.8.8               \n [23] plotly_4.10.2             zoo_1.8-12               \n [25] igraph_1.6.0              mime_0.12                \n [27] lifecycle_1.0.3           iterators_1.0.14         \n [29] pkgconfig_2.0.3           rsvd_1.0.5               \n [31] Matrix_1.6-3              R6_2.5.1                 \n [33] fastmap_1.1.1             MatrixGenerics_1.12.3    \n [35] fitdistrplus_1.1-11       future_1.33.0            \n [37] shiny_1.8.0               clue_0.3-64              \n [39] digest_0.6.33             colorspace_2.1-0         \n [41] patchwork_1.2.0           S4Vectors_0.38.1         \n [43] tensor_1.5                Seurat_5.0.0             \n [45] dqrng_0.3.0               RSpectra_0.16-1          \n [47] irlba_2.3.5.1             beachmat_2.16.0          \n [49] PCAtools_2.14.0           progressr_0.14.0         \n [51] RcppZiggurat_0.1.6        spatstat.sparse_3.0-2    \n [53] fansi_1.0.4               polyclip_1.10-4          \n [55] httr_1.4.6                abind_1.4-5              \n [57] compiler_4.3.2            withr_3.0.0              \n [59] doParallel_1.0.17         BiocParallel_1.34.2      \n [61] viridis_0.6.4             fastDummies_1.7.3        \n [63] dendextend_1.17.1         MASS_7.3-60              \n [65] openssl_2.1.0             DelayedArray_0.26.7      \n [67] rjson_0.2.21              tools_4.3.2              \n [69] lmtest_0.9-40             httpuv_1.6.11            \n [71] future.apply_1.11.0       goftest_1.2-3            \n [73] glue_1.7.0                nlme_3.1-163             \n [75] promises_1.2.0.1          grid_4.3.2               \n [77] Rtsne_0.16                cluster_2.1.6            \n [79] reshape2_1.4.4            generics_0.1.3           \n [81] spatstat.data_3.0-1       gtable_0.3.3             \n [83] tidyr_1.3.0               BiocSingular_1.16.0      \n [85] ScaledMatrix_1.8.1        sp_2.1-1                 \n [87] utf8_1.2.3                spatstat.geom_3.2-4      \n [89] BiocGenerics_0.46.0       RcppAnnoy_0.0.21         \n [91] ggrepel_0.9.3             RANN_2.6.1               \n [93] foreach_1.5.2             pillar_1.9.0             \n [95] spam_2.10-0               RcppHNSW_0.6.0           \n [97] later_1.3.1               circlize_0.4.15          \n [99] splines_4.3.2             dplyr_1.1.2              \n[101] lattice_0.22-5            deldir_2.0-2             \n[103] survival_3.5-7            tidyselect_1.2.0         \n[105] ComplexHeatmap_2.16.0     miniUI_0.1.1.1           \n[107] pbapply_1.7-2             knitr_1.43               \n[109] gridExtra_2.3             IRanges_2.34.1           \n[111] scattermore_1.2           stats4_4.3.2             \n[113] xfun_0.39                 matrixStats_1.2.0        \n[115] stringi_1.8.1             lazyeval_0.2.2           \n[117] yaml_2.3.7                evaluate_0.21            \n[119] codetools_0.2-19          tibble_3.2.1             \n[121] cli_3.6.1                 uwot_0.1.16              \n[123] RcppParallel_5.1.7        xtable_1.8-4             \n[125] reticulate_1.35.0         munsell_0.5.0            \n[127] Rcpp_1.0.11               spatstat.random_3.2-1    \n[129] globals_0.16.2            png_0.1-8                \n[131] parallel_4.3.2            Rfast_2.1.0              \n[133] ellipsis_0.3.2            dotCall64_1.1-0          \n[135] parallelDist_0.2.6        sparseMatrixStats_1.12.2 \n[137] listenv_0.9.0             ggthemes_5.0.0           \n[139] viridisLite_0.4.2         ggridges_0.5.4           \n[141] purrr_1.0.1               SeuratObject_5.0.0       \n[143] leiden_0.4.3              crayon_1.5.2             \n[145] GetoptLong_1.0.5          cowplot_1.1.1"
  },
  {
    "objectID": "DEA_Type1Error.html",
    "href": "DEA_Type1Error.html",
    "title": "Differential expression analisys: type I error",
    "section": "",
    "text": "library(COTAN)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(viridis)\n\n\ndirOut &lt;- \"Results/TypeIError/\"\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/SingleClusterRawData/\"\n\n\nAutomatic functions\n\nCOTAN.DEA &lt;- function(dataSet,clusters.list, GEO.code, sequencingMethod,sampleCondition, clName,dirOut,percentage){\n  obj &lt;- automaticCOTANObjectCreation(raw = dataSet,\n                                      calcCoex = F,\n                                      cores = 10,\n                                      saveObj = F,\n                                      GEO = GEO.code,\n                                      sequencingMethod = sequencingMethod,\n                                      sampleCondition = sampleCondition)\n  obj &lt;- addClusterization(obj,clName = clName,clusters = clusters.list)\n  \n  DF.DEA &lt;- DEAOnClusters(obj,clName = clName )\n  pval.DEA &lt;- pValueFromDEA(DF.DEA,numCells = getNumCells(obj))\n  adj.pval.DEA &lt;- pval.DEA\n  for (col in colnames(pval.DEA)) {\n    adj.pval.DEA[,col] &lt;- p.adjust(adj.pval.DEA[,col],method = \"bonferroni\")\n  }\n  n.genes.DEA &lt;- sum(adj.pval.DEA &lt; 0.05)\n  res &lt;- list(\"n.genes.DEA\"=n.genes.DEA,\"DF.DEA\"=DF.DEA,\"adj.pval.DEA\" = adj.pval.DEA)\n  \n  write.csv(res$adj.pval.DEA, file = paste0(dirOut,clName,\"_de_genes_COTAN_\",percentage,\".csv\"))\n  \n  return(res)\n\n}\n\nSeurat.DEA &lt;- function(dataSet,clusters.list, project, dirOut,percentage){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n  \n  \n  pbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n  pbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n  all.genes &lt;- rownames(pbmc)\n  pbmc &lt;- ScaleData(pbmc, features = all.genes)\n  \n  pbmc &lt;- RunPCA(pbmc)\n  pbmc &lt;- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- factor(clusters.list)\n  \n  pbmc &lt;- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE)\n  \n  \n  \n  n.genes.DEA &lt;- sum(pbmc.markers$p_val_adj &lt; 0.05)\n  \n  print(n.genes.DEA)\n  \n  write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n  }\n\nMonocle.DEA &lt;- function(dataSet,clusters.list,project, dirOut,percentage){\n  \n  cell_metadata = as.data.frame(clusters.list[colnames(dataSet)])\n  colnames(cell_metadata) &lt;- \"Clusters\"\n  cds &lt;- new_cell_data_set(dataSet[rowSums(dataSet) &gt; 3,],\n                         cell_metadata = cell_metadata\n                         )\n  colData(cds)$cluster &lt;- clusters.list[rownames(colData(cds))]\n\n  #cds &lt;- preprocess_cds(cds, num_dim = 100)\n  #cds &lt;- reduce_dimension(cds)\n  #cds &lt;- cluster_cells(cds, resolution=1e-5)\n\n  marker_test_res &lt;- top_markers(cds, \n                                 group_cells_by=\"Clusters\", \n                                 genes_to_test_per_group = dim(cds)[1],\n                                  cores=10)\n  \n  # de_results &lt;- fit_models(cds,model_formula_str = \" ~ cluster\",cores = 10,verbose = T)\n  # fit_coefs &lt;- coefficient_table(de_results)\n  # \n  # fit_coefs &lt;- fit_coefs %&gt;% filter(term == \"cluster\")\n  \n  write.csv(marker_test_res, file = paste0(dirOut,project,\"_de_genes_Monocle_\",percentage,\".csv\"))\n  \n  # return(list(\"n.genes.DEA\"=sum(fit_coefs$q_value &lt; 0.05, na.rm = T),\n  #             \"fit_coefs\"= fit_coefs,\n  #             \"de_results\"=de_results))\n  return(list(\"n.genes.DEA\"=sum(marker_test_res$marker_test_q_value &lt; 0.05, na.rm = T),\n              \"marker_test_res\"= marker_test_res\n              ))\n}\n\n\nScanPy.DEA &lt;- function(dataSet,\n                       clusters.list, \n                       project, \n                       dirOut,\n                       percentage){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- clusters.list\n  \n  exprs &lt;- pbmc@assays$RNA$counts\n  \n  meta &lt;- pbmc[[]]\n  #feature_meta &lt;- GetAssay(pbmc)[[]]\n  tmp &lt;- as.data.frame(matrix(data = NA, \n                              ncol = 1, \n                              nrow = nrow(pbmc@assays$RNA$counts)))\n  rownames(tmp) &lt;- rownames(pbmc@assays$RNA$counts)\n  \n  feature_meta &lt;- tmp\n  #embedding &lt;- Embeddings(pbmc, \"umap\")\n  \n  Sys.setenv(RETICULATE_PYTHON = \"../../../bin/python3\")\n  py &lt;- import(\"sys\")\n  \n  source_python(\"src/scanpyTypeIError.py\")\n  scanpyTypeIError(exprs, \n                   meta, \n                   feature_meta, \n                   \"mt\", \n                   dirOut, \n                   percentage,project)\n\n  out &lt;- read.csv(file = paste0(dirOut,\n                                project,\n                                \"_ScanPy_de_genes_\",\n                                percentage,\n                                \".csv\"),\n                  header = T, \n                  row.names = 1)\n  \n  gc()\n\n  return(out)\n}\n\nWe would evaluate the Type I error and to do so, we consider some transcriptionally uniform clusters from the Loom dataset. We splitted these cluster in two partitions (with three different dimensions: 1/2, 1/3 and 1/4) one containing the cells with higher library size and the other with the lower library size. On these two clusters we than tested the four different software.\n\nfor (perc in c(0.75)) { #0.5, 0.33, 0.25,0.67, \n  outPutMatrix &lt;- as.data.frame(matrix(nrow = 1,ncol = 4))\n  colnames(outPutMatrix) &lt;- c(\"Cotan\",\"Seurat\", \"Monocle\", \"ScanPy\")\n\n  for (dataSet in list.files(dataSetDir)) {\n  \n    cluster.name &lt;- str_split(dataSet,pattern = \"_\", simplify = T)[1]\n    \n    print(cluster.name)\n    outTemp &lt;- NA\n     \n    dataSet &lt;- readRDS(paste0(dataSetDir,dataSet))\n    \n\n    cl1 &lt;- colnames(dataSet)[order(colSums(dataSet),decreasing = T)[1:round(ncol(dataSet)*perc,digits = 0)]]\n    \n    clusters.list &lt;- list(\"cl1\"=cl1,\n                          \"cl2\"=colnames(dataSet)[!colnames(dataSet) %in% cl1])\n  \n    clusters.list &lt;- setNames(rep(1,ncol(dataSet)),\n                              colnames(dataSet))\n    clusters.list[colnames(dataSet)[!colnames(dataSet) %in% cl1]] &lt;- 2 \n  \n    cotan.dea.out &lt;- COTAN.DEA(dataSet = dataSet,\n                               clusters.list = clusters.list,\n                               GEO.code = \"\",\n                               sequencingMethod = \"10x\",\n                               sampleCondition = \"Temp\",\n                               clName =  cluster.name,\n                               dirOut, percentage = perc)\n  \n    outTemp &lt;- c(outTemp,cotan.dea.out$n.genes.DEA)\n    \n    rm(cotan.dea.out)\n    gc()\n  \n    seurat.dea.out &lt;- Seurat.DEA(dataSet = dataSet,\n                               clusters.list = clusters.list,\n                               project = cluster.name,\n                               dirOut, percentage = perc)\n  \n    outTemp &lt;- c(outTemp,seurat.dea.out$n.genes.DEA)\n    \n    rm(seurat.dea.out)\n    gc()\n  \n  \n    monocle.dea.out &lt;- Monocle.DEA(dataSet = dataSet,\n                                   clusters.list = clusters.list,\n                                   project = cluster.name,\n                                   dirOut = dirOut, percentage = perc)\n  \n    outTemp &lt;- c(outTemp,monocle.dea.out$n.genes.DEA)\n    rm(monocle.dea.out)\n    gc()\n  \n    ScanPy.dea.out &lt;- ScanPy.DEA(dataSet = dataSet, \n                                 clusters.list = clusters.list, \n                                 project = cluster.name, \n                                 dirOut = dirOut, percentage = perc\n                                  )\n    \n  \n    ScanPy.dea.out.filterd &lt;- ScanPy.dea.out[ScanPy.dea.out$pval_adj &lt; 0.05\n                                             & ScanPy.dea.out$clusters == \"cl1.0\",]\n    \n    outTemp &lt;- c(outTemp,dim(ScanPy.dea.out.filterd)[1])\n    rm(ScanPy.dea.out.filterd)\n    gc()\n    \n    outTemp &lt;- outTemp[2:length(outTemp)]\n    \n    outPutMatrix &lt;- rbind(outPutMatrix,outTemp)\n    rownames(outPutMatrix)[nrow(outPutMatrix)] &lt;- cluster.name\n    \n    write.csv(outPutMatrix,paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n  }\n  \n  outPutMatrix &lt;-   outPutMatrix[2:nrow(outPutMatrix),]\n  write.csv(outPutMatrix,paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n\n}\n\n\n\nSummarize the output\n\ndf_plot &lt;- NA\nfor (perc in c(0.5, 0.33, 0.25,0.67, 0.75)) {\n  outPutMatrix &lt;- read.csv(paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n  \n  outPutMatrix$Division &lt;- perc\n  \n  df_plot &lt;- rbind(df_plot,outPutMatrix)\n  \n}\ndf_plot &lt;- df_plot[2:nrow(df_plot),]\n\ndf_plot &lt;- as.data.frame(pivot_longer(df_plot,cols = c(2:5),values_to = \"N.Genes\",names_to = \"Method\"))\n\n\n\nggplot(df_plot,aes(x = Method, y=N.Genes,fill=Method))+geom_boxplot()+\nscale_fill_viridis(discrete = TRUE, alpha=0.6) + facet_wrap(~Division)+\n    geom_jitter(color=\"black\", size=0.4, alpha=0.9) +theme_light()+\n    theme(\n      legend.position=\"none\",\n      plot.title = element_text(size=11)\n    )\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] viridis_0.6.4               viridisLite_0.4.2          \n [3] ggplot2_3.4.2               tidyr_1.3.0                \n [5] dplyr_1.1.2                 stringr_1.5.0              \n [7] reticulate_1.35.0           monocle3_1.3.4             \n [9] SingleCellExperiment_1.22.0 SummarizedExperiment_1.30.2\n[11] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1        \n[13] IRanges_2.34.1              S4Vectors_0.38.1           \n[15] MatrixGenerics_1.12.3       matrixStats_1.2.0          \n[17] Biobase_2.60.0              BiocGenerics_0.46.0        \n[19] Seurat_5.0.0                SeuratObject_5.0.0         \n[21] sp_2.1-1                    COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] doParallel_1.0.17         globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] dendextend_1.17.1         magrittr_2.0.3           \n [15] plotly_4.10.2             rmarkdown_2.24           \n [17] yaml_2.3.7                httpuv_1.6.11            \n [19] sctransform_0.4.1         spam_2.10-0              \n [21] askpass_1.2.0             spatstat.sparse_3.0-2    \n [23] minqa_1.2.5               cowplot_1.1.1            \n [25] pbapply_1.7-2             RColorBrewer_1.1-3       \n [27] zlibbioc_1.46.0           abind_1.4-5              \n [29] Rtsne_0.16                purrr_1.0.1              \n [31] RCurl_1.98-1.12           GenomeInfoDbData_1.2.10  \n [33] circlize_0.4.15           ggrepel_0.9.3            \n [35] irlba_2.3.5.1             listenv_0.9.0            \n [37] spatstat.utils_3.0-3      terra_1.7-39             \n [39] umap_0.2.10.0             goftest_1.2-3            \n [41] RSpectra_0.16-1           spatstat.random_3.2-1    \n [43] dqrng_0.3.0               fitdistrplus_1.1-11      \n [45] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [47] leiden_0.4.3              codetools_0.2-19         \n [49] DelayedArray_0.26.7       tidyselect_1.2.0         \n [51] shape_1.4.6               farver_2.1.1             \n [53] lme4_1.1-34               ScaledMatrix_1.8.1       \n [55] spatstat.explore_3.2-1    jsonlite_1.8.7           \n [57] GetoptLong_1.0.5          ellipsis_0.3.2           \n [59] progressr_0.14.0          ggridges_0.5.4           \n [61] survival_3.5-7            iterators_1.0.14         \n [63] foreach_1.5.2             tools_4.3.2              \n [65] ica_1.0-3                 Rcpp_1.0.11              \n [67] glue_1.7.0                gridExtra_2.3            \n [69] xfun_0.39                 ggthemes_5.0.0           \n [71] withr_3.0.0               fastmap_1.1.1            \n [73] boot_1.3-28               fansi_1.0.4              \n [75] openssl_2.1.0             digest_0.6.33            \n [77] rsvd_1.0.5                parallelDist_0.2.6       \n [79] R6_2.5.1                  mime_0.12                \n [81] colorspace_2.1-0          scattermore_1.2          \n [83] tensor_1.5                spatstat.data_3.0-1      \n [85] utf8_1.2.3                generics_0.1.3           \n [87] data.table_1.15.0         httr_1.4.6               \n [89] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [91] uwot_0.1.16               pkgconfig_2.0.3          \n [93] gtable_0.3.3              ComplexHeatmap_2.16.0    \n [95] lmtest_0.9-40             XVector_0.40.0           \n [97] htmltools_0.5.7           dotCall64_1.1-0          \n [99] clue_0.3-64               scales_1.3.0             \n[101] png_0.1-8                 knitr_1.43               \n[103] rstudioapi_0.15.0         reshape2_1.4.4           \n[105] rjson_0.2.21              nloptr_2.0.3             \n[107] nlme_3.1-163              zoo_1.8-12               \n[109] GlobalOptions_0.1.2       KernSmooth_2.23-22       \n[111] parallel_4.3.2            miniUI_0.1.1.1           \n[113] RcppZiggurat_0.1.6        pillar_1.9.0             \n[115] grid_4.3.2                vctrs_0.6.3              \n[117] RANN_2.6.1                promises_1.2.0.1         \n[119] BiocSingular_1.16.0       beachmat_2.16.0          \n[121] xtable_1.8-4              cluster_2.1.6            \n[123] evaluate_0.21             zeallot_0.1.0            \n[125] cli_3.6.1                 compiler_4.3.2           \n[127] rlang_1.1.1               crayon_1.5.2             \n[129] future.apply_1.11.0       labeling_0.4.2           \n[131] plyr_1.8.8                stringi_1.8.1            \n[133] deldir_2.0-2              BiocParallel_1.34.2      \n[135] assertthat_0.2.1          munsell_0.5.0            \n[137] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[139] PCAtools_2.14.0           Matrix_1.6-3             \n[141] RcppHNSW_0.6.0            patchwork_1.2.0          \n[143] sparseMatrixStats_1.12.2  future_1.33.0            \n[145] shiny_1.8.0               ROCR_1.0-11              \n[147] Rfast_2.1.0               igraph_1.6.0             \n[149] RcppParallel_5.1.7"
  },
  {
    "objectID": "CorticalCells_GSM2861514_E175-analysis.html",
    "href": "CorticalCells_GSM2861514_E175-analysis.html",
    "title": "Cortical cells DGE E17.5 Data-set Anaysis",
    "section": "",
    "text": "library(ggplot2)\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"Data/Yuzwa_MouseCortex/\"\n\nsetLoggingLevel(1)\nsetLoggingFile(file.path(outDir, \"CorticalCells_GSM2861514_E175-analysis.log\"))\nRead the dataset from file\ndataset &lt;- read.csv(file.path(outDir &lt;- \"Data/Yuzwa_MouseCortex/\"\n, \"GSM2861514_E175_Only_Cortical_Cells_DGE.txt\"),\n       header = TRUE, sep = \"\\t\", strip.white = TRUE,row.names = 1)"
  },
  {
    "objectID": "CorticalCells_GSM2861514_E175-analysis.html#cleaning",
    "href": "CorticalCells_GSM2861514_E175-analysis.html#cleaning",
    "title": "Cortical cells DGE E17.5 Data-set Anaysis",
    "section": "Cleaning",
    "text": "Cleaning\nCrate the COTAN object\n\nsampleCondition &lt;- \"CorticalCells_GSM2861514_E175\"\ncc175Obj &lt;- COTAN(raw = dataset)\ncc175Obj &lt;- initializeMetaDataset(cc175Obj,\n                                  GEO = \"GSM2861511_E135\",\n                                  sequencingMethod = \"DropSeq\",\n                                  sampleCondition = sampleCondition)\n\nInspect cells’ sizes\n\ncellSizePlot(cc175Obj)\n\n\n\n\nDrop cells with too many ritz reads as they are probably duplets\n\ncellsSizeThr &lt;- 6500\ncc175Obj &lt;- addElementToMetaDataset(cc175Obj, \"Cells size threshold\", cellsSizeThr)\n\ncells_to_rem &lt;- getCells(cc175Obj)[getCellsSize(cc175Obj) &gt; cellsSizeThr]\ncc175Obj &lt;- dropGenesCells(cc175Obj, cells = cells_to_rem)\n\ncellSizePlot(cc175Obj)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(cc175Obj)\n\n\n\n\nDrop cells with too high genes expession as they are probably duplets\n\ngenesSizeThr &lt;- 3000\ncc175Obj &lt;- addElementToMetaDataset(cc175Obj, \"Num genes threshold\", genesSizeThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(cc175Obj)\ncells_to_rem &lt;- names(numExprGenes)[numExprGenes &gt; genesSizeThr]\ncc175Obj &lt;- dropGenesCells(cc175Obj, cells = cells_to_rem)\n\ngenesSizePlot(cc175Obj)\n\n\n\n\nCheck number of mitocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^mt-\"\ngetGenes(cc175Obj)[grep(mitGenesPattern, getGenes(cc175Obj))]\n\n [1] \"mt-Co1\"  \"mt-Co2\"  \"mt-Co3\"  \"mt-Cytb\" \"mt-Nd1\"  \"mt-Nd2\"  \"mt-Nd4\" \n [8] \"mt-Nd5\"  \"mt-Nd6\"  \"mt-Rnr1\" \"mt-Rnr2\" \"mt-Ta\"   \"mt-Tc\"   \"mt-Te\"  \n[15] \"mt-Tf\"   \"mt-Ti\"   \"mt-Tl1\"  \"mt-Tl2\"  \"mt-Tm\"   \"mt-Tp\"   \"mt-Tq\"  \n[22] \"mt-Ts2\"  \"mt-Tt\"   \"mt-Tv\"   \"mt-Tw\"   \"mt-Ty\"  \n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(cc175Obj, genePrefix = mitGenesPattern)\n\nplot(mitPlot)\n\n\n\n\nCells with a too high percentage of mitocondrial genes are likely dead (or at the last problematic) cells. So we drop them!\n\nmitPercThr &lt;- 5.0\ncc175Obj &lt;- addElementToMetaDataset(cc175Obj, \"Mitoc. perc. threshold\", mitPercThr)\n\ncells_to_rem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\ncc175Obj &lt;- dropGenesCells(cc175Obj, cells = cells_to_rem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(cc175Obj, genePrefix = mitGenesPattern)\n\nplot(mitPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(cc175Obj)\n\n\n\ngenesSizePlot(cc175Obj)\n\n\n\n\n\nClean: round 1\n\ncc175Obj &lt;- clean(cc175Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cc175Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\ncc175Obj &lt;- addElementToMetaDataset(cc175Obj, \"Num drop B group\", 0)\n\nB group contains high number of hemoglobin genes: so they are not interesting\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\ncc175Obj &lt;- dropGenesCells(cc175Obj, cells = cells_to_rem)\n\n\n\nClean: round 2\n\ncc175Obj &lt;- clean(cc175Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cc175Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\ncc175Obj &lt;- addElementToMetaDataset(cc175Obj, \"Num drop B group\", 1)\n\nVisualize if all is ok:\n\nplot(pcaCellsData)\n\n\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\nDrop very low UDE cells as they are likely outliers\n\nlowUDEThr &lt;- 0.2\ncc175Obj &lt;- addElementToMetaDataset(cc175Obj, \"Low UDE threshold\", lowUDEThr)\n\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(cc175Obj)), \"n\" = seq_along(getNu(cc175Obj)))\n\ncells_to_rem &lt;- rownames(nuDf)[nuDf[[\"nu\"]] &lt; lowUDEThr]\ncc175Obj &lt;- dropGenesCells(cc175Obj, cells = cells_to_rem)\n\nFinal cleaning to check all is OK\n\ncc175Obj &lt;- clean(cc175Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cc175Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(cellSizePlot(cc175Obj))\n\n\n\nplot(genesSizePlot(cc175Obj))\n\n\n\n\nCalculate genes’ COEX\n\ncc175Obj &lt;- proceedToCoex(cc175Obj, calcCoex = TRUE, cores = 12,\n                          saveObj = TRUE, outDir = outDir)"
  },
  {
    "objectID": "CorticalCells_GSM2861514_E175-analysis.html#gdi",
    "href": "CorticalCells_GSM2861514_E175-analysis.html#gdi",
    "title": "Cortical cells DGE E17.5 Data-set Anaysis",
    "section": "GDI",
    "text": "GDI\n\ngdiData &lt;- calculateGDI(cc175Obj)\n\ngenesToLabel &lt;- head(rownames(gdiData[order(gdiData[[\"GDI\"]],\n                                            decreasing = TRUE), ]), n = 10L)\n\ngenesToLabel\n\n [1] \"Ednrb\"   \"Mfge8\"   \"Aldoc\"   \"Sox2\"    \"Vim\"     \"Hes5\"    \"Neurod6\"\n [8] \"Tubb3\"   \"Ddah1\"   \"Atp1a2\" \n\ngdiPlot &lt;- GDIPlot(cc175Obj, GDIIn = gdiData, GDIThreshold = 1.4,\n                   genes = list(\"Top 10 GDI genes\" = genesToLabel))\n\nplot(gdiPlot)\n\n\n\n\nSave the COTAN object\n\nsaveRDS(cc175Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))"
  },
  {
    "objectID": "CorticalCells_GSM2861514_E175-analysis.html#consistent-transcript-cohorts-clustering",
    "href": "CorticalCells_GSM2861514_E175-analysis.html#consistent-transcript-cohorts-clustering",
    "title": "Cortical cells DGE E17.5 Data-set Anaysis",
    "section": "Consistent Transcript Cohorts (clustering)",
    "text": "Consistent Transcript Cohorts (clustering)\n\nc(splitClusters, splitCoexDF) %&lt;-%\n  cellsUniformClustering(cc175Obj, GDIThreshold = 1.4, cores = 13,\n                         saveObj = TRUE, outDir = outDir)\n\n\ncc175Obj &lt;- addClusterization(cc175Obj, clName = \"split\",\n                              clusters = splitClusters,\n                              coexDF = splitCoexDF, override = TRUE)\n\ntable(splitClusters)\n\n\nsaveRDS(cc175Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nc(mergedClusters, mergedCoexDF) %&lt;-%\n  mergeUniformCellsClusters(cc175Obj, clusters = splitClusters,\n                            GDIThreshold = 1.4, cores = 13,\n                            saveObj = TRUE, outDir = outDir)\n\ncc175Obj &lt;- addClusterization(cc175Obj, clName = \"merge\",\n                              clusters = mergedClusters,\n                              coexDF = mergedCoexDF,\n                              override = TRUE)\n\ntable(mergedClusters)\n\n\nsaveRDS(cc175Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\n\nSys.time()\n\n[1] \"2023-08-22 19:46:59 CEST\"\n\n\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.1.7   zeallot_0.1.0 tibble_3.2.1  ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.15.0      jsonlite_1.8.7        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.24        \n [10] GlobalOptions_0.1.2    vctrs_0.6.3            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-22    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.2          zoo_1.8-12             igraph_1.5.1          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.6-0           R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-11    future_1.33.0         \n [34] shiny_1.7.5            clue_0.3-64            digest_0.6.33         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.1      \n [40] Seurat_4.3.0.1         tensor_1.5             RSpectra_0.16-1       \n [43] irlba_2.3.5.1          labeling_0.4.2         progressr_0.14.0      \n [46] RcppZiggurat_0.1.6     fansi_1.0.4            spatstat.sparse_3.0-2 \n [49] httr_1.4.6             polyclip_1.10-4        abind_1.4-5           \n [52] compiler_4.3.1         withr_2.5.0            doParallel_1.0.17     \n [55] viridis_0.6.4          dendextend_1.17.1      MASS_7.3-60           \n [58] openssl_2.1.0          rjson_0.2.21           tools_4.3.1           \n [61] lmtest_0.9-40          httpuv_1.6.11          future.apply_1.11.0   \n [64] goftest_1.2-3          glue_1.6.2             nlme_3.1-162          \n [67] promises_1.2.0.1       grid_4.3.1             Rtsne_0.16            \n [70] cluster_2.1.4          reshape2_1.4.4         generics_0.1.3        \n [73] gtable_0.3.3           spatstat.data_3.0-1    tidyr_1.3.0           \n [76] data.table_1.14.8      sp_2.0-0               utf8_1.2.3            \n [79] BiocGenerics_0.46.0    spatstat.geom_3.2-4    RcppAnnoy_0.0.21      \n [82] ggrepel_0.9.3          RANN_2.6.1             foreach_1.5.2         \n [85] pillar_1.9.0           stringr_1.5.0          later_1.3.1           \n [88] circlize_0.4.15        splines_4.3.1          dplyr_1.1.2           \n [91] lattice_0.21-8         survival_3.5-5         deldir_1.0-9          \n [94] tidyselect_1.2.0       ComplexHeatmap_2.16.0  miniUI_0.1.1.1        \n [97] pbapply_1.7-2          knitr_1.43             gridExtra_2.3         \n[100] IRanges_2.34.1         scattermore_1.2        stats4_4.3.1          \n[103] xfun_0.39              factoextra_1.0.7       matrixStats_1.0.0     \n[106] stringi_1.7.12         lazyeval_0.2.2         yaml_2.3.7            \n[109] evaluate_0.21          codetools_0.2-19       cli_3.6.1             \n[112] RcppParallel_5.1.7     uwot_0.1.16            xtable_1.8-4          \n[115] reticulate_1.30        munsell_0.5.0          Rcpp_1.0.11           \n[118] globals_0.16.2         spatstat.random_3.1-5  png_0.1-8             \n[121] parallel_4.3.1         Rfast_2.0.8            ellipsis_0.3.2        \n[124] assertthat_0.2.1       parallelDist_0.2.6     listenv_0.9.0         \n[127] ggthemes_4.2.4         viridisLite_0.4.2      scales_1.2.1          \n[130] ggridges_0.5.4         SeuratObject_4.1.3     leiden_0.4.3          \n[133] purrr_1.0.1            crayon_1.5.2           GetoptLong_1.0.5      \n[136] rlang_1.1.1            cowplot_1.1.1"
  },
  {
    "objectID": "CorticalCells_GSM2861511_E135-analysis.html",
    "href": "CorticalCells_GSM2861511_E135-analysis.html",
    "title": "Cortical cells DGE E13.5 Data-set Anaysis",
    "section": "",
    "text": "library(ggplot2)\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"Data/Yuzwa_MouseCortex/\"\n\nsetLoggingLevel(1)\nsetLoggingFile(file.path(outDir, \"CorticalCells_GSM2861511_E135-analysis.log\"))\nRead the dataset from file\ndataset &lt;- read.csv(file.path(\"Data/Yuzwa_MouseCortex/\", \"GSM2861511_E135_Only_Cortical_Cells_DGE.txt.gz\"),\n                    header = TRUE, sep = \"\\t\", strip.white = TRUE,\n                    row.names = 1)"
  },
  {
    "objectID": "CorticalCells_GSM2861511_E135-analysis.html#cleaning",
    "href": "CorticalCells_GSM2861511_E135-analysis.html#cleaning",
    "title": "Cortical cells DGE E13.5 Data-set Anaysis",
    "section": "Cleaning",
    "text": "Cleaning\nCrate the COTAN object\n\nsampleCondition &lt;- \"CorticalCells_GSM2861511_E135\"\ncc135Obj &lt;- COTAN(raw = dataset)\ncc135Obj &lt;- initializeMetaDataset(cc135Obj,\n                                  GEO = \"GSM2861511_E135\",\n                                  sequencingMethod = \"Drop_seq\",\n                                  sampleCondition = sampleCondition)\n\nInspect cells’ sizes\n\ncellSizePlot(cc135Obj)\n\n\n\n\nDrop cells with too many ritz reads as they are probably duplets\n\ncellsSizeThr &lt;- 8000\ncc135Obj &lt;- addElementToMetaDataset(cc135Obj, \"Cells size threshold\", cellsSizeThr)\n\ncells_to_rem &lt;- getCells(cc135Obj)[getCellsSize(cc135Obj) &gt; cellsSizeThr]\ncc135Obj &lt;- dropGenesCells(cc135Obj, cells = cells_to_rem)\n\ncellSizePlot(cc135Obj)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(cc135Obj)\n\n\n\n\nDrop cells with too high genes expession as they are probably duplets\n\ngenesSizeThr &lt;- 3300\ncc135Obj &lt;- addElementToMetaDataset(cc135Obj, \"Num genes threshold\", genesSizeThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(cc135Obj)\ncells_to_rem &lt;- names(numExprGenes)[numExprGenes &gt; genesSizeThr]\ncc135Obj &lt;- dropGenesCells(cc135Obj, cells = cells_to_rem)\n\ngenesSizePlot(cc135Obj)\n\n\n\n\nCheck number of mitocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^mt-\"\ngetGenes(cc135Obj)[grep(mitGenesPattern, getGenes(cc135Obj))]\n\n [1] \"mt-Co1\"  \"mt-Co3\"  \"mt-Cytb\" \"mt-Nd1\"  \"mt-Nd2\"  \"mt-Nd4\"  \"mt-Nd5\" \n [8] \"mt-Nd6\"  \"mt-Rnr1\" \"mt-Rnr2\" \"mt-Ta\"   \"mt-Tc\"   \"mt-Te\"   \"mt-Tf\"  \n[15] \"mt-Ti\"   \"mt-Tl1\"  \"mt-Tl2\"  \"mt-Tm\"   \"mt-Tn\"   \"mt-Tp\"   \"mt-Tq\"  \n[22] \"mt-Ts2\"  \"mt-Tt\"   \"mt-Tv\"   \"mt-Tw\"  \n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(cc135Obj, genePrefix = mitGenesPattern)\n\nplot(mitPlot)\n\n\n\n\nCells with a too high percentage of mitocondrial genes are likely dead (or at the last problematic) cells. So we drop them!\n\nmitPercThr &lt;- 10.0\ncc135Obj &lt;- addElementToMetaDataset(cc135Obj, \"Mitoc. perc. threshold\", mitPercThr)\n\ncells_to_rem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\ncc135Obj &lt;- dropGenesCells(cc135Obj, cells = cells_to_rem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(cc135Obj, genePrefix = mitGenesPattern)\n\nplot(mitPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(cc135Obj)\n\n\n\ngenesSizePlot(cc135Obj)\n\n\n\n\n\nClean: round 1\n\ncc135Obj &lt;- clean(cc135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cc135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\n\nB group contains high number of hemoglobin genes: so they are not interesting\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\ncc135Obj &lt;- dropGenesCells(cc135Obj, cells = cells_to_rem)\n\n\n\nClean: round 2\n\ncc135Obj &lt;- clean(cc135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cc135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(pcaCellsData)\n\n\n\nplot(genesPlot)\n\n\n\n\nB group contains just 3 cells quite different in the 3rd and 4th components: better to drop them\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\ncc135Obj &lt;- dropGenesCells(cc135Obj, cells = cells_to_rem)\n\n\n\nClean: round 3\n\ncc135Obj &lt;- clean(cc135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cc135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\ncc135Obj &lt;- addElementToMetaDataset(cc135Obj, \"Num drop B group\", 2)\n\nVisualize if all is ok:\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\nDrop very low UDE cells as they are likely outliers\n\nlowUDEThr &lt;- 0.14 # the threshold to remove low UDE cells\n\ncc135Obj &lt;- addElementToMetaDataset(cc135Obj, \"Low UDE threshold\", lowUDEThr)\n\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(cc135Obj)), \"n\" = seq_along(getNu(cc135Obj)))\n\n\ncells_to_rem &lt;- rownames(nuDf)[nuDf[[\"nu\"]] &lt; lowUDEThr]\ncc135Obj &lt;- dropGenesCells(cc135Obj, cells = cells_to_rem)\n\nFinal cleaning to check all is OK\n\ncc135Obj &lt;- clean(cc135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cc135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(zoomedNuPlot)\n\n\n\nplot(cellSizePlot(cc135Obj))\n\n\n\nplot(genesSizePlot(cc135Obj))\n\n\n\n\n\ncc135Obj &lt;- proceedToCoex(cc135Obj, calcCoex = TRUE, cores = 12,\n                          saveObj = TRUE, outDir = outDir)\n\nSave the COTAN object\n\nsaveRDS(cc135Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))"
  },
  {
    "objectID": "CorticalCells_GSM2861511_E135-analysis.html#gdi",
    "href": "CorticalCells_GSM2861511_E135-analysis.html#gdi",
    "title": "Cortical cells DGE E13.5 Data-set Anaysis",
    "section": "GDI",
    "text": "GDI\n\ngdiData &lt;- calculateGDI(cc135Obj)\n\ngenesToLabel &lt;- head(rownames(gdiData[order(gdiData[[\"GDI\"]],\n                                            decreasing = TRUE), ]), n = 10L)\n\ngenesToLabel\n\n [1] \"Neurod6\"       \"2610017I09Rik\" \"Nr2e1\"         \"Ina\"          \n [5] \"Sox2\"          \"Stmn2\"         \"Mdk\"           \"Mapt\"         \n [9] \"Gas1\"          \"2810417H13Rik\"\n\ngdiPlot &lt;- GDIPlot(cc135Obj, GDIIn = gdiData, GDIThreshold = 1.4,\n                   genes = list(\"Top 10 GDI genes\" = genesToLabel))\n\nplot(gdiPlot)"
  },
  {
    "objectID": "CorticalCells_GSM2861511_E135-analysis.html#consistent-transcript-cohorts",
    "href": "CorticalCells_GSM2861511_E135-analysis.html#consistent-transcript-cohorts",
    "title": "Cortical cells DGE E13.5 Data-set Anaysis",
    "section": "Consistent Transcript Cohorts",
    "text": "Consistent Transcript Cohorts\n\nc(splitClusters, splitCoexDF) %&lt;-% \n  cellsUniformClustering(cc135Obj, GDIThreshold = 1.4, cores = 13,\n                         saveObj = TRUE, outDir = outDir)\n\n\ncc135Obj &lt;- addClusterization(cc135Obj, clName = \"split\",\n                              clusters = splitClusters,\n                              coexDF = splitCoexDF, override = TRUE)\n\n\ntable(splitClusters)\n\nsplitClusters\n -1  01  02  03  04  05  06  07  08  09  10  11  12  13  14 \n  6  94 106  47  69 127  92  11  25  12  41 113  59 161 149 \n\n\n\nsaveRDS(cc135Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nc(mergedClusters, mergedCoexDF) %&lt;-%\n  mergeUniformCellsClusters(cc135Obj, clusters = splitClusters,\n                            GDIThreshold = 1.4, cores = 13,\n                            saveObj = TRUE, outDir = outDir)\n\ncc135Obj &lt;- addClusterization(cc135Obj, clName = \"merge\",\n                              clusters = mergedClusters,\n                              coexDF = mergedCoexDF,\n                              override = TRUE)\n\n\ntable(mergedClusters)\n\nmergedClusters\n  1   2   3   4   5   6   7   8   9 \n 94 153 161 127 113 102  52 161 149 \n\n\n\nsaveRDS(cc135Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\n\nSys.time()\n\n[1] \"2023-08-22 17:55:23 CEST\"\n\n\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.1.7   zeallot_0.1.0 tibble_3.2.1  ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.15.0      jsonlite_1.8.7        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.24        \n [10] GlobalOptions_0.1.2    vctrs_0.6.3            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-22    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.2          zoo_1.8-12             igraph_1.5.1          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.6-0           R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-11    future_1.33.0         \n [34] shiny_1.7.5            clue_0.3-64            digest_0.6.33         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.1      \n [40] Seurat_4.3.0.1         tensor_1.5             RSpectra_0.16-1       \n [43] irlba_2.3.5.1          labeling_0.4.2         progressr_0.14.0      \n [46] RcppZiggurat_0.1.6     fansi_1.0.4            spatstat.sparse_3.0-2 \n [49] httr_1.4.6             polyclip_1.10-4        abind_1.4-5           \n [52] compiler_4.3.1         withr_2.5.0            doParallel_1.0.17     \n [55] viridis_0.6.4          dendextend_1.17.1      MASS_7.3-60           \n [58] openssl_2.1.0          rjson_0.2.21           tools_4.3.1           \n [61] lmtest_0.9-40          httpuv_1.6.11          future.apply_1.11.0   \n [64] goftest_1.2-3          glue_1.6.2             nlme_3.1-162          \n [67] promises_1.2.0.1       grid_4.3.1             Rtsne_0.16            \n [70] cluster_2.1.4          reshape2_1.4.4         generics_0.1.3        \n [73] gtable_0.3.3           spatstat.data_3.0-1    tidyr_1.3.0           \n [76] data.table_1.14.8      sp_2.0-0               utf8_1.2.3            \n [79] BiocGenerics_0.46.0    spatstat.geom_3.2-4    RcppAnnoy_0.0.21      \n [82] ggrepel_0.9.3          RANN_2.6.1             foreach_1.5.2         \n [85] pillar_1.9.0           stringr_1.5.0          later_1.3.1           \n [88] circlize_0.4.15        splines_4.3.1          dplyr_1.1.2           \n [91] lattice_0.21-8         survival_3.5-5         deldir_1.0-9          \n [94] tidyselect_1.2.0       ComplexHeatmap_2.16.0  miniUI_0.1.1.1        \n [97] pbapply_1.7-2          knitr_1.43             gridExtra_2.3         \n[100] IRanges_2.34.1         scattermore_1.2        stats4_4.3.1          \n[103] xfun_0.39              factoextra_1.0.7       matrixStats_1.0.0     \n[106] stringi_1.7.12         lazyeval_0.2.2         yaml_2.3.7            \n[109] evaluate_0.21          codetools_0.2-19       cli_3.6.1             \n[112] RcppParallel_5.1.7     uwot_0.1.16            xtable_1.8-4          \n[115] reticulate_1.30        munsell_0.5.0          Rcpp_1.0.11           \n[118] globals_0.16.2         spatstat.random_3.1-5  png_0.1-8             \n[121] parallel_4.3.1         Rfast_2.0.8            ellipsis_0.3.2        \n[124] assertthat_0.2.1       parallelDist_0.2.6     listenv_0.9.0         \n[127] ggthemes_4.2.4         viridisLite_0.4.2      scales_1.2.1          \n[130] ggridges_0.5.4         SeuratObject_4.1.3     leiden_0.4.3          \n[133] purrr_1.0.1            crayon_1.5.2           GetoptLong_1.0.5      \n[136] rlang_1.1.1            cowplot_1.1.1"
  },
  {
    "objectID": "DEA_Seurat_COTAN.html",
    "href": "DEA_Seurat_COTAN.html",
    "title": "DEA comparison Seurat - Cotan",
    "section": "",
    "text": "library(ggplot2)\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\nlibrary(plyr)\nlibrary(scales) \nlibrary(rlang)\nlibrary(Seurat)\nlibrary(wordcloud)\nlibrary(stringr)\nlibrary(assertr)\nlibrary(ggVennDiagram)\nlibrary(ggplot2)\nlibrary(tidyr)\n\nlibrary(enrichR)\n\nwebsiteLive &lt;- getOption(\"enrichR.live\")\nif (websiteLive) dbs &lt;- listEnrichrDbs()\nhead(dbs)\n\n  geneCoverage genesPerTerm                      libraryName\n1        13362          275              Genome_Browser_PWMs\n2        27884         1284         TRANSFAC_and_JASPAR_PWMs\n3         6002           77        Transcription_Factor_PPIs\n4        47172         1370                        ChEA_2013\n5        47107          509 Drug_Perturbations_from_GEO_2014\n6        21493         3713          ENCODE_TF_ChIP-seq_2014\n                                                      link numTerms\n1 http://hgdownload.cse.ucsc.edu/goldenPath/hg18/database/      615\n2                 http://jaspar.genereg.net/html/DOWNLOAD/      326\n3                                                               290\n4           http://amp.pharm.mssm.edu/lib/cheadownload.jsp      353\n5                         http://www.ncbi.nlm.nih.gov/geo/      701\n6             http://genome.ucsc.edu/ENCODE/downloads.html      498\n                                   appyter categoryId\n1 ea115789fcbf12797fd692cec6df0ab4dbc79c6a          1\n2 7d42eb43a64a4e3b20d721fc7148f685b53b6b30          1\n3 849f222220618e2599d925b6b51868cf1dab3763          1\n4 7ebe772afb55b63b41b79dd8d06ea0fdd9fa2630          7\n5 ad270a6876534b7cb063e004289dcd4d3164f342          7\n6 497787ebc418d308045efb63b8586f10c526af51          7\n\n#dbs &lt;- \"Tabula_Muris\"\ndbs &lt;- \"ARCHS4_Tissues\"\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"./e15.0_FD_CheckClustersUniformity\"\n\nsetLoggingLevel(1)\nsetLoggingFile(file.path(outDir, \"FindUniformGivenClustersInForebrainDorsal_E150.log\"))\nfb150ObjRaw &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/SourceData/\", \"e15.0_ForebrainDorsal.cotan.RDS\"))\n\nfb150Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e15.0_ForebrainDorsal.cotan.RDS\"))\nAlign to cleaned cells’ list\nmetaC &lt;- getMetadataCells(fb150ObjRaw)[getCells(fb150Obj), ]\n\n#metaCDrop &lt;- getMetadataCells(fb150ObjRaw)[!getCells(fb150ObjRaw) %in% getCells(fb150Obj), ]\nExtract the cells of class ‘Neuron’\nmetaNeuron &lt;- metaC[metaC[[\"Class\"]] == \"Neuron\", ]\n\nsort(table(metaNeuron[[\"Subclass\"]]), decreasing = TRUE)\n\n\nCortical or hippocampal glutamatergic                   Forebrain GABAergic \n                                 3969                                   610 \n                        Cajal-Retzius                Mixed region GABAergic \n                                  145                                    21 \n                            Undefined               Forebrain glutamatergic \n                                   16                                    15 \n                         Hypothalamus            Mixed region glutamatergic \n                                    8                                     5 \n    Mixed region and neurotransmitter               Hindbrain glutamatergic \n                                    4                                     2 \n                Hindbrain glycinergic            Hypothalamus glutamatergic \n                                    2                                     2 \n        Dorsal midbrain glutamatergic                          Mixed region \n                                    1                                     1 \n\nsort(table(metaNeuron[[\"ClusterName\"]]), decreasing = TRUE)\n\n\nNeur525 Neur511 Neur509 Neur510 Neur508 Neur507 Neur568 Neur504 Neur505 Neur516 \n    826     540     402     402     397     183     181     174     147     137 \nNeur565 Neur524 Neur679 Neur493 Neur498 Neur497 Neur506 Neur502 Neur494 Neur574 \n    133     108     105      93      79      51      46      42      41      41 \nNeur575 Neur492 Neur519 Neur526 Neur566 Neur501 Neur573 Neur499 Neur518 Neur560 \n     41      38      31      28      28      24      24      23      22      20 \nNeur514 Neur523 Neur569 Neur557 Neur495 Neur520 Neur535 Neur542 Neur677 Neur527 \n     19      19      18      16      15      15      14      14      14      13 \nNeur496 Neur512 Neur676 Neur517 Neur558 Neur503 Neur739 Neur559 Neur564 Neur538 \n     11      11      11      10       9       8       8       7       7       6 \nNeur549 Neur561 Neur671 Neur695 Neur738 Neur747 Neur500 Neur536 Neur678 Neur534 \n      6       6       6       6       6       6       5       5       5       4 \nNeur550 Neur570 Neur686 Neur731 Neur737 Neur513 Neur515 Neur528 Neur533 Neur539 \n      4       4       4       4       4       3       3       3       3       3 \nNeur544 Neur571 Neur674 Neur675 Neur732 Neur531 Neur543 Neur548 Neur552 Neur554 \n      3       3       3       3       3       2       2       2       2       2 \nNeur562 Neur670 Neur689 Neur740 Neur529 Neur530 Neur532 Neur537 Neur540 Neur553 \n      2       2       2       2       1       1       1       1       1       1 \nNeur567 Neur572 Neur601 Neur614 Neur634 Neur647 Neur649 Neur672 Neur680 Neur681 \n      1       1       1       1       1       1       1       1       1       1 \nNeur684 Neur693 Neur696 Neur726 Neur734 Neur749 Neur750 Neur751 Neur760 Neur771 \n      1       1       1       1       1       1       1       1       1       1\ncl.to.keep &lt;- names(table(metaNeuron[[\"ClusterName\"]])[table(metaNeuron[[\"ClusterName\"]]) &gt;= 20L])\n\nmeta.to.keep &lt;- metaNeuron[metaNeuron$ClusterName %in% cl.to.keep,]\ndim(meta.to.keep)\n\n[1] 4407   41\n\ndim(metaNeuron)\n\n[1] 4801   41\nDropped cell\ndim(metaNeuron)[1] - dim(meta.to.keep)[1]\n\n[1] 394\nRemoving cells\ncell.to.drop &lt;- getCells(fb150Obj)[!getCells(fb150Obj) %in% rownames(meta.to.keep)]\n\nfb150Obj &lt;- dropGenesCells(fb150Obj,cells = cell.to.drop)\n\ndim(meta.to.keep)[1] == dim(getRawData(fb150Obj))[2]\n\n[1] TRUE\n\nmetaC &lt;- getMetadataCells(fb150ObjRaw)[getCells(fb150Obj), ]\nfb150Obj &lt;- clean(fb150Obj)\nfb150Obj &lt;- estimateDispersionBisection(fb150Obj)\n\nidentical(rownames(fb150Obj@metaCells), rownames(metaC))\n\n[1] TRUE\n\nfb150Obj@metaCells &lt;- cbind(fb150Obj@metaCells,metaC)\n\nfb150Obj@metaCells[1:10,]\n\n                            feCells        nu feCells        nu   Age\n10X74_4_A_1:TGGTAGACCCTACCx   FALSE 0.9375770   FALSE 0.9214807 e15.0\n10X73_3_A_1:TACCGGCTTCAGTGx   FALSE 0.7855991   FALSE 0.7722440 e15.0\n10X74_4_A_1:CCCAGTTGGAGGTGx   FALSE 0.6983103   FALSE 0.6863260 e15.0\n10X73_3_A_1:AATTGATGAGAATGx   FALSE 1.1751850   FALSE 1.1548031 e15.0\n10X74_4_A_1:TAGTGGTGAGTAGAx   FALSE 1.1001290   FALSE 1.0808973 e15.0\n10X74_4_A_1:ATTATGGACTACGAx   FALSE 1.3074658   FALSE 1.2844945 e15.0\n10X64_3_A_1:TGTATCTGCCTTATx   FALSE 1.4138296   FALSE 1.3891434 e15.0\n10X64_3_A_1:TAGTATGACTATGGx   FALSE 1.6528889   FALSE 1.6249089 e15.0\n10X73_3_A_1:ACTTGGGATTGCAGx   FALSE 0.7482785   FALSE 0.7355965 e15.0\n10X74_4_A_1:AGCTCGCTCCATGAx   FALSE 1.1109106   FALSE 1.0914844 e15.0\n                                       CellCycle                      CellID\n10X74_4_A_1:TGGTAGACCCTACCx  0.00308982564555286 10X74_4_A_1:TGGTAGACCCTACCx\n10X73_3_A_1:TACCGGCTTCAGTGx 0.000789058390320884 10X73_3_A_1:TACCGGCTTCAGTGx\n10X74_4_A_1:CCCAGTTGGAGGTGx  0.00177988727380599 10X74_4_A_1:CCCAGTTGGAGGTGx\n10X73_3_A_1:AATTGATGAGAATGx 0.000880436696601514 10X73_3_A_1:AATTGATGAGAATGx\n10X74_4_A_1:TAGTGGTGAGTAGAx 0.000752021056589585 10X74_4_A_1:TAGTGGTGAGTAGAx\n10X74_4_A_1:ATTATGGACTACGAx  0.00174133291119202 10X74_4_A_1:ATTATGGACTACGAx\n10X64_3_A_1:TGTATCTGCCTTATx 0.000878348704435661 10X64_3_A_1:TGTATCTGCCTTATx\n10X64_3_A_1:TAGTATGACTATGGx  0.00125156445556946 10X64_3_A_1:TAGTATGACTATGGx\n10X73_3_A_1:ACTTGGGATTGCAGx  0.00221177771633951 10X73_3_A_1:ACTTGGGATTGCAGx\n10X74_4_A_1:AGCTCGCTCCATGAx  0.00111835973904939 10X74_4_A_1:AGCTCGCTCCATGAx\n                            Cell_Conc Chemistry ChipID  Class ClusterName\n10X74_4_A_1:TGGTAGACCCTACCx       600        v2  10X74 Neuron     Neur492\n10X73_3_A_1:TACCGGCTTCAGTGx       600        v2  10X73 Neuron     Neur492\n10X74_4_A_1:CCCAGTTGGAGGTGx       600        v2  10X74 Neuron     Neur492\n10X73_3_A_1:AATTGATGAGAATGx       600        v2  10X73 Neuron     Neur492\n10X74_4_A_1:TAGTGGTGAGTAGAx       600        v2  10X74 Neuron     Neur492\n10X74_4_A_1:ATTATGGACTACGAx       600        v2  10X74 Neuron     Neur492\n10X64_3_A_1:TGTATCTGCCTTATx       600        v2  10X64 Neuron     Neur492\n10X64_3_A_1:TAGTATGACTATGGx       600        v2  10X64 Neuron     Neur492\n10X73_3_A_1:ACTTGGGATTGCAGx       600        v2  10X73 Neuron     Neur492\n10X74_4_A_1:AGCTCGCTCCATGAx       600        v2  10X74 Neuron     Neur492\n                            Clusters Date_Captured    DonorID\n10X74_4_A_1:TGGTAGACCCTACCx      492    2016-11-30 Batch14K-2\n10X73_3_A_1:TACCGGCTTCAGTGx      492    2016-11-30 Batch14K-2\n10X74_4_A_1:CCCAGTTGGAGGTGx      492    2016-11-30 Batch14K-2\n10X73_3_A_1:AATTGATGAGAATGx      492    2016-11-30 Batch14K-2\n10X74_4_A_1:TAGTGGTGAGTAGAx      492    2016-11-30 Batch14K-2\n10X74_4_A_1:ATTATGGACTACGAx      492    2016-11-30 Batch14K-2\n10X64_3_A_1:TGTATCTGCCTTATx      492    2016-11-15 Batch11H-5\n10X64_3_A_1:TAGTATGACTATGGx      492    2016-11-15 Batch11H-5\n10X73_3_A_1:ACTTGGGATTGCAGx      492    2016-11-30 Batch14K-2\n10X74_4_A_1:AGCTCGCTCCATGAx      492    2016-11-30 Batch14K-2\n                              DoubletFinderPCA         HPF_LogPP IsCycling\n10X74_4_A_1:TGGTAGACCCTACCx                  0 -881923.697556259         0\n10X73_3_A_1:TACCGGCTTCAGTGx                  0 -621646.228431766         0\n10X74_4_A_1:CCCAGTTGGAGGTGx 0.0303030303030303 -615788.630071891         0\n10X73_3_A_1:AATTGATGAGAATGx  0.027027027027027 -1043580.43446046         0\n10X74_4_A_1:TAGTGGTGAGTAGAx 0.0606060606060606 -892588.390822332         0\n10X74_4_A_1:ATTATGGACTACGAx 0.0606060606060606 -1057464.46525045         0\n10X64_3_A_1:TGTATCTGCCTTATx 0.0588235294117647 -1259381.55581998         0\n10X64_3_A_1:TAGTATGACTATGGx  0.147058823529412 -1384562.64613975         0\n10X73_3_A_1:ACTTGGGATTGCAGx  0.027027027027027 -766332.582748427         0\n10X74_4_A_1:AGCTCGCTCCATGAx                  0 -760899.629760664         0\n                            Label Location_E9_E11 NCellsCluster NGenes\n10X74_4_A_1:TGGTAGACCCTACCx  G119             nan           457   2402\n10X73_3_A_1:TACCGGCTTCAGTGx  G115             nan           457   2034\n10X74_4_A_1:CCCAGTTGGAGGTGx  G119             nan           457   1915\n10X73_3_A_1:AATTGATGAGAATGx  G115             nan           457   2555\n10X74_4_A_1:TAGTGGTGAGTAGAx  G119             nan           457   2448\n10X74_4_A_1:ATTATGGACTACGAx  G119             nan           457   2785\n10X64_3_A_1:TGTATCTGCCTTATx   G94             nan           457   2842\n10X64_3_A_1:TAGTATGACTATGGx   G94             nan           457   3160\n10X73_3_A_1:ACTTGGGATTGCAGx  G115             nan           457   2033\n10X74_4_A_1:AGCTCGCTCCATGAx  G119             nan           457   2469\n                            Num_Pooled_Animals PCR_Cycles  Plug_Date Project\n10X74_4_A_1:TGGTAGACCCTACCx                  3         13 2016-11-15     Dev\n10X73_3_A_1:TACCGGCTTCAGTGx                  3         13 2016-11-15     Dev\n10X74_4_A_1:CCCAGTTGGAGGTGx                  3         13 2016-11-15     Dev\n10X73_3_A_1:AATTGATGAGAATGx                  3         13 2016-11-15     Dev\n10X74_4_A_1:TAGTGGTGAGTAGAx                  3         13 2016-11-15     Dev\n10X74_4_A_1:ATTATGGACTACGAx                  3         13 2016-11-15     Dev\n10X64_3_A_1:TGTATCTGCCTTATx                  3         13 2016-10-31     Dev\n10X64_3_A_1:TAGTATGACTATGGx                  3         13 2016-10-31     Dev\n10X73_3_A_1:ACTTGGGATTGCAGx                  3         13 2016-11-15     Dev\n10X74_4_A_1:AGCTCGCTCCATGAx                  3         13 2016-11-15     Dev\n                            PseudoAge     PseudoTissue    Region SampleID\n10X74_4_A_1:TGGTAGACCCTACCx    15.905  ForebrainDorsal Forebrain  10X74_4\n10X73_3_A_1:TACCGGCTTCAGTGx    13.155  ForebrainDorsal Forebrain  10X73_3\n10X74_4_A_1:CCCAGTTGGAGGTGx    13.935  ForebrainDorsal Forebrain  10X74_4\n10X73_3_A_1:AATTGATGAGAATGx     15.54  ForebrainDorsal Forebrain  10X73_3\n10X74_4_A_1:TAGTGGTGAGTAGAx    14.595  ForebrainDorsal Forebrain  10X74_4\n10X74_4_A_1:ATTATGGACTACGAx   14.3725  ForebrainDorsal Forebrain  10X74_4\n10X64_3_A_1:TGTATCTGCCTTATx   15.1275  ForebrainDorsal Forebrain  10X64_3\n10X64_3_A_1:TAGTATGACTATGGx    16.225  ForebrainDorsal Forebrain  10X64_3\n10X73_3_A_1:ACTTGGGATTGCAGx   12.8175 ForebrainVentral Forebrain  10X73_3\n10X74_4_A_1:AGCTCGCTCCATGAx   14.7975  ForebrainDorsal Forebrain  10X74_4\n                            SampleName Sample_Index Sex Species Split Strain\n10X74_4_A_1:TGGTAGACCCTACCx       G119     SI-3A-E7   ?      Mm     0   CD-1\n10X73_3_A_1:TACCGGCTTCAGTGx       G115     SI-3A-A7   ?      Mm     0   CD-1\n10X74_4_A_1:CCCAGTTGGAGGTGx       G119     SI-3A-E7   ?      Mm     0   CD-1\n10X73_3_A_1:AATTGATGAGAATGx       G115     SI-3A-A7   ?      Mm     0   CD-1\n10X74_4_A_1:TAGTGGTGAGTAGAx       G119     SI-3A-E7   ?      Mm     0   CD-1\n10X74_4_A_1:ATTATGGACTACGAx       G119     SI-3A-E7   ?      Mm     0   CD-1\n10X64_3_A_1:TGTATCTGCCTTATx        G94     SI-3A-H3   ?      Mm     0   CD-1\n10X64_3_A_1:TAGTATGACTATGGx        G94     SI-3A-H3   ?      Mm     0   CD-1\n10X73_3_A_1:ACTTGGGATTGCAGx       G115     SI-3A-A7   ?      Mm     0   CD-1\n10X74_4_A_1:AGCTCGCTCCATGAx       G119     SI-3A-E7   ?      Mm     0   CD-1\n                                                         Subclass\n10X74_4_A_1:TGGTAGACCCTACCx Cortical or hippocampal glutamatergic\n10X73_3_A_1:TACCGGCTTCAGTGx Cortical or hippocampal glutamatergic\n10X74_4_A_1:CCCAGTTGGAGGTGx Cortical or hippocampal glutamatergic\n10X73_3_A_1:AATTGATGAGAATGx Cortical or hippocampal glutamatergic\n10X74_4_A_1:TAGTGGTGAGTAGAx Cortical or hippocampal glutamatergic\n10X74_4_A_1:ATTATGGACTACGAx Cortical or hippocampal glutamatergic\n10X64_3_A_1:TGTATCTGCCTTATx Cortical or hippocampal glutamatergic\n10X64_3_A_1:TAGTATGACTATGGx Cortical or hippocampal glutamatergic\n10X73_3_A_1:ACTTGGGATTGCAGx Cortical or hippocampal glutamatergic\n10X74_4_A_1:AGCTCGCTCCATGAx Cortical or hippocampal glutamatergic\n                            Target_Num_Cells          Tissue TotalUMI\n10X74_4_A_1:TGGTAGACCCTACCx             3500 ForebrainDorsal     4531\n10X73_3_A_1:TACCGGCTTCAGTGx             3500 ForebrainDorsal     3802\n10X74_4_A_1:CCCAGTTGGAGGTGx             3500 ForebrainDorsal     3371\n10X73_3_A_1:AATTGATGAGAATGx             3500 ForebrainDorsal     5679\n10X74_4_A_1:TAGTGGTGAGTAGAx             3500 ForebrainDorsal     5319\n10X74_4_A_1:ATTATGGACTACGAx             3500 ForebrainDorsal     6317\n10X64_3_A_1:TGTATCTGCCTTATx             3500 ForebrainDorsal     6831\n10X64_3_A_1:TAGTATGACTATGGx             3500 ForebrainDorsal     7990\n10X73_3_A_1:ACTTGGGATTGCAGx             3500 ForebrainDorsal     3617\n10X74_4_A_1:AGCTCGCTCCATGAx             3500 ForebrainDorsal     5365\n                            Transcriptome cDNA_Lib_Ok ngperul_cDNA\n10X74_4_A_1:TGGTAGACCCTACCx          mm10           Y          3,1\n10X73_3_A_1:TACCGGCTTCAGTGx          mm10           Y          3,4\n10X74_4_A_1:CCCAGTTGGAGGTGx          mm10           Y          3,1\n10X73_3_A_1:AATTGATGAGAATGx          mm10           Y          3,4\n10X74_4_A_1:TAGTGGTGAGTAGAx          mm10           Y          3,1\n10X74_4_A_1:ATTATGGACTACGAx          mm10           Y          3,1\n10X64_3_A_1:TGTATCTGCCTTATx          mm10           Y          3,5\n10X64_3_A_1:TAGTATGACTATGGx          mm10           Y          3,5\n10X73_3_A_1:ACTTGGGATTGCAGx          mm10           Y          3,4\n10X74_4_A_1:AGCTCGCTCCATGAx          mm10           Y          3,1"
  },
  {
    "objectID": "DEA_Seurat_COTAN.html#cotan-differential-expression",
    "href": "DEA_Seurat_COTAN.html#cotan-differential-expression",
    "title": "DEA comparison Seurat - Cotan",
    "section": "Cotan differential expression",
    "text": "Cotan differential expression\nDEA on Subclass groups formed by just three cell types: Cortical or hippocampal glutamatergic, Forebrain GABAergic and Cajal-Retzius.\n\nclusters.cells &lt;- set_names(fb150Obj@metaCells$Subclass,nm = rownames(fb150Obj@metaCells))\ndea.Subclass &lt;- DEAOnClusters(fb150Obj,clusters = clusters.cells)\n\nhead(dea.Subclass$coex)\n\n       Cajal-Retzius Cortical or hippocampal glutamatergic Forebrain GABAergic\nLamc1   -0.026166913                          -0.003964787          0.02109719\nLama1   -0.021046008                          -0.059311990          0.08266931\nHs3st1   0.009828396                           0.072980864         -0.08910190\nFabp3   -0.090809976                           0.106706770         -0.06883822\nNrg2    -0.001594555                          -0.025294811          0.03037227\nBend4    0.009762501                          -0.192484391          0.21811993\n\n\nDEA on ClusterName: [1] “Neur492” “Neur493” “Neur494” “Neur497” “Neur498” “Neur499” “Neur501” “Neur502” “Neur504” [10] “Neur505” “Neur506” “Neur507” “Neur508” “Neur509” “Neur510” “Neur511” “Neur516” “Neur518” [19] “Neur519” “Neur524” “Neur525” “Neur526” “Neur560” “Neur565” “Neur566” “Neur568” “Neur573” [28] “Neur574” “Neur575” “Neur679”\n30 different cell groups.\n\nclusters.cells &lt;- set_names(fb150Obj@metaCells$ClusterName,nm = rownames(fb150Obj@metaCells))\ndea.ClusterName &lt;- DEAOnClusters(fb150Obj,clusters = clusters.cells)\n\nhead(dea.ClusterName$coex)\n\n            Neur492       Neur493      Neur494      Neur497      Neur498\nLamc1  -0.015142482  0.0052112095 -0.007566741  0.026741619  0.010599224\nLama1  -0.009632159 -0.0002343889 -0.010660671 -0.011372217 -0.004549478\nHs3st1  0.017614822 -0.0670123869  0.031852014 -0.033595679 -0.051990356\nFabp3  -0.013876113  0.0978372006  0.033870283 -0.018363993 -0.001097806\nNrg2   -0.005434727  0.0035304650  0.005300480 -0.008163350 -0.009236954\nBend4  -0.006635644 -0.0051243739 -0.007347493 -0.007827941 -0.014149243\n            Neur499      Neur501      Neur502     Neur504      Neur505\nLamc1  -0.002987865  0.010825673 -0.020364010 -0.01240859 -0.008362820\nLama1  -0.004586508 -0.004627726  0.008897717 -0.02182153  0.013489025\nHs3st1 -0.028752186  0.116297848  0.039591917  0.09582077  0.080567467\nFabp3  -0.001637069 -0.017191649 -0.010664235 -0.06640263 -0.046594627\nNrg2   -0.010451945  0.004869471  0.015748204 -0.02610886 -0.001227308\nBend4   0.027951286  0.012358515 -0.004432487 -0.01802341 -0.003364840\n             Neur506      Neur507      Neur508      Neur509      Neur510\nLamc1  -0.0137768308  0.013438810  0.003655012  0.015332401 -0.022982461\nLama1   0.0473493936 -0.001843277 -0.020074771 -0.004309732 -0.022499414\nHs3st1  0.0009883989 -0.044753051 -0.005629901  0.113439645 -0.017375581\nFabp3   0.0495867141 -0.030231847 -0.043623601 -0.077834754  0.043983043\nNrg2   -0.0005773858 -0.024882460 -0.051351834 -0.033940039 -0.006889284\nBend4  -0.0096820697 -0.023076428 -0.024799514 -0.026800103 -0.023813556\n            Neur511      Neur516      Neur518      Neur519      Neur524\nLamc1  -0.006029846  0.029054227 -0.001584281 -0.023778455  0.010622135\nLama1  -0.007894555 -0.022458902 -0.008383886 -0.008774730 -0.008985542\nHs3st1  0.026348751  0.015910202 -0.022958194 -0.011012483 -0.026955014\nFabp3   0.025743620 -0.017541959  0.038232083  0.016478606  0.086814711\nNrg2   -0.041561278  0.008453141 -0.002869805  0.037131271  0.077391246\nBend4  -0.032179960  0.006955173 -0.005798012 -0.006054586  0.010811234\n            Neur525       Neur526      Neur560     Neur565      Neur566\nLamc1  -0.005698386  8.098411e-03 -0.002777033  0.02760694  0.042467086\nLama1   0.021459376 -5.210111e-03  0.026547559  0.05971741  0.026773138\nHs3st1 -0.058540117 -5.159973e-03 -0.028545565 -0.03421586 -0.018237097\nFabp3   0.104026536 -4.399868e-05 -0.031478717 -0.01143598 -0.007057800\nNrg2    0.067456393  1.888367e-02  0.036151663  0.04125869  0.005918738\nBend4  -0.035214002 -3.580672e-03 -0.003135888  0.21473720  0.012669639\n             Neur568      Neur573      Neur574      Neur575      Neur679\nLamc1  -0.0238073082  0.016259061  0.029273702 -0.006876455 -0.026166913\nLama1   0.0269694769  0.011948982 -0.005923828  0.009594151 -0.021046008\nHs3st1 -0.0557759330 -0.025415472 -0.033200908 -0.024987623  0.009828396\nFabp3  -0.0650712806 -0.026079990 -0.007401114 -0.012669512 -0.090809976\nNrg2    0.0004859691 -0.008135245  0.001663527 -0.013282661 -0.001594555\nBend4   0.1394771632 -0.002429324 -0.004063790  0.011455264  0.009762501"
  },
  {
    "objectID": "DEA_Seurat_COTAN.html#seurat-object-creation",
    "href": "DEA_Seurat_COTAN.html#seurat-object-creation",
    "title": "DEA comparison Seurat - Cotan",
    "section": "Seurat object creation",
    "text": "Seurat object creation\n\nseurat.obj &lt;- CreateSeuratObject(counts = getRawData(fb150Obj), project = \"fb15.0\", min.cells = 3, min.features = 200)\n\nseurat.obj[[\"percent.mt\"]] &lt;- PercentageFeatureSet(seurat.obj, pattern = \"^mt.\")\nVlnPlot(seurat.obj, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3)\n\n\n\n\n\nseurat.obj &lt;- NormalizeData(seurat.obj, normalization.method = \"LogNormalize\", scale.factor = 10000)\n\nseurat.obj &lt;- FindVariableFeatures(seurat.obj, selection.method = \"vst\", nfeatures = 2000)\nall.genes &lt;- rownames(seurat.obj)\nseurat.obj &lt;- ScaleData(seurat.obj, features = all.genes)\n\nseurat.obj &lt;- RunPCA(seurat.obj, features = VariableFeatures(object = seurat.obj))\n\nDimPlot(seurat.obj)\n\n\n\n\n\nElbowPlot(seurat.obj,ndims = 50)\n\n\n\n\n\nseurat.obj &lt;- FindNeighbors(seurat.obj, dims = 1:25)\nseurat.obj &lt;- FindClusters(seurat.obj, resolution = 0.5)\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4407\nNumber of edges: 148076\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8695\nNumber of communities: 11\nElapsed time: 0 seconds\n\nseurat.obj &lt;- RunUMAP(seurat.obj, dims = 1:25)\n\n\nDimPlot(seurat.obj)\n\n\n\n\n\nidentical(rownames(seurat.obj@meta.data),rownames(metaC))\n\n[1] TRUE\n\nseurat.obj@meta.data &lt;- cbind(seurat.obj@meta.data, metaC)\n\nDimPlot(seurat.obj,group.by = \"Subclass\", label = TRUE)+NoLegend()\n\n\n\n\n\nDimPlot(seurat.obj,group.by = \"ClusterName\", label = T, label.size = 3)+NoLegend()\n\n\n\n\n\nseurat.obj &lt;- SetIdent(seurat.obj,value = \"Subclass\")\nseurat.obj.markers.Subclass &lt;- FindAllMarkers(seurat.obj, logfc.threshold = 0.1,min.pct = 0.01, only.pos = TRUE)\n\nhead(seurat.obj.markers.Subclass)\n\n                p_val avg_log2FC pct.1 pct.2     p_val_adj\nNeurod6  0.000000e+00   4.090494 0.987 0.127  0.000000e+00\nNeurod2 3.164351e-294   3.376326 0.957 0.065 4.101949e-290\nTiam2   4.807385e-256   3.542872 0.900 0.068 6.231813e-252\nSox5    2.989319e-249   3.598904 0.912 0.127 3.875055e-245\nPpp2r2b 9.140509e-235   2.193826 0.970 0.361 1.184884e-230\nRbfox1  3.234905e-206   2.318090 0.974 0.412 4.193407e-202\n                                      cluster    gene\nNeurod6 Cortical or hippocampal glutamatergic Neurod6\nNeurod2 Cortical or hippocampal glutamatergic Neurod2\nTiam2   Cortical or hippocampal glutamatergic   Tiam2\nSox5    Cortical or hippocampal glutamatergic    Sox5\nPpp2r2b Cortical or hippocampal glutamatergic Ppp2r2b\nRbfox1  Cortical or hippocampal glutamatergic  Rbfox1\n\n\n\n seurat.obj &lt;- SetIdent(seurat.obj,value = \"ClusterName\")\n seurat.obj.markers.ClusterName &lt;- FindAllMarkers(seurat.obj,densify = TRUE, logfc.threshold = 0.1,min.pct = 0.01,only.pos = TRUE)\n \nhead(seurat.obj.markers.ClusterName)\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj cluster     gene\nWnt10a   4.836119e-259  0.9646853 0.316 0.000 6.269061e-255 Neur492   Wnt10a\nAdamts19 2.737699e-201  0.8726592 0.316 0.001 3.548879e-197 Neur492 Adamts19\nTac2     1.894266e-172  2.0721515 0.316 0.002 2.455537e-168 Neur492     Tac2\nRmst     1.166934e-155  2.2966143 0.763 0.024 1.512697e-151 Neur492     Rmst\nEomes    1.978338e-139  1.6902540 0.579 0.015 2.564520e-135 Neur492    Eomes\nEbf1     4.915113e-109  1.9468755 0.526 0.016 6.371461e-105 Neur492     Ebf1"
  },
  {
    "objectID": "DEA_Seurat_COTAN.html#comparision-cotan-seurat",
    "href": "DEA_Seurat_COTAN.html#comparision-cotan-seurat",
    "title": "DEA comparison Seurat - Cotan",
    "section": "Comparision COTAN-Seurat",
    "text": "Comparision COTAN-Seurat\n\nmarkers.list.names &lt;- col_concat(crossing(colnames(dea.Subclass$coex),c(\"Seurat\",\"Cotan\")),sep = \" \")\n\nmarkers.list &lt;- vector(\"list\", length(markers.list.names))\nnames(markers.list) &lt;- markers.list.names\n\n# I take positive coex significant genes \nfor (cl.name in colnames(dea.Subclass$coex)) {\n  genes &lt;- rownames(dea.Subclass$coex[dea.Subclass$`p-value`[,cl.name] &lt; 0.01 & dea.Subclass$coex[,cl.name] &gt; 0,])\n  markers.list[[paste0(cl.name,\" Cotan\")]] &lt;- genes\n}\n\n#For seurat\nfor (cl.name in colnames(dea.Subclass$coex)) {\n  genes &lt;- seurat.obj.markers.Subclass[seurat.obj.markers.Subclass$cluster == cl.name & seurat.obj.markers.Subclass$p_val &lt; 0.01,]$gene\n  markers.list[[paste0(cl.name,\" Seurat\")]] &lt;- genes\n}\n\n\nCajal-Retzius subclass\n\nggvenn.CR &lt;- ggVennDiagram(markers.list[1:2])\nggvenn.CR\n\n\n\n\nWe can observe that there is a good overlap among the detected markers.\n\ngenes.to.test &lt;- markers.list$`Cajal-Retzius Seurat`[!markers.list$`Cajal-Retzius Seurat` %in% markers.list$`Cajal-Retzius Cotan`]\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Seurat Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#E69F00\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 50)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\nset.seed(111)\ngenes &lt;- sample(genes.to.test,size = 12)\ngenes\n\n [1] \"Zfp579\" \"Lias\"   \"Tmed2\"  \"Srsf9\"  \"Dtx3\"   \"Srp14\"  \"Pofut2\" \"Rtn1\"  \n [9] \"Thap3\"  \"Cttn\"   \"Socs2\"  \"Ctxn1\" \n\n\n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\nGenerally if we look at the genes specifically detected by Seurat, they don’t seems so distinctive for CR cells.\n\nsum(genes.to.test %in% markers.list$`Cortical or hippocampal glutamatergic Seurat`)/length(genes.to.test)\n\n[1] 0.08626761\n\n\n\ngenes.to.test.Cotan &lt;- markers.list$`Cajal-Retzius Cotan`[!markers.list$`Cajal-Retzius Cotan` %in% markers.list$`Cajal-Retzius Seurat`]\n\nset.seed(11)\ngenes &lt;- sample(genes.to.test.Cotan,size = 30)\ngenes\n\n [1] \"Fam149a\"        \"Slc35g2\"        \"Chst7\"          \"P2ry14\"        \n [5] \"Tusc3\"          \"A730056A06Rik\"  \"Zfp941\"         \"Gpx8\"          \n [9] \"Ripk1\"          \"Gm15441\"        \"Igsf10\"         \"X4930522L14Rik\"\n[13] \"Gm16845\"        \"Gspt2\"          \"Scn2b\"          \"Akr1b10\"       \n[17] \"Vegfa\"          \"X4933431E20Rik\" \"Rtkn\"           \"Gm38250\"       \n[21] \"Fancf\"          \"Rab43\"          \"Grik1\"          \"Eya1\"          \n[25] \"Pih1d2\"         \"Cldn12\"         \"Cacng2\"         \"Pias3\"         \n[29] \"Gm26782\"        \"Mme\"           \n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test.Cotan]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Cotan Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#C69AFF\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 25)+xlim(0,4800)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\nNow we can test the enrichment for the specific gene both in Seurat and in Cotan.\nTo make a comparison more equal we select the same number of genes (depending on the smallest group)\n\ngenes.to.testTop &lt;- seurat.obj.markers.Subclass[seurat.obj.markers.Subclass$cluster == \"Cajal-Retzius\" & seurat.obj.markers.Subclass$gene %in% genes.to.test,]$gene[1:length(genes.to.test.Cotan)]\n\n\nenriched &lt;- enrichr(genes.to.testTop, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(123)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:20],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:20])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\nenriched &lt;- enrichr(genes.to.test.Cotan, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(123)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:20],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:20])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\n\nCortical or hippocampal glutamatergic subclass\n\nggvenn.CHG &lt;- ggVennDiagram(markers.list[3:4])\nggvenn.CHG\n\n\n\n\n\ngenes.to.test &lt;- markers.list$`Cortical or hippocampal glutamatergic Seurat`[!markers.list$`Cortical or hippocampal glutamatergic Seurat` %in% markers.list$`Cortical or hippocampal glutamatergic Cotan`]\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Seurat Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nlibrary(plyr)\nlibrary(scales) \nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#E69F00\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 50)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\nset.seed(111)\ngenes &lt;- sample(genes.to.test,size = 18)\ngenes\n\n [1] \"Fam220a\" \"Taok3\"   \"Fau\"     \"Fzd1\"    \"Rpl7\"    \"Idh3a\"   \"Lgmn\"   \n [8] \"Mapkap1\" \"Apopt1\"  \"Tubg1\"   \"Rpl10\"   \"Rpl6\"    \"Ankrd45\" \"Nsa2\"   \n[15] \"Reep2\"   \"Rpl14\"   \"Egfem1\"  \"Letm1\"  \n\n\n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\n\ngenes.to.test.Cotan &lt;- markers.list$`Cortical or hippocampal glutamatergic Cotan`[!markers.list$`Cortical or hippocampal glutamatergic Cotan` %in% markers.list$`Cortical or hippocampal glutamatergic Seurat`]\n\nset.seed(11)\ngenes &lt;- sample(genes.to.test.Cotan,size = 30)\ngenes\n\n [1] \"Pitpnm1\"        \"Nptx1\"          \"Tnfaip8l1\"      \"Dlc1\"          \n [5] \"Ttyh1\"          \"Pde11a\"         \"Adamts2\"        \"Pomk\"          \n [9] \"D6Ertd474e\"     \"Car12\"          \"Rspo3\"          \"Gm43517\"       \n[13] \"X3830406C13Rik\" \"Grp\"            \"E2f1\"           \"Ntf3\"          \n[17] \"Stim2\"          \"D030068K23Rik\"  \"Tspan17\"        \"Ube2t\"         \n[21] \"Impa2\"          \"Egfl6\"          \"Serping1\"       \"Pttg1\"         \n[25] \"Sh3bgrl3\"       \"Mcrip2\"         \"Map1lc3a\"       \"Nrn1\"          \n[29] \"Gm42997\"        \"AC124490.1\"    \n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test.Cotan]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Cotan Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#C69AFF\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 25)+xlim(0,4800)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\ngenes.to.testTop &lt;- seurat.obj.markers.Subclass[seurat.obj.markers.Subclass$cluster == \"Cortical or hippocampal glutamatergic\" & seurat.obj.markers.Subclass$gene %in% genes.to.test,]$gene[1:length(genes.to.test.Cotan)]\n\n\nenriched &lt;- enrichr(genes.to.testTop, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(12333)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:8],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:8])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(2, 0.5), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\nenriched &lt;- enrichr(genes.to.test.Cotan, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(1233)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:20],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:20])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\n\nForebrain GABAergic subclass\n\nggvenn.FGaba &lt;- ggVennDiagram(markers.list[5:6])\nggvenn.FGaba\n\n\n\n\n\ngenes.to.test &lt;- markers.list$`Forebrain GABAergic Seurat`[!markers.list$`Forebrain GABAergic Seurat` %in% markers.list$`Forebrain GABAergic Cotan`]\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Seurat Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nlibrary(plyr)\nlibrary(scales) \nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#E69F00\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 50)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\nset.seed(111)\ngenes &lt;- sample(genes.to.test,size = 18)\ngenes\n\n [1] \"Ddx5\"    \"Pycr2\"   \"Them4\"   \"Zfp647\"  \"Jpt1\"    \"Ybx1\"    \"Atp5a1\" \n [8] \"Cdkn1c\"  \"Gm3764\"  \"Bex2\"    \"Ftl1\"    \"Kmt2a\"   \"Map2\"    \"Cntnap2\"\n[15] \"Pogk\"    \"Rtn1\"    \"Scg5\"    \"H3f3b\"  \n\n\n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\n\ngenes.to.test.Cotan &lt;- markers.list$`Forebrain GABAergic Cotan`[!markers.list$`Forebrain GABAergic Cotan` %in% markers.list$`Forebrain GABAergic Seurat`]\n\nset.seed(11)\ngenes &lt;- sample(genes.to.test.Cotan,size = 30)\ngenes\n\n [1] \"Met\"        \"Rsbn1l\"     \"Zfp358\"     \"Enpp5\"      \"Sft2d3\"    \n [6] \"Gng4\"       \"Gm14342\"    \"Msrb3\"      \"Ncaph2\"     \"Dtnbp1\"    \n[11] \"Zfp62\"      \"Shprh\"      \"Bmf\"        \"AC174678.1\" \"Map7d1\"    \n[16] \"Srsf1\"      \"Smim7\"      \"Rab39b\"     \"Depdc7\"     \"Prkg1\"     \n[21] \"Rad21\"      \"Brinp1\"     \"Rbm5\"       \"Laptm4b\"    \"Dcbld2\"    \n[26] \"Slf2\"       \"Fam173a\"    \"Sh3bp5l\"    \"Slc1a2\"     \"Sstr1\"     \n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test.Cotan]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Cotan Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#C69AFF\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 25)+xlim(0,4800)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\nenriched &lt;- enrichr(genes.to.test, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(12333)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:5],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:5])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\nsubset.pval &lt;- dea.Subclass$`p-value`[rownames(dea.Subclass$`p-value`) %in% genes.to.test.Cotan,]\n\ngenes.to.test.Cotan.Top &lt;- rownames(subset.pval[order(subset.pval$`Forebrain GABAergic`,decreasing = F),])[1:length(genes.to.test)]\n\nenriched &lt;- enrichr(genes.to.test.Cotan.Top, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(123)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term,pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score)\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\n\nCluster Neur509\n\n# markers.list.namesNeur509 &lt;- col_concat(crossing(colnames(dea.ClusterName$coex),c(\"Seurat\",\"Cotan\")),sep = \" \")\n# \n# markers.listNeur509 &lt;- vector(\"list\", length(markers.list.namesNeur509))\n# names(markers.listNeur509) &lt;- markers.list.namesNeur509\n\nmarkers.listNeur509 &lt;- list(\"Neur509 Cotan\"=NA,\"Neur509 Seurat\"=NA)\n\n# I take positive coex significant genes \nfor (cl.name in \"Neur509\") {\n  genes &lt;- rownames(dea.ClusterName$coex[dea.ClusterName$`p-value`[,cl.name] &lt; 0.01 & dea.ClusterName$coex[,cl.name] &gt; 0,])\n  markers.listNeur509[[paste0(cl.name,\" Cotan\")]] &lt;- genes\n}\n\n#For seurat\nfor (cl.name in \"Neur509\") {\n  genes &lt;- seurat.obj.markers.ClusterName[seurat.obj.markers.ClusterName$cluster == cl.name & seurat.obj.markers.ClusterName$p_val &lt; 0.01,]$gene\n  markers.listNeur509[[paste0(cl.name,\" Seurat\")]] &lt;- genes\n}\n\n\nggVennDiagram(markers.listNeur509)\n\n\n\n\nWe can observe that there is a good overlap among the detected markers.\n\ngenes.to.test &lt;- markers.listNeur509$`Neur509 Seurat`[!markers.listNeur509$`Neur509 Seurat` %in% markers.listNeur509$`Neur509 Cotan`]\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Seurat Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#E69F00\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 25)+xlim(0,4800)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent of genes\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\nset.seed(111)\ngenes &lt;- sample(genes.to.test,size = 12)\ngenes\n\n [1] \"Grpel1\"         \"Ssna1\"          \"X1110004E09Rik\" \"Mri1\"          \n [5] \"Sod2\"           \"Bola1\"          \"Ppp4c\"          \"Draxin\"        \n [9] \"Peli2\"          \"Sfpq\"           \"Rpl22\"          \"Chmp5\"         \n\n\n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\nGenerally if we look at the genes specifically detected by Seurat, they don’t seems so distinctive for CR cells.\n\nsum(genes.to.test %in% markers.listNeur509$`Cortical or hippocampal glutamatergic Seurat`)/length(genes.to.test)\n\n[1] 0\n\n\n\ngenes.to.test.Cotan &lt;- markers.listNeur509$`Neur509 Cotan`[!markers.listNeur509$`Neur509 Cotan` %in% markers.listNeur509$`Neur509 Seurat`]\n\nset.seed(11)\ngenes &lt;- sample(genes.to.test.Cotan,size = 30)\ngenes\n\n [1] \"Dusp14\"     \"Gm15594\"    \"Tnik\"       \"Sertad3\"    \"Sowahc\"    \n [6] \"Adgrg6\"     \"Rbfox1\"     \"Gm10073\"    \"Gm17231\"    \"Btf3\"      \n[11] \"Khdrbs2\"    \"Adpgk\"      \"Pih1d2\"     \"Capzb\"      \"Cox6b1\"    \n[16] \"Chst5\"      \"Dcxr\"       \"Tfdp2\"      \"Plcxd2\"     \"Prss41\"    \n[21] \"Kcnq5\"      \"AC152827.1\" \"Atg4a\"      \"Fezf2\"      \"Gm15489\"   \n[26] \"Cth\"        \"Zbtb44\"     \"Sec61a1\"    \"Rbm12b1\"    \"Hk2\"       \n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test.Cotan]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Cotan Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#C69AFF\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 25)+xlim(0,4800)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\nNow we can test the enrichment for the specific gene both in Seurat and in Cotan.\nTo make a comparison more equal we select the same number of genes (depending on the smallest group)\n\ngenes.to.testTop &lt;- seurat.obj.markers.ClusterName[seurat.obj.markers.ClusterName$cluster == \"Neur509\" & seurat.obj.markers.ClusterName$gene %in% genes.to.test,]$gene[1:length(genes.to.test.Cotan)]\n\n\nenriched &lt;- enrichr(genes.to.testTop, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(123)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:20],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:20])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\nenriched &lt;- enrichr(genes.to.test.Cotan, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(123)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:20],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:20])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\n\nCluster Neur508\n\n# markers.list.namesNeur508 &lt;- col_concat(crossing(colnames(dea.ClusterName$coex),c(\"Seurat\",\"Cotan\")),sep = \" \")\n# \n# markers.listNeur508 &lt;- vector(\"list\", length(markers.list.namesNeur508))\n# names(markers.listNeur508) &lt;- markers.list.namesNeur508\n\nmarkers.listNeur508 &lt;- list(\"Neur508 Cotan\"=NA,\"Neur508 Seurat\"=NA)\n\n# I take positive coex significant genes \nfor (cl.name in \"Neur508\") {\n  genes &lt;- rownames(dea.ClusterName$coex[dea.ClusterName$`p-value`[,cl.name] &lt; 0.01 & dea.ClusterName$coex[,cl.name] &gt; 0,])\n  markers.listNeur508[[paste0(cl.name,\" Cotan\")]] &lt;- genes\n}\n\n#For seurat\nfor (cl.name in \"Neur508\") {\n  genes &lt;- seurat.obj.markers.ClusterName[seurat.obj.markers.ClusterName$cluster == cl.name & seurat.obj.markers.ClusterName$p_val &lt; 0.01,]$gene\n  markers.listNeur508[[paste0(cl.name,\" Seurat\")]] &lt;- genes\n}\n\n\nggVennDiagram(markers.listNeur508)\n\n\n\n\nWe can observe that there is a good overlap among the detected markers.\n\ngenes.to.test &lt;- markers.listNeur508$`Neur508 Seurat`[!markers.listNeur508$`Neur508 Seurat` %in% markers.listNeur508$`Neur508 Cotan`]\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Seurat Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#E69F00\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 50)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\n\nset.seed(111)\ngenes &lt;- sample(genes.to.test,size = 12)\ngenes\n\n [1] \"Gm10131\" \"Topors\"  \"Agfg1\"   \"Pfdn4\"   \"Arhgdia\" \"Fam96b\"  \"Kif5c\"  \n [8] \"Rpl18\"   \"Akt3\"    \"Gm42743\" \"Papola\"  \"Uri1\"   \n\n\n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\nGenerally if we look at the genes specifically detected by Seurat, they don’t seems so distinctive for CR cells.\n\nsum(genes.to.test %in% markers.listNeur508$`Cortical or hippocampal glutamatergic Seurat`)/length(genes.to.test)\n\n[1] 0\n\n\n\ngenes.to.test.Cotan &lt;- markers.listNeur508$`Neur508 Cotan`[!markers.listNeur508$`Neur508 Cotan` %in% markers.listNeur508$`Neur508 Seurat`]\n\n\n\nset.seed(11)\ngenes &lt;- sample(genes.to.test.Cotan,size = 30)\ngenes\n\n [1] \"X1700066M21Rik\" \"Gm44734\"        \"Zfp959\"         \"Rpl37\"         \n [5] \"Chodl\"          \"Mmp17\"          \"Atp5h\"          \"Acot6\"         \n [9] \"Cux2\"           \"Rps10\"          \"Rpl13a\"         \"Lurap1l\"       \n[13] \"Tcf12\"          \"Sirt6\"          \"Gm12184\"        \"Etohd2\"        \n[17] \"Laptm4b\"        \"Pomc\"           \"Rpl9\"           \"Inhbb\"         \n[21] \"Gpr62\"          \"Sstr3\"          \"D830035M03Rik\"  \"Eef1b2\"        \n[25] \"Bmpr1b\"         \"Rps4x\"          \"Tpd52\"          \"Selenow\"       \n[29] \"Pla2g7\"         \"Kcnj11\"        \n\nn=0\nfor (g in c(0:2)) {\n  n = g*4\n  plot(FeaturePlot(seurat.obj,features = genes[n+c(1:4)], label = T))\n}\n\n\n\n\n\n\n\n\n\n\n\ndf &lt;- getNumOfExpressingCells(fb150Obj)[genes.to.test.Cotan]\ndf &lt;- as.data.frame(df)\ncolnames(df) &lt;- \"CellNumber\"\nrownames(df) &lt;- NULL\ndf$type &lt;- \"Only Cotan Genes\"\n\ndf.bk &lt;- as.data.frame(getNumOfExpressingCells(fb150Obj)[sample(getGenes(fb150Obj), size = length(rownames(df)))])\nrownames(df.bk) &lt;- NULL\ncolnames(df.bk) &lt;- \"CellNumber\"\ndf.bk$type &lt;- \"Whole dataset Genes\"\ndf &lt;- rbind(df,df.bk)\n\nmu &lt;- ddply(df, \"type\", summarise, grp.mean=mean(CellNumber))\n\nggplot(df,aes(x=CellNumber,fill=type))+\n  scale_fill_manual(values=c(\"#C69AFF\", \"#56B4E9\"))+\n  geom_histogram(aes(y=..density..), position=\"identity\", alpha=0.5,bins = 25)+xlim(0,4800)+\n  geom_vline(data=mu, aes(xintercept=grp.mean, color=type),\n           linetype=\"dashed\")+\n  geom_density(alpha=0.6)+\n  scale_y_continuous(labels = percent, name = \"percent\") +\n  theme_classic()+\n  theme(legend.position=\"bottom\")\n\n\n\n\nNow we can test the enrichment for the specific gene both in Seurat and in Cotan.\nTo make a comparison more equal we select the same number of genes (depending on the smallest group)\n\n#genes.to.testTop &lt;- seurat.obj.markers.ClusterName[seurat.obj.markers.ClusterName$cluster == \"Neur508\" & seurat.obj.markers.ClusterName$gene %in% genes.to.test,]$gene[1:length(genes.to.test.Cotan)]\n\n\nenriched &lt;- enrichr(genes.to.test, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(123)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:20],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:20])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\nsubset.pval &lt;- dea.ClusterName$`p-value`[rownames(dea.ClusterName$`p-value`) %in% genes.to.test.Cotan,]\n\ngenes.to.test.Cotan.Top &lt;- rownames(subset.pval[order(subset.pval$Neur492,decreasing = F),])[1:length(genes.to.test)]\n\n\n\nenriched &lt;- enrichr(genes.to.test.Cotan.Top, dbs)\n\nUploading data to Enrichr... Done.\n  Querying ARCHS4_Tissues... Done.\nParsing results... Done.\n\nplotEnrich(enriched[[1]], showTerms = 10, numChar = 40, y = \"Count\", orderBy = \"P.value\")\n\n\n\n\n\nset.seed(123)\nwordcloud_data &lt;- data.frame(Terms = str_split(enriched[[1]]$Term[1:20],pattern = \" CL\",simplify = T )[,1],\n                             Scores = enriched[[1]]$Combined.Score[1:20])\n\nwordcloud(wordcloud_data$Terms, wordcloud_data$Scores, scale = c(3, 1), min.freq = 1, random.order=FALSE, rot.per=0.1,colors=brewer.pal(8, \"Dark2\"))\n\n\n\n\n\nggVennDiagram(markers.list[c(1,3,5)])\n\n\n\n\n\nggVennDiagram(markers.list[c(2,4,6)])\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Berlin\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] enrichR_3.2         tidyr_1.3.0         ggVennDiagram_1.2.2\n [4] assertr_3.0.0       stringr_1.5.0       wordcloud_2.6      \n [7] RColorBrewer_1.1-3  SeuratObject_4.1.3  Seurat_4.3.0       \n[10] rlang_1.1.0         scales_1.2.1        plyr_1.8.8         \n[13] COTAN_2.1.5         zeallot_0.1.0       tibble_3.2.1       \n[16] ggplot2_3.4.2      \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.20       splines_4.3.0          later_1.3.0           \n  [4] polyclip_1.10-4        factoextra_1.0.7       lifecycle_1.0.3       \n  [7] sf_1.0-13              doParallel_1.0.17      globals_0.16.2        \n [10] lattice_0.21-8         MASS_7.3-59            dendextend_1.17.1     \n [13] magrittr_2.0.3         limma_3.56.0           plotly_4.10.1         \n [16] rmarkdown_2.21         yaml_2.3.7             httpuv_1.6.9          \n [19] sctransform_0.3.5      askpass_1.1            sp_1.6-0              \n [22] spatstat.sparse_3.0-1  reticulate_1.30        cowplot_1.1.1         \n [25] pbapply_1.7-0          DBI_1.1.3              abind_1.4-5           \n [28] Rtsne_0.16             purrr_1.0.1            BiocGenerics_0.46.0   \n [31] WriteXLS_6.4.0         circlize_0.4.15        IRanges_2.34.0        \n [34] S4Vectors_0.38.0       ggrepel_0.9.3          irlba_2.3.5.1         \n [37] listenv_0.9.0          spatstat.utils_3.0-3   units_0.8-2           \n [40] umap_0.2.10.0          goftest_1.2-3          RSpectra_0.16-1       \n [43] spatstat.random_3.1-4  fitdistrplus_1.1-8     parallelly_1.36.0     \n [46] leiden_0.4.3           codetools_0.2-19       tidyselect_1.2.0      \n [49] shape_1.4.6            farver_2.1.1           viridis_0.6.2         \n [52] matrixStats_1.0.0      stats4_4.3.0           spatstat.explore_3.2-1\n [55] jsonlite_1.8.4         GetoptLong_1.0.5       e1071_1.7-13          \n [58] ellipsis_0.3.2         progressr_0.13.0       ggridges_0.5.4        \n [61] survival_3.5-5         iterators_1.0.14       foreach_1.5.2         \n [64] tools_4.3.0            ica_1.0-3              Rcpp_1.0.10           \n [67] glue_1.6.2             gridExtra_2.3          xfun_0.39             \n [70] ggthemes_4.2.4         dplyr_1.1.2            withr_2.5.0           \n [73] fastmap_1.1.1          fansi_1.0.4            openssl_2.0.6         \n [76] digest_0.6.31          parallelDist_0.2.6     R6_2.5.1              \n [79] mime_0.12              colorspace_2.1-0       scattermore_1.2       \n [82] tensor_1.5             spatstat.data_3.0-1    utf8_1.2.3            \n [85] generics_0.1.3         data.table_1.14.8      class_7.3-21          \n [88] httr_1.4.5             htmlwidgets_1.6.2      uwot_0.1.14           \n [91] pkgconfig_2.0.3        gtable_0.3.3           ComplexHeatmap_2.16.0 \n [94] lmtest_0.9-40          htmltools_0.5.5        clue_0.3-64           \n [97] png_0.1-8              knitr_1.42             rstudioapi_0.14       \n[100] reshape2_1.4.4         rjson_0.2.21           nlme_3.1-162          \n[103] curl_5.0.0             proxy_0.4-27           zoo_1.8-12            \n[106] GlobalOptions_0.1.2    RVenn_1.1.0            KernSmooth_2.23-20    \n[109] parallel_4.3.0         miniUI_0.1.1.1         vipor_0.4.5           \n[112] RcppZiggurat_0.1.6     ggrastr_1.0.2          pillar_1.9.0          \n[115] grid_4.3.0             vctrs_0.6.1            RANN_2.6.1            \n[118] promises_1.2.0.1       xtable_1.8-4           cluster_2.1.4         \n[121] beeswarm_0.4.0         evaluate_0.20          cli_3.6.1             \n[124] compiler_4.3.0         crayon_1.5.2           future.apply_1.11.0   \n[127] labeling_0.4.2         classInt_0.4-9         ggbeeswarm_0.7.2      \n[130] stringi_1.7.12         viridisLite_0.4.1      deldir_1.0-6          \n[133] assertthat_0.2.1       munsell_0.5.0          lazyeval_0.2.2        \n[136] spatstat.geom_3.2-1    Matrix_1.5-4.1         patchwork_1.1.2       \n[139] future_1.32.0          shiny_1.7.4            ROCR_1.0-11           \n[142] Rfast_2.0.7            igraph_1.4.2           RcppParallel_5.1.7"
  },
  {
    "objectID": "Dataset1.html",
    "href": "Dataset1.html",
    "title": "E14.5 Mouse Cortex Loo 2019",
    "section": "",
    "text": "options(parallelly.fork.enable = TRUE)\nlibrary(COTAN)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(factoextra)\n\nLoading required package: ggplot2\n\n\nWelcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa\n\nlibrary(Rtsne)\nlibrary(qpdf)\nlibrary(stringr)\ne14_dge = read.table(\"../COTAN_small_paper/data/MouseCortex/E14_combined_matrix.txt.gz\",header=T,sep=\"\\t\",row.names=1)\n\nprint(dim(e14_dge))\n\n[1] 21313 11069\noutDir &lt;- \"Data/MouseCortex/\"\nsetLoggingLevel(1)\n\nSetting new log level to 1\n\nsetLoggingFile(file.path(outDir, \"Dataset.log\"))\n\nSetting log file to be: Data/MouseCortex//Dataset.log\ncond &lt;- \"MouseCortex_E14.5\"\nobj &lt;- COTAN(raw = e14_dge)\nobj &lt;- initializeMetaDataset(obj,\n                             GEO = \"GSE123335\",\n                             sequencingMethod = \"Drop_seq\",\n                             sampleCondition = cond)\nrm(e14_dge)\nECDPlot(obj, yCut = 400L)\ncellSizePlot(obj,splitPattern = \"_\",numCol = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\ngenesSizePlot(obj,splitPattern = \"_\",numCol = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nmit &lt;- mitochondrialPercentagePlot(obj, genePrefix = \"^mt-\",splitPattern = \"_\",numCol = 1)\nmit[[\"plot\"]]\nTo drop cells by cell library size:\ncells_to_rem &lt;- getCells(obj)[getCellsSize(obj) &gt; 15000]\nobj &lt;- dropGenesCells(obj, cells = cells_to_rem)\ncellSizePlot(obj,splitPattern = \"_\",numCol = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\ngenesSizePlot(obj,splitPattern = \"_\",numCol = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\nTo drop cells by mitochondrial percentage:\nto_rem &lt;- mit[[\"sizes\"]][[\"mit.percentage\"]] &gt; 7.5\ncells_to_rem &lt;- rownames(mit[[\"sizes\"]])[to_rem]\nobj &lt;- dropGenesCells(obj, cells = cells_to_rem)\n\nmit &lt;- mitochondrialPercentagePlot(obj, genePrefix = \"^mt-\",splitPattern = \"_\",numCol = 1)\n\nmit[[\"plot\"]]\ncellSizePlot(obj,splitPattern = \"_\",numCol = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nobj &lt;- clean(obj)\n\nGenes/cells selection done: dropped [7655] genes and [0] cells\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %&lt;-% cleanPlots(obj)\n\nWarning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size\n1.1 GiB\n\npcaCellsPlot\ngenesPlot\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\nobj &lt;- dropGenesCells(obj, cells = cells_to_rem)\nobj &lt;- clean(obj)\n\nGenes/cells selection done: dropped [1] genes and [0] cells\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %&lt;-% cleanPlots(obj)\n\nWarning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size\n1.1 GiB\n\npcaCellsPlot\ngenesPlot\nplot(nuPlot)\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(obj)), \"n\" = seq_along(getNu(obj)))\nyset &lt;- 0.18 # the threshold to remove low UDE cells\nplot.ude &lt;- ggplot(nuDf, aes(x = n, y = nu)) +\n            geom_point(colour = \"#8491B4B2\", size = 1.0) +\n            xlim(0L, 3000) +\n            ylim(0.0, 1.0) +\n            geom_hline(yintercept = yset, linetype = \"dashed\",\n                       color = \"darkred\") +\n            annotate(geom = \"text\", x = 1000L, y = 0.25,\n                     label = paste0(\"to remove cells with nu &lt; \", yset),\n                     color = \"darkred\", size = 4.5)\n\nplot.ude\n\nWarning: Removed 7905 rows containing missing values (`geom_point()`).\nobj &lt;- addElementToMetaDataset(obj, \"Threshold low UDE cells:\", yset)\n\ncells_to_rem &lt;- rownames(nuDf)[nuDf[[\"nu\"]] &lt; yset]\nobj &lt;- dropGenesCells(obj, cells = cells_to_rem)\nobj &lt;- clean(obj)\n\nGenes/cells selection done: dropped [0] genes and [0] cells\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %&lt;-% cleanPlots(obj)\n\nWarning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size\n1.1 GiB\n\npcaCellsPlot\ngenesPlot\nUDEPlot\nnuPlot\nUDEPlot$data$Sample &lt;- str_split(rownames(UDEPlot$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(UDEPlot$data, aes(PC1,PC2,color = Sample)) + geom_point(size = 0.5, alpha=0.7)\nggplot(UDEPlot$data, aes(PC2,PC3,color = Sample)) + geom_point(size = 0.5, alpha=0.7)\nggplot(UDEPlot$data, aes(PC2,PC5,color = Sample)) + geom_point(size = 0.5, alpha=0.7)\nggplot(UDEPlot$data, aes(PC2,PC5,color = groups)) + geom_point(size = 0.5, alpha=0.7)"
  },
  {
    "objectID": "Dataset1.html#cotan-analysis",
    "href": "Dataset1.html#cotan-analysis",
    "title": "E14.5 Mouse Cortex Loo 2019",
    "section": "COTAN analysis",
    "text": "COTAN analysis\nIn this part, all the contingency tables are computed and used to get the statistics.\n\nobj &lt;- estimateDispersionBisection(obj, cores = 15L)\n\ndispersion | min: -0.00997257232666016 | max: 691 | % negative: 2.21864245441898\n\n\nCOEX evaluation and storing\n\nobj &lt;- calculateCoex(obj)\n\n\n# saving the structure\nsaveRDS(obj, file = file.path(outDir, paste0(cond, \".cotan.RDS\")))\n\n\nobj &lt;- readRDS(file = file.path(outDir, paste0(cond, \".cotan.RDS\")))\n\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Berlin\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] stringr_1.5.0     qpdf_1.3.2        Rtsne_0.16        factoextra_1.0.7 \n[5] ggplot2_3.4.2     data.table_1.14.8 zeallot_0.1.0     COTAN_2.1.2      \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.14        jsonlite_1.8.4        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.21        \n [10] GlobalOptions_0.1.2    vctrs_0.6.1            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-20    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.1          zoo_1.8-12             igraph_1.4.2          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.5-4           R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-8     future_1.32.0         \n [34] shiny_1.7.4            clue_0.3-64            digest_0.6.31         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.0      \n [40] Seurat_4.3.0           tensor_1.5             RSpectra_0.16-1       \n [43] irlba_2.3.5.1          labeling_0.4.2         progressr_0.13.0      \n [46] RcppZiggurat_0.1.6     fansi_1.0.4            spatstat.sparse_3.0-1 \n [49] httr_1.4.5             polyclip_1.10-4        abind_1.4-5           \n [52] compiler_4.3.0         withr_2.5.0            doParallel_1.0.17     \n [55] viridis_0.6.2          dendextend_1.17.1      MASS_7.3-59           \n [58] openssl_2.0.6          rjson_0.2.21           tools_4.3.0           \n [61] lmtest_0.9-40          httpuv_1.6.9           future.apply_1.11.0   \n [64] goftest_1.2-3          glue_1.6.2             nlme_3.1-162          \n [67] promises_1.2.0.1       grid_4.3.0             cluster_2.1.4         \n [70] reshape2_1.4.4         generics_0.1.3         gtable_0.3.3          \n [73] spatstat.data_3.0-1    tidyr_1.3.0            sp_1.6-0              \n [76] utf8_1.2.3             BiocGenerics_0.46.0    spatstat.geom_3.2-1   \n [79] RcppAnnoy_0.0.20       ggrepel_0.9.3          RANN_2.6.1            \n [82] foreach_1.5.2          pillar_1.9.0           later_1.3.0           \n [85] circlize_0.4.15        splines_4.3.0          dplyr_1.1.2           \n [88] lattice_0.21-8         survival_3.5-5         deldir_1.0-6          \n [91] tidyselect_1.2.0       ComplexHeatmap_2.16.0  miniUI_0.1.1.1        \n [94] pbapply_1.7-0          knitr_1.42             gridExtra_2.3         \n [97] IRanges_2.34.0         scattermore_1.1        stats4_4.3.0          \n[100] xfun_0.39              matrixStats_1.0.0      stringi_1.7.12        \n[103] lazyeval_0.2.2         yaml_2.3.7             evaluate_0.20         \n[106] codetools_0.2-19       tibble_3.2.1           cli_3.6.1             \n[109] uwot_0.1.14            xtable_1.8-4           reticulate_1.28       \n[112] munsell_0.5.0          Rcpp_1.0.10            globals_0.16.2        \n[115] spatstat.random_3.1-4  png_0.1-8              parallel_4.3.0        \n[118] Rfast_2.0.7            ellipsis_0.3.2         assertthat_0.2.1      \n[121] listenv_0.9.0          ggthemes_4.2.4         viridisLite_0.4.1     \n[124] scales_1.2.1           ggridges_0.5.4         SeuratObject_4.1.3    \n[127] leiden_0.4.3           purrr_1.0.1            crayon_1.5.2          \n[130] GetoptLong_1.0.5       rlang_1.1.0            cowplot_1.1.1"
  },
  {
    "objectID": "FDR_analisys.html",
    "href": "FDR_analisys.html",
    "title": "FDR analysis - define DE genes",
    "section": "",
    "text": "library(COTAN)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\"\n\n\nSeurat.DEA &lt;- function(dataSet,clusters.list, project, dirOut#,percentage\n                       ){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet,\n                             project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n  \n  \n  pbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n  pbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n  all.genes &lt;- rownames(pbmc)\n  pbmc &lt;- ScaleData(pbmc, features = all.genes)\n  \n  pbmc &lt;- RunPCA(pbmc)\n  pbmc &lt;- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- factor(clusters.list)\n  \n  pbmc &lt;- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE)\n  \n  \n  \n  n.genes.DEA &lt;- sum(pbmc.markers$p_val_adj &lt; 0.05)\n  \n  print(n.genes.DEA)\n  \n  #write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n}\n\n\nSeurat.DEA.bimod &lt;- function(dataSet,clusters.list, project, dirOut#,percentage\n                       ){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet,\n                             project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n  \n  \n  pbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n  pbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n  all.genes &lt;- rownames(pbmc)\n  pbmc &lt;- ScaleData(pbmc, features = all.genes)\n  \n  pbmc &lt;- RunPCA(pbmc)\n  pbmc &lt;- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- factor(clusters.list)\n  \n  pbmc &lt;- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE,test.use = \"bimod\" )\n  \n  \n  \n  n.genes.DEA &lt;- sum(pbmc.markers$p_val_adj &lt; 0.05)\n  \n  print(n.genes.DEA)\n  \n  #write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n}\n\nSeurat.DEAScTransform &lt;- function(dataSet,clusters.list, project, dirOut#,percentage\n                       ){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet,\n                             project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n\n  # store mitochondrial percentage in object meta data\n  pbmc &lt;- PercentageFeatureSet(pbmc, pattern = \"^mt-\", col.name = \"percent.mt\")\n\n# run sctransform\n  pbmc &lt;- SCTransform(pbmc, vars.to.regress = \"percent.mt\", verbose = FALSE)\n\n  \n  pbmc &lt;- RunPCA(pbmc)\n  pbmc &lt;- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- factor(clusters.list)\n  \n  pbmc &lt;- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE)\n  \n  \n  \n  n.genes.DEA &lt;- sum(pbmc.markers$p_val_adj &lt; 0.05)\n  \n  print(n.genes.DEA)\n  \n  #write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n}\n\n\n\n\nMonocle.DEA &lt;- function(dataSet,clusters.list,project, dirOut#,percentage\n                        ){\n  \n  cell_metadata = as.data.frame(clusters.list[colnames(dataSet)])\n  colnames(cell_metadata) &lt;- \"Clusters\"\n  cds &lt;- new_cell_data_set(dataSet[rowSums(dataSet) &gt; 3,],\n                         cell_metadata = cell_metadata\n                         )\n  colData(cds)$cluster &lt;- clusters.list[rownames(colData(cds))]\n\n  #cds &lt;- preprocess_cds(cds, num_dim = 100)\n  #cds &lt;- reduce_dimension(cds)\n  #cds &lt;- cluster_cells(cds, resolution=1e-5)\n  marker_test_res &lt;- top_markers(cds, \n                                 group_cells_by=\"Clusters\", \n                                 genes_to_test_per_group = dim(cds)[1],\n                                  cores=10)\n  \n  # de_results &lt;- fit_models(cds,model_formula_str = \" ~ cluster\",cores = 10,verbose = T)\n  # fit_coefs &lt;- coefficient_table(de_results)\n  # \n  # fit_coefs &lt;- fit_coefs %&gt;% filter(grepl(\"cluster\",term))\n  # fit_coefs &lt;- as.data.frame(fit_coefs)\n  #write.csv(as.data.frame(fit_coefs[,c(\"num_cells_expressed\" ,\"gene_id\",\"p_value\",\"q_value\")]), file = paste0(dirOut,project,\"_de_genes_Monocle_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=sum(marker_test_res$marker_test_q_value &lt; 0.05, na.rm = T),\n              \"marker_test_res\"= marker_test_res\n              ))\n}\n\n\nScamPy.DEA &lt;- function(dataSet,\n                       clusters.list, \n                       project, \n                       dirOut,\n                       percentage){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- clusters.list\n  \n  exprs &lt;- pbmc@assays$RNA$counts\n  \n  meta &lt;- pbmc[[]]\n  #feature_meta &lt;- GetAssay(pbmc)[[]]\n  tmp &lt;- as.data.frame(matrix(data = NA, \n                              ncol = 1, \n                              nrow = nrow(pbmc@assays$RNA$counts)))\n  rownames(tmp) &lt;- rownames(pbmc@assays$RNA$counts)\n  \n  feature_meta &lt;- tmp\n  #embedding &lt;- Embeddings(pbmc, \"umap\")\n  \n  Sys.setenv(RETICULATE_PYTHON = \"../../../bin/python3\")\n  py &lt;- import(\"sys\")\n  \n  source_python(\"src/scanpyFDR.py\")\n  scanpyFDR(exprs, \n                   meta, \n                   feature_meta, \n                   \"mt\", \n                   dirOut, \n                   project)\n\n  out &lt;- read.csv(file = paste0(dirOut,\n                                project,\n                                \"_Scampy_DEA_all_genes.csv\"\n                               ),\n                  header = T,\n                  row.names = 1)\n\n  gc()\n\n  return(out)\n}"
  },
  {
    "objectID": "FDR_analisys.html#automatic-functions",
    "href": "FDR_analisys.html#automatic-functions",
    "title": "FDR analysis - define DE genes",
    "section": "",
    "text": "library(COTAN)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\"\n\n\nSeurat.DEA &lt;- function(dataSet,clusters.list, project, dirOut#,percentage\n                       ){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet,\n                             project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n  \n  \n  pbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n  pbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n  all.genes &lt;- rownames(pbmc)\n  pbmc &lt;- ScaleData(pbmc, features = all.genes)\n  \n  pbmc &lt;- RunPCA(pbmc)\n  pbmc &lt;- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- factor(clusters.list)\n  \n  pbmc &lt;- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE)\n  \n  \n  \n  n.genes.DEA &lt;- sum(pbmc.markers$p_val_adj &lt; 0.05)\n  \n  print(n.genes.DEA)\n  \n  #write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n}\n\n\nSeurat.DEA.bimod &lt;- function(dataSet,clusters.list, project, dirOut#,percentage\n                       ){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet,\n                             project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n  \n  \n  pbmc &lt;- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n  pbmc &lt;- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n  all.genes &lt;- rownames(pbmc)\n  pbmc &lt;- ScaleData(pbmc, features = all.genes)\n  \n  pbmc &lt;- RunPCA(pbmc)\n  pbmc &lt;- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- factor(clusters.list)\n  \n  pbmc &lt;- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE,test.use = \"bimod\" )\n  \n  \n  \n  n.genes.DEA &lt;- sum(pbmc.markers$p_val_adj &lt; 0.05)\n  \n  print(n.genes.DEA)\n  \n  #write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n}\n\nSeurat.DEAScTransform &lt;- function(dataSet,clusters.list, project, dirOut#,percentage\n                       ){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet,\n                             project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n\n  # store mitochondrial percentage in object meta data\n  pbmc &lt;- PercentageFeatureSet(pbmc, pattern = \"^mt-\", col.name = \"percent.mt\")\n\n# run sctransform\n  pbmc &lt;- SCTransform(pbmc, vars.to.regress = \"percent.mt\", verbose = FALSE)\n\n  \n  pbmc &lt;- RunPCA(pbmc)\n  pbmc &lt;- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- factor(clusters.list)\n  \n  pbmc &lt;- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE)\n  \n  \n  \n  n.genes.DEA &lt;- sum(pbmc.markers$p_val_adj &lt; 0.05)\n  \n  print(n.genes.DEA)\n  \n  #write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n}\n\n\n\n\nMonocle.DEA &lt;- function(dataSet,clusters.list,project, dirOut#,percentage\n                        ){\n  \n  cell_metadata = as.data.frame(clusters.list[colnames(dataSet)])\n  colnames(cell_metadata) &lt;- \"Clusters\"\n  cds &lt;- new_cell_data_set(dataSet[rowSums(dataSet) &gt; 3,],\n                         cell_metadata = cell_metadata\n                         )\n  colData(cds)$cluster &lt;- clusters.list[rownames(colData(cds))]\n\n  #cds &lt;- preprocess_cds(cds, num_dim = 100)\n  #cds &lt;- reduce_dimension(cds)\n  #cds &lt;- cluster_cells(cds, resolution=1e-5)\n  marker_test_res &lt;- top_markers(cds, \n                                 group_cells_by=\"Clusters\", \n                                 genes_to_test_per_group = dim(cds)[1],\n                                  cores=10)\n  \n  # de_results &lt;- fit_models(cds,model_formula_str = \" ~ cluster\",cores = 10,verbose = T)\n  # fit_coefs &lt;- coefficient_table(de_results)\n  # \n  # fit_coefs &lt;- fit_coefs %&gt;% filter(grepl(\"cluster\",term))\n  # fit_coefs &lt;- as.data.frame(fit_coefs)\n  #write.csv(as.data.frame(fit_coefs[,c(\"num_cells_expressed\" ,\"gene_id\",\"p_value\",\"q_value\")]), file = paste0(dirOut,project,\"_de_genes_Monocle_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=sum(marker_test_res$marker_test_q_value &lt; 0.05, na.rm = T),\n              \"marker_test_res\"= marker_test_res\n              ))\n}\n\n\nScamPy.DEA &lt;- function(dataSet,\n                       clusters.list, \n                       project, \n                       dirOut,\n                       percentage){\n  pbmc &lt;- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  \n  pbmc@meta.data$TestCl &lt;- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl &lt;- clusters.list\n  \n  exprs &lt;- pbmc@assays$RNA$counts\n  \n  meta &lt;- pbmc[[]]\n  #feature_meta &lt;- GetAssay(pbmc)[[]]\n  tmp &lt;- as.data.frame(matrix(data = NA, \n                              ncol = 1, \n                              nrow = nrow(pbmc@assays$RNA$counts)))\n  rownames(tmp) &lt;- rownames(pbmc@assays$RNA$counts)\n  \n  feature_meta &lt;- tmp\n  #embedding &lt;- Embeddings(pbmc, \"umap\")\n  \n  Sys.setenv(RETICULATE_PYTHON = \"../../../bin/python3\")\n  py &lt;- import(\"sys\")\n  \n  source_python(\"src/scanpyFDR.py\")\n  scanpyFDR(exprs, \n                   meta, \n                   feature_meta, \n                   \"mt\", \n                   dirOut, \n                   project)\n\n  out &lt;- read.csv(file = paste0(dirOut,\n                                project,\n                                \"_Scampy_DEA_all_genes.csv\"\n                               ),\n                  header = T,\n                  row.names = 1)\n\n  gc()\n\n  return(out)\n}"
  },
  {
    "objectID": "FDR_analisys.html#cluster-gene-enrichment",
    "href": "FDR_analisys.html#cluster-gene-enrichment",
    "title": "FDR analysis - define DE genes",
    "section": "Cluster Gene Enrichment",
    "text": "Cluster Gene Enrichment\n\ndatasets_csv &lt;- read.csv(file.path(dataSetDir,\"Cells_Usage_DataFrame.csv\"),\n                         row.names = 1\n                        ) \n\ndatasets_csv\n\n                      Group\n1      2_Clusters_even_near\n2      2_Clusters_even_near\n3      2_Clusters_even_near\n4    2_Clusters_even_medium\n5    2_Clusters_even_medium\n6    2_Clusters_even_medium\n7       2_Clusters_even_far\n8       2_Clusters_even_far\n9       2_Clusters_even_far\n10   2_Clusters_uneven_near\n11   2_Clusters_uneven_near\n12   2_Clusters_uneven_near\n13 2_Clusters_uneven_medium\n14 2_Clusters_uneven_medium\n15 2_Clusters_uneven_medium\n16    2_Clusters_uneven_far\n17    2_Clusters_uneven_far\n18    2_Clusters_uneven_far\n19          3_Clusters_even\n20          3_Clusters_even\n21          3_Clusters_even\n22        3_Clusters_uneven\n23        3_Clusters_uneven\n24        3_Clusters_uneven\n25        5_Clusters_uneven\n26        5_Clusters_uneven\n27        5_Clusters_uneven\n                                                  Collection E13.5.432\n1                                      E13.5-434_+_E15.0-428         0\n2                                      E15.0-432_+_E13.5-432       536\n3                                      E15.0-508_+_E15.0-509         0\n4                                      E13.5-187_+_E13.5-184         0\n5                                      E15.0-434_+_E17.5-516         0\n6                                      E15.0-437_+_E15.0-508         0\n7                                      E17.5-516_+_E13.5-187         0\n8                                      E15.0-510_+_E13.5-437         0\n9                                      E15.0-509_+_E13.5-184         0\n10                                     E13.5-434_+_E15.0-428         0\n11                                     E15.0-432_+_E13.5-432        66\n12                                     E15.0-508_+_E15.0-509         0\n13                                     E13.5-187_+_E13.5-184         0\n14                                     E15.0-434_+_E17.5-516         0\n15                                     E15.0-437_+_E15.0-508         0\n16                                     E17.5-516_+_E13.5-187         0\n17                                     E15.0-510_+_E13.5-437         0\n18                                     E15.0-509_+_E13.5-184         0\n19                         E15.0-437_+_E13.5-510_+_E13.5-437         0\n20                         E17.5-505_+_E17.5-516_+_E13.5-437         0\n21                         E15.0-510_+_E15.0-428_+_E13.5-510         0\n22                         E15.0-428_+_E13.5-434_+_E15.0-510         0\n23                         E13.5-187_+_E13.5-432_+_E15.0-432       168\n24                         E15.0-509_+_E13.5-184_+_E15.0-508         0\n25 E13.5-510_+_E15.0-437_+_E15.0-510_+_E13.5-432_+_E13.5-437       518\n26 E15.0-428_+_E13.5-434_+_E15.0-434_+_E17.5-505_+_E13.5-184         0\n27 E13.5-432_+_E15.0-509_+_E15.0-432_+_E13.5-187_+_E15.0-508       440\n   E13.5.187 E13.5.434 E13.5.184 E13.5.437 E13.5.510 E15.0.432 E15.0.509\n1          0       318         0         0         0         0         0\n2          0         0         0         0         0       536         0\n3          0         0         0         0         0         0       397\n4        292         0       292         0         0         0         0\n5          0         0         0         0         0         0         0\n6          0         0         0         0         0         0         0\n7        297         0         0         0         0         0         0\n8          0         0         0       259         0         0         0\n9          0         0       292         0         0         0       292\n10         0       326         0         0         0         0         0\n11         0         0         0         0         0       586         0\n12         0         0         0         0         0         0       402\n13       334         0        38         0         0         0         0\n14         0         0         0         0         0         0         0\n15         0         0         0         0         0         0         0\n16       334         0         0         0         0         0         0\n17         0         0         0        45         0         0         0\n18         0         0        45         0         0         0       402\n19         0         0         0       248       248         0         0\n20         0         0         0       203         0         0         0\n21         0         0         0         0       248         0         0\n22         0       115         0         0         0         0         0\n23        84         0         0         0         0       586         0\n24         0         0        58         0         0         0       402\n25         0         0         0       259        65         0         0\n26         0       326       163         0         0         0         0\n27        74         0         0         0         0       586       293\n   E15.0.510 E15.0.508 E15.0.428 E15.0.434 E15.0.437 E17.5.516 E17.5.505\n1          0         0       318         0         0         0         0\n2          0         0         0         0         0         0         0\n3          0       397         0         0         0         0         0\n4          0         0         0         0         0         0         0\n5          0         0         0       273         0       273         0\n6          0       258         0         0       258         0         0\n7          0         0         0         0         0       297         0\n8        259         0         0         0         0         0         0\n9          0         0         0         0         0         0         0\n10         0         0        37         0         0         0         0\n11         0         0         0         0         0         0         0\n12         0        45         0         0         0         0         0\n13         0         0         0         0         0         0         0\n14         0         0         0        33         0       297         0\n15         0       397         0         0        45         0         0\n16         0         0         0         0         0        38         0\n17       402         0         0         0         0         0         0\n18         0         0         0         0         0         0         0\n19         0         0         0         0       248         0         0\n20         0         0         0         0         0       203       203\n21       248         0       248         0         0         0         0\n22       402         0        58         0         0         0         0\n23         0         0         0         0         0         0         0\n24         0       115         0         0         0         0         0\n25       389         0         0         0        65         0         0\n26         0         0       245        41         0         0        41\n27         0        74         0         0         0         0         0\n\n\n\nDEA genes for COTAN\n\nfor (ind in 1:dim(datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(datasets_csv$Group[ind],\"_\",datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"bonferroni\")\n\n  df.genes &lt;- deaCOTAN[rowMin(as.matrix(pvalCOTAN)) &lt; 0.05,]\n  \n  write.csv(df.genes,file.path(dirOut,paste0(file.code,\"COTAN_DEA_genes.csv\")))\n  \n  }\n\n\n\nDEA genes for Seurat\n\nfor (ind in 1:dim(datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(datasets_csv$Group[ind],\"_\",datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusters &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[1]]\n  deaSeurat &lt;- Seurat.DEA(getRawData(dataset),\n                          clusters.list = clusters,\n                          project = file.code,\n                          dirOut = dirOut)\n  write.csv(deaSeurat$markers,\n          file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")))\n}\n\n\n\nDEA genes for Seurat scTransform\n\nfor (ind in 1:dim(datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(datasets_csv$Group[ind],\"_\",datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusters &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[1]]\n  deaSeurat &lt;- Seurat.DEAScTransform(getRawData(dataset),\n                          clusters.list = clusters,\n                          project = file.code,\n                          dirOut = dirOut)\n  write.csv(deaSeurat$markers,\n          file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")))\n}\n\n\n\nDEA genes for Seurat test: bimod\n\nfor (ind in 1:dim(datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(datasets_csv$Group[ind],\"_\",datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusters &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[1]]\n  deaSeurat &lt;- Seurat.DEA.bimod(getRawData(dataset),\n                          clusters.list = clusters,\n                          project = file.code,\n                          dirOut = dirOut)\n  write.csv(deaSeurat$markers,\n          file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")))\n}\n\n\n\nDEA from Monocle\n\nfor (ind in 1:dim(datasets_csv)[1]) {\n  file.code &lt;- paste0(datasets_csv$Group[ind],\"_\",datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  print(file.code)\n  clusters &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[1]]\n  \n  deaMonocle &lt;- Monocle.DEA(dataSet = getRawData(dataset),\n                          clusters.list = clusters,\n                          project = file.code,\n                          dirOut = dirOut)\n  \n  # deaMonocleOut &lt;- deaMonocle$fit_coefs[,c(\"num_cells_expressed\", \n  #                                         \"gene_id\",\"term\",\"estimate\",\n  #                                         \"std_err\", \"test_val\",\"p_value\", \n  #                                         \"normalized_effect\",\"q_value\")]\n  \n  \n  write.csv(deaMonocle$marker_test_res,\n          file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\"))) \n  \n  #rm(deaMonocleOut)\n  rm(deaMonocle)\n  gc()\n}\n\n\n\nDEA from ScamPy\n\nfor (ind in 1:dim(datasets_csv)[1]) {\n  file.code &lt;- paste0(datasets_csv$Group[ind],\"_\",datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusters &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[1]]\n  \n  deaScamPy &lt;- ScamPy.DEA(dataSet = getRawData(dataset),\n                          clusters.list = clusters,\n                          project = file.code,\n                          dirOut = dirOut)\n  \n  write.csv(deaScamPy,\n          file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\"))) \n  \n}"
  },
  {
    "objectID": "FDR_analisys.html#footer",
    "href": "FDR_analisys.html#footer",
    "title": "FDR analysis - define DE genes",
    "section": "Footer",
    "text": "Footer\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] dplyr_1.1.2                 stringr_1.5.0              \n [3] reticulate_1.35.0           monocle3_1.3.4             \n [5] SingleCellExperiment_1.22.0 SummarizedExperiment_1.30.2\n [7] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1        \n [9] IRanges_2.34.1              S4Vectors_0.38.1           \n[11] MatrixGenerics_1.12.3       matrixStats_1.2.0          \n[13] Biobase_2.60.0              BiocGenerics_0.46.0        \n[15] Seurat_5.0.0                SeuratObject_5.0.0         \n[17] sp_2.1-1                    COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] doParallel_1.0.17         globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] dendextend_1.17.1         magrittr_2.0.3           \n [15] plotly_4.10.2             rmarkdown_2.24           \n [17] yaml_2.3.7                httpuv_1.6.11            \n [19] sctransform_0.4.1         spam_2.10-0              \n [21] askpass_1.2.0             spatstat.sparse_3.0-2    \n [23] minqa_1.2.5               cowplot_1.1.1            \n [25] pbapply_1.7-2             RColorBrewer_1.1-3       \n [27] zlibbioc_1.46.0           abind_1.4-5              \n [29] Rtsne_0.16                purrr_1.0.1              \n [31] RCurl_1.98-1.12           GenomeInfoDbData_1.2.10  \n [33] circlize_0.4.15           ggrepel_0.9.3            \n [35] irlba_2.3.5.1             listenv_0.9.0            \n [37] spatstat.utils_3.0-3      terra_1.7-39             \n [39] umap_0.2.10.0             goftest_1.2-3            \n [41] RSpectra_0.16-1           spatstat.random_3.2-1    \n [43] dqrng_0.3.0               fitdistrplus_1.1-11      \n [45] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [47] leiden_0.4.3              codetools_0.2-19         \n [49] DelayedArray_0.26.7       tidyselect_1.2.0         \n [51] shape_1.4.6               lme4_1.1-34              \n [53] ScaledMatrix_1.8.1        viridis_0.6.4            \n [55] spatstat.explore_3.2-1    jsonlite_1.8.7           \n [57] GetoptLong_1.0.5          ellipsis_0.3.2           \n [59] progressr_0.14.0          ggridges_0.5.4           \n [61] survival_3.5-7            iterators_1.0.14         \n [63] foreach_1.5.2             tools_4.3.2              \n [65] ica_1.0-3                 Rcpp_1.0.11              \n [67] glue_1.7.0                gridExtra_2.3            \n [69] xfun_0.39                 ggthemes_5.0.0           \n [71] withr_3.0.0               fastmap_1.1.1            \n [73] boot_1.3-28               fansi_1.0.4              \n [75] openssl_2.1.0             digest_0.6.33            \n [77] rsvd_1.0.5                parallelDist_0.2.6       \n [79] R6_2.5.1                  mime_0.12                \n [81] colorspace_2.1-0          scattermore_1.2          \n [83] tensor_1.5                spatstat.data_3.0-1      \n [85] utf8_1.2.3                tidyr_1.3.0              \n [87] generics_0.1.3            data.table_1.15.0        \n [89] httr_1.4.6                htmlwidgets_1.6.2        \n [91] S4Arrays_1.2.0            uwot_0.1.16              \n [93] pkgconfig_2.0.3           gtable_0.3.3             \n [95] ComplexHeatmap_2.16.0     lmtest_0.9-40            \n [97] XVector_0.40.0            htmltools_0.5.7          \n [99] dotCall64_1.1-0           clue_0.3-64              \n[101] scales_1.3.0              png_0.1-8                \n[103] knitr_1.43                rstudioapi_0.15.0        \n[105] reshape2_1.4.4            rjson_0.2.21             \n[107] nloptr_2.0.3              nlme_3.1-163             \n[109] zoo_1.8-12                GlobalOptions_0.1.2      \n[111] KernSmooth_2.23-22        parallel_4.3.2           \n[113] miniUI_0.1.1.1            RcppZiggurat_0.1.6       \n[115] pillar_1.9.0              grid_4.3.2               \n[117] vctrs_0.6.3               RANN_2.6.1               \n[119] promises_1.2.0.1          BiocSingular_1.16.0      \n[121] beachmat_2.16.0           xtable_1.8-4             \n[123] cluster_2.1.6             evaluate_0.21            \n[125] zeallot_0.1.0             cli_3.6.1                \n[127] compiler_4.3.2            rlang_1.1.1              \n[129] crayon_1.5.2              future.apply_1.11.0      \n[131] plyr_1.8.8                stringi_1.8.1            \n[133] viridisLite_0.4.2         deldir_2.0-2             \n[135] BiocParallel_1.34.2       assertthat_0.2.1         \n[137] munsell_0.5.0             lazyeval_0.2.2           \n[139] spatstat.geom_3.2-4       PCAtools_2.14.0          \n[141] Matrix_1.6-3              RcppHNSW_0.6.0           \n[143] patchwork_1.2.0           sparseMatrixStats_1.12.2 \n[145] future_1.33.0             ggplot2_3.4.2            \n[147] shiny_1.8.0               ROCR_1.0-11              \n[149] Rfast_2.1.0               igraph_1.6.0             \n[151] RcppParallel_5.1.7"
  },
  {
    "objectID": "FDR_analisysResults5.html",
    "href": "FDR_analisysResults5.html",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggpubr)\nlibrary(ggplot2)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\""
  },
  {
    "objectID": "FDR_analisysResults5.html#preamble",
    "href": "FDR_analisysResults5.html#preamble",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggpubr)\nlibrary(ggplot2)\n\ndirOut &lt;- \"Results/FDR/\"\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- \"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\""
  },
  {
    "objectID": "FDR_analisysResults5.html#dataset-composition",
    "href": "FDR_analisysResults5.html#dataset-composition",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "Dataset composition",
    "text": "Dataset composition\n\ndatasets_csv &lt;- read.csv(file.path(dataSetDir,\"Cells_Usage_DataFrame.csv\"),\n                         row.names = 1\n                        ) \n\ndatasets_csv[1:3,]\n\n                 Group            Collection E13.5.432 E13.5.187 E13.5.434\n1 2_Clusters_even_near E13.5-434_+_E15.0-428         0         0       318\n2 2_Clusters_even_near E15.0-432_+_E13.5-432       536         0         0\n3 2_Clusters_even_near E15.0-508_+_E15.0-509         0         0         0\n  E13.5.184 E13.5.437 E13.5.510 E15.0.432 E15.0.509 E15.0.510 E15.0.508\n1         0         0         0         0         0         0         0\n2         0         0         0       536         0         0         0\n3         0         0         0         0       397         0       397\n  E15.0.428 E15.0.434 E15.0.437 E17.5.516 E17.5.505\n1       318         0         0         0         0\n2         0         0         0         0         0\n3         0         0         0         0         0\n\n\n\nDefine which genes are expressed\nFor each data set we need to define, independently from the DEA methods, which genes are specific for each cluster. So we need to define first which genes are expressed and which are not expressed. To do so we can take advantage from the fact that we have the original clusters from which the cells were sampled to create the artificial datasets. So looking to the original cluster we define as expressed all genes present in at least the 5% of cells and we define as not expressed the genes completely absent or expressed in less than 5% of cells.\nSince these two thresholds can have a big influence on the tools performances we will test also others in other pages.\n\nfile.presence &lt;- readRDS(\"Data/MouseCortexFromLoom/FDR/Results/GenePresence_PerCluster.RDS\")\n\nfor (file in list.files(\"Data/MouseCortexFromLoom/SingleClusterRawData/\")) {\n#  print(file)\n  Code &lt;- str_split(file,pattern = \"_\",simplify = T)[1]\n  Time &lt;- str_split(Code,pattern = \"e\",simplify = T)[2]\n  Cluster &lt;- str_split(Code,pattern = \"e\",simplify = T)[1]\n  Cluster &lt;- str_remove(Cluster,pattern = \"Cl\")\n  Cluster &lt;- paste0(\"E\",Time,\"-\",Cluster)\n  file.presence[,Cluster] &lt;- \"Absent\"\n  dataset.cl &lt;- readRDS(file.path(\"Data/MouseCortexFromLoom/SingleClusterRawData/\",\n                                         file))\n  number.cell.expressing &lt;- rowSums(dataset.cl &gt; 0)\n  AbsentThreshold &lt;- round(0.05*dim(dataset.cl)[2],digits = 0)\n  PresenceThreshold &lt;- round(0.05*dim(dataset.cl)[2],digits = 0)\n  file.presence[names(number.cell.expressing[number.cell.expressing &gt; AbsentThreshold]),Cluster] &lt;- \"Uncertain\" \n  \n  file.presence[names(number.cell.expressing[number.cell.expressing &gt;= PresenceThreshold]),Cluster] &lt;- \"Present\"\n  print(Cluster)\n  print(table(file.presence[,Cluster]))\n  \n  }\n\n[1] \"E13.5-184\"\n\n Absent Present \n   6536    8159 \n[1] \"E13.5-187\"\n\n Absent Present \n   5809    8886 \n[1] \"E15.0-428\"\n\n Absent Present \n   7304    7391 \n[1] \"E13.5-432\"\n\n Absent Present \n   6753    7942 \n[1] \"E15.0-432\"\n\n Absent Present \n   6873    7822 \n[1] \"E13.5-434\"\n\n Absent Present \n   7004    7691 \n[1] \"E15.0-434\"\n\n Absent Present \n   7380    7315 \n[1] \"E13.5-437\"\n\n Absent Present \n   6825    7870 \n[1] \"E15.0-437\"\n\n Absent Present \n   6891    7804 \n[1] \"E17.5-505\"\n\n Absent Present \n   6870    7825 \n[1] \"E15.0-508\"\n\n Absent Present \n   6520    8175 \n[1] \"E15.0-509\"\n\n Absent Present \n   6376    8319 \n[1] \"E13.5-510\"\n\n Absent Present \n   5790    8905 \n[1] \"E15.0-510\"\n\n Absent Present \n   5956    8739 \n[1] \"E17.5-516\"\n\n Absent Present \n   6777    7918"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_even_near",
    "href": "FDR_analisysResults5.html#clusters_even_near",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "2_Clusters_even_near",
    "text": "2_Clusters_even_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_near\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set             set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                     &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_even_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_even_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_even_near          1\n4 Lamc1 E15.0-428 TRUE  2_Clusters_even_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_even_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_even_near          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 2320\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_even_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_even_nearPL &lt;- TwoClusters_even_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_even_nearPL"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_even_medium",
    "href": "FDR_analisysResults5.html#clusters_even_medium",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "2_Clusters_even_medium",
    "text": "2_Clusters_even_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_medium\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_even_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_even_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_even_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_even_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_even_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_even_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 4661\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_even_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_even_mediumPL &lt;- Two_Clusters_even_medium + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_even_mediumPL"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_even_far",
    "href": "FDR_analisysResults5.html#clusters_even_far",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "2_Clusters_even_far",
    "text": "2_Clusters_even_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_far\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set            set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                    &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_even_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_even_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_even_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_even_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_even_far          1\n6 Lama1 E13.5-187 TRUE  2_Clusters_even_far          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 7189\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_even_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_even_farPL &lt;- Two_Clusters_even_far + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_even_farPL"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_uneven_near",
    "href": "FDR_analisysResults5.html#clusters_uneven_near",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "2_Clusters_uneven_near",
    "text": "2_Clusters_uneven_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_near\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_uneven_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_uneven_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n4 Lamc1 E15.0-428 TRUE  2_Clusters_uneven_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_uneven_near          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 2320\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\nplot(roc_resultSeurat)\n\n\n\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_nearPL &lt;- Two_Clusters_uneven_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwo_Clusters_uneven_nearPL"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_uneven_medium",
    "href": "FDR_analisysResults5.html#clusters_uneven_medium",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "2_Clusters_uneven_medium",
    "text": "2_Clusters_uneven_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_medium\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set                 set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                         &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 4661\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_mediumPL &lt;- Two_Clusters_uneven_medium + xlab(\"FPR\") + ylab(\"TPR\")\n\nTwo_Clusters_uneven_mediumPL"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_uneven_far",
    "href": "FDR_analisysResults5.html#clusters_uneven_far",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "2_Clusters_uneven_far",
    "text": "2_Clusters_uneven_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_far\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set              set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                      &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_uneven_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_uneven_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n6 Lama1 E13.5-187 TRUE  2_Clusters_uneven_far          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 7189\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwo_Clusters_uneven_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwo_Clusters_uneven_farPL &lt;- Two_Clusters_uneven_far + xlab(\"FPR\") + ylab(\"TPR\")\n\nTwo_Clusters_uneven_farPL"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_even",
    "href": "FDR_analisysResults5.html#clusters_even",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "3_Clusters_even",
    "text": "3_Clusters_even\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_even\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set        set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                &lt;int&gt;\n1 Neil2 E15.0-437 FALSE 3_Clusters_even          1\n2 Neil2 E13.5-510 FALSE 3_Clusters_even          1\n3 Neil2 E13.5-437 FALSE 3_Clusters_even          1\n4 Lamc1 E15.0-437 FALSE 3_Clusters_even          1\n5 Lamc1 E13.5-510 TRUE  3_Clusters_even          1\n6 Lamc1 E13.5-437 TRUE  3_Clusters_even          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 11529\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E17.5-516\"\n[1] \"E13.5-437\"\n[1] \"E17.5-505\"\n[1] \"E15.0-510\"\n[1] \"E15.0-428\"\n[1] \"E13.5-510\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThree_Clusters_even &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThree_Clusters_evenPL &lt;- Three_Clusters_even + \n  xlab(\"FPR\") + ylab(\"TPR\")+theme(legend.position=\"none\")\nThree_Clusters_even"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_uneven",
    "href": "FDR_analisysResults5.html#clusters_uneven",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "3_Clusters_uneven",
    "text": "3_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_uneven\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E15.0-428 FALSE 3_Clusters_uneven          1\n2 Neil2 E13.5-434 FALSE 3_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 3_Clusters_uneven          1\n4 Lamc1 E15.0-428 TRUE  3_Clusters_uneven          1\n5 Lamc1 E13.5-434 FALSE 3_Clusters_uneven          1\n6 Lamc1 E15.0-510 TRUE  3_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 11195\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E15.0-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E13.5-187\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-184\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThree_Clusters_uneven &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThree_Clusters_unevenPL &lt;- Three_Clusters_uneven + xlab(\"FPR\") + ylab(\"TPR\")+theme(legend.position=\"none\")\n\nThree_Clusters_uneven"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters_uneven-1",
    "href": "FDR_analisysResults5.html#clusters_uneven-1",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "5_Clusters_uneven",
    "text": "5_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"5_Clusters_uneven\",] \n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  file.presence.subset &lt;- file.presence[,clusters]\n  \n  \n  #file.presence.subset &lt;- as.matrix(file.presence.subset)\n  \n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(file.presence.subset),\n                                       ncol = ncol(file.presence.subset)))\n  rownames(ground_truth) &lt;- rownames(file.presence.subset)\n  colnames(ground_truth) &lt;- colnames(file.presence.subset)\n  \n  ground_truth[file.presence.subset == \"Absent\"] &lt;- 0\n  ground_truth[file.presence.subset == \"Present\"] &lt;- 1\n  ground_truth[file.presence.subset == \"Uncertain\"] &lt;- 0.6\n  \n  file.presence.subset &lt;- ground_truth\n  \n  for (col in 1:ncol(ground_truth)) {\n    ground_truth[,col] &lt;- FALSE  \n    ground_truth[file.presence.subset[,col] == 1 & rowMeans(file.presence.subset[,-col,drop = FALSE]) &lt; 0.555  ,col] &lt;- TRUE\n    }\n  \n  ground_truth$genes &lt;- rownames(ground_truth) \n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind,1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n  \n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E13.5-510 FALSE 5_Clusters_uneven          1\n2 Neil2 E15.0-437 FALSE 5_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 5_Clusters_uneven          1\n4 Neil2 E13.5-432 FALSE 5_Clusters_uneven          1\n5 Neil2 E13.5-437 FALSE 5_Clusters_uneven          1\n6 Lamc1 E13.5-510 FALSE 5_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes)) \n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 13080\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-432\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E13.5-184\"\n[1] \"E15.0-434\"\n[1] \"E17.5-505\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-187\"\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nFive_Clusters &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,                  Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\n \nFive_Clusters_unevenPL &lt;- Five_Clusters + xlab(\"FPR\") + ylab(\"TPR\")\n\nFive_Clusters_unevenPL"
  },
  {
    "objectID": "FDR_analisysResults5.html#clusters-2",
    "href": "FDR_analisysResults5.html#clusters-2",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "2 Clusters",
    "text": "2 Clusters\n\nggarrange(TwoClusters_even_nearPL,Two_Clusters_even_mediumPL, Two_Clusters_even_farPL,Two_Clusters_uneven_nearPL, Two_Clusters_uneven_mediumPL,Two_Clusters_uneven_farPL,\n          labels = c(\"Even_Near\", \"Even_Medium\", \"Even_Far\", \"Uneven_Near\",\"Uneven_Medium\",\"Uneven_Far\"),\n          ncol = 3, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analisysResults5.html#and-5-clusters",
    "href": "FDR_analisysResults5.html#and-5-clusters",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "3 and 5 Clusters",
    "text": "3 and 5 Clusters\n\nggarrange(Three_Clusters_evenPL,Three_Clusters_unevenPL, NULL, Five_Clusters_unevenPL,\n          labels = c(\"3_Even\", \"3_Uneven\", \"\", \"5_Uneven\"),\n          ncol = 2, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analisysResults5.html#footer",
    "href": "FDR_analisysResults5.html#footer",
    "title": "FDR analysis - Results - thresholds true 5%",
    "section": "Footer",
    "text": "Footer\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ggpubr_0.6.0                ggplot2_3.4.2              \n [3] tidyr_1.3.0                 dplyr_1.1.2                \n [5] stringr_1.5.0               reticulate_1.35.0          \n [7] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [9] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n[11] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n[13] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n[15] matrixStats_1.2.0           Biobase_2.60.0             \n[17] BiocGenerics_0.46.0         Seurat_5.0.0               \n[19] SeuratObject_5.0.0          sp_2.1-1                   \n[21] pROC_1.18.4                 COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] rstatix_0.7.2             doParallel_1.0.17        \n [11] globals_0.16.2            lattice_0.22-5           \n [13] MASS_7.3-60               backports_1.4.1          \n [15] dendextend_1.17.1         magrittr_2.0.3           \n [17] plotly_4.10.2             rmarkdown_2.24           \n [19] yaml_2.3.7                httpuv_1.6.11            \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] minqa_1.2.5               cowplot_1.1.1            \n [27] pbapply_1.7-2             RColorBrewer_1.1-3       \n [29] zlibbioc_1.46.0           abind_1.4-5              \n [31] Rtsne_0.16                purrr_1.0.1              \n [33] RCurl_1.98-1.12           GenomeInfoDbData_1.2.10  \n [35] circlize_0.4.15           ggrepel_0.9.3            \n [37] irlba_2.3.5.1             listenv_0.9.0            \n [39] spatstat.utils_3.0-3      terra_1.7-39             \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       tidyselect_1.2.0         \n [53] shape_1.4.6               farver_2.1.1             \n [55] lme4_1.1-34               ScaledMatrix_1.8.1       \n [57] viridis_0.6.4             spatstat.explore_3.2-1   \n [59] jsonlite_1.8.7            GetoptLong_1.0.5         \n [61] ellipsis_0.3.2            progressr_0.14.0         \n [63] ggridges_0.5.4            survival_3.5-7           \n [65] iterators_1.0.14          foreach_1.5.2            \n [67] tools_4.3.2               ica_1.0-3                \n [69] Rcpp_1.0.11               glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] scattermore_1.2           tensor_1.5               \n [87] spatstat.data_3.0-1       utf8_1.2.3               \n [89] generics_0.1.3            data.table_1.15.0        \n [91] httr_1.4.6                htmlwidgets_1.6.2        \n [93] S4Arrays_1.2.0            uwot_0.1.16              \n [95] pkgconfig_2.0.3           gtable_0.3.3             \n [97] ComplexHeatmap_2.16.0     lmtest_0.9-40            \n [99] XVector_0.40.0            htmltools_0.5.7          \n[101] carData_3.0-5             dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] nlme_3.1-163              zoo_1.8-12               \n[113] GlobalOptions_0.1.2       KernSmooth_2.23-22       \n[115] parallel_4.3.2            miniUI_0.1.1.1           \n[117] RcppZiggurat_0.1.6        pillar_1.9.0             \n[119] grid_4.3.2                vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] car_3.1-2                 BiocSingular_1.16.0      \n[125] beachmat_2.16.0           xtable_1.8-4             \n[127] cluster_2.1.6             evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              ggsignif_0.6.4           \n[135] future.apply_1.11.0       labeling_0.4.2           \n[137] plyr_1.8.8                stringi_1.8.1            \n[139] viridisLite_0.4.2         deldir_2.0-2             \n[141] BiocParallel_1.34.2       assertthat_0.2.1         \n[143] munsell_0.5.0             lazyeval_0.2.2           \n[145] spatstat.geom_3.2-4       PCAtools_2.14.0          \n[147] Matrix_1.6-3              RcppHNSW_0.6.0           \n[149] patchwork_1.2.0           sparseMatrixStats_1.12.2 \n[151] future_1.33.0             shiny_1.8.0              \n[153] ROCR_1.0-11               Rfast_2.1.0              \n[155] broom_1.0.5               igraph_1.6.0             \n[157] RcppParallel_5.1.7"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html",
    "href": "FDR_analysisResultsLFC.html",
    "title": "Results - Log Fold Change",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\n#library(Seurat)\n#library(monocle3)\n#library(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\ndirOut &lt;- file.path(\".\", \"Results/FDR/\")\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- file.path(\"Data/MouseCortexFromLoom/FDR/\", \"MergedClusters_For_FDR\")"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#preamble",
    "href": "FDR_analysisResultsLFC.html#preamble",
    "title": "Results - Log Fold Change",
    "section": "",
    "text": "library(COTAN)\nlibrary(pROC)\noptions(parallelly.fork.enable = TRUE)\n#library(Seurat)\n#library(monocle3)\n#library(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\ndirOut &lt;- file.path(\".\", \"Results/FDR/\")\nif (!dir.exists(dirOut)) {\n  dir.create(dirOut)\n}\n\ndataSetDir &lt;- file.path(\"Data/MouseCortexFromLoom/FDR/\", \"MergedClusters_For_FDR\")"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#dataset-composition",
    "href": "FDR_analysisResultsLFC.html#dataset-composition",
    "title": "Results - Log Fold Change",
    "section": "Dataset composition",
    "text": "Dataset composition\n\ndatasets_csv &lt;- read.csv(file.path(dataSetDir,\"Cells_Usage_DataFrame.csv\"),\n                         row.names = 1, header = TRUE, quote = '\"'\n                        ) \n\ndatasets_csv[1:10, ]\n\n                    Group            Collection E13.5.432 E13.5.187 E13.5.434\n1    2_Clusters_even_near E13.5-434_+_E15.0-428         0         0       318\n2    2_Clusters_even_near E15.0-432_+_E13.5-432       536         0         0\n3    2_Clusters_even_near E15.0-508_+_E15.0-509         0         0         0\n4  2_Clusters_even_medium E13.5-187_+_E13.5-184         0       292         0\n5  2_Clusters_even_medium E15.0-434_+_E17.5-516         0         0         0\n6  2_Clusters_even_medium E15.0-437_+_E15.0-508         0         0         0\n7     2_Clusters_even_far E17.5-516_+_E13.5-187         0       297         0\n8     2_Clusters_even_far E15.0-510_+_E13.5-437         0         0         0\n9     2_Clusters_even_far E15.0-509_+_E13.5-184         0         0         0\n10 2_Clusters_uneven_near E13.5-434_+_E15.0-428         0         0       326\n   E13.5.184 E13.5.437 E13.5.510 E15.0.432 E15.0.509 E15.0.510 E15.0.508\n1          0         0         0         0         0         0         0\n2          0         0         0       536         0         0         0\n3          0         0         0         0       397         0       397\n4        292         0         0         0         0         0         0\n5          0         0         0         0         0         0         0\n6          0         0         0         0         0         0       258\n7          0         0         0         0         0         0         0\n8          0       259         0         0         0       259         0\n9        292         0         0         0       292         0         0\n10         0         0         0         0         0         0         0\n   E15.0.428 E15.0.434 E15.0.437 E17.5.516 E17.5.505\n1        318         0         0         0         0\n2          0         0         0         0         0\n3          0         0         0         0         0\n4          0         0         0         0         0\n5          0       273         0       273         0\n6          0         0       258         0         0\n7          0         0         0       297         0\n8          0         0         0         0         0\n9          0         0         0         0         0\n10        37         0         0         0         0\n\n\n\nDefine which genes are expressed\nFor each data set we need to define, independently from the DEA methods, which genes are specific for each cluster. So we need to define first which genes are expressed and which are not expressed. To do so we can take advantage from the fact that we have the original clusters from which the cells were sampled to create the artificial datasets. So looking to the original cluster we define as expressed all genes present for which there are at least 2 reads every 10 cells. We define as enriched for a cluster the genes that are present and have at least 3 times as many average reads as the average reads outside the cluster.\n\nreadsLogMeansPerCluster &lt;- readRDS(file.path(dirOut, \"readsLogAverageCount_PerCluster.RDS\"))\n\nthresholdLFC &lt;- log10(3.0) # presence if 3 times more reads on average\nthresholdLFM &lt;- log10(10000 * 2 / 10) # 2 reads each 10 cells\n\n10^thresholdLFC\n\n[1] 3\n\n10^(thresholdLFM-4)\n\n[1] 0.2"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_even_near",
    "href": "FDR_analysisResultsLFC.html#clusters_even_near",
    "title": "Results - Log Fold Change",
    "section": "2_Clusters_even_near",
    "text": "2_Clusters_even_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_near\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1] \n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set             set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                     &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_even_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_even_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_even_near          1\n4 Lamc1 E15.0-428 FALSE 2_Clusters_even_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_even_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_even_near          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 80\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_even_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_even_nearPL &lt;- TwoClusters_even_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_even_nearPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_even_medium",
    "href": "FDR_analysisResultsLFC.html#clusters_even_medium",
    "title": "Results - Log Fold Change",
    "section": "2_Clusters_even_medium",
    "text": "2_Clusters_even_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_medium\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_even_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_even_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_even_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_even_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_even_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_even_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 1559\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_even_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_even_mediumPL &lt;- TwoClusters_even_medium + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_even_mediumPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_even_far",
    "href": "FDR_analysisResultsLFC.html#clusters_even_far",
    "title": "Results - Log Fold Change",
    "section": "2_Clusters_even_far",
    "text": "2_Clusters_even_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_even_far\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set            set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                    &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_even_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_even_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_even_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_even_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_even_far          1\n6 Lama1 E13.5-187 FALSE 2_Clusters_even_far          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 4020\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_even_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_even_farPL &lt;- TwoClusters_even_far + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_even_farPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_uneven_near",
    "href": "FDR_analysisResultsLFC.html#clusters_uneven_near",
    "title": "Results - Log Fold Change",
    "section": "2_Clusters_uneven_near",
    "text": "2_Clusters_uneven_near\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_near\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set               set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Neil2 E13.5-434 FALSE 2_Clusters_uneven_near          1\n2 Neil2 E15.0-428 FALSE 2_Clusters_uneven_near          1\n3 Lamc1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n4 Lamc1 E15.0-428 FALSE 2_Clusters_uneven_near          1\n5 Lama1 E13.5-434 FALSE 2_Clusters_uneven_near          1\n6 Lama1 E15.0-428 FALSE 2_Clusters_uneven_near          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 80\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_uneven_near &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_uneven_nearPL &lt;- TwoClusters_uneven_near + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_uneven_nearPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_uneven_medium",
    "href": "FDR_analysisResultsLFC.html#clusters_uneven_medium",
    "title": "Results - Log Fold Change",
    "section": "2_Clusters_uneven_medium",
    "text": "2_Clusters_uneven_medium\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_medium\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set                 set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                         &lt;int&gt;\n1 Neil2 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n2 Neil2 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n3 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n4 Lamc1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n5 Lama1 E13.5-187 FALSE 2_Clusters_uneven_medium          1\n6 Lama1 E13.5-184 FALSE 2_Clusters_uneven_medium          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 1559\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E13.5-184\"\n[1] \"E17.5-516\"\n[1] \"E15.0-434\"\n[1] \"E15.0-508\"\n[1] \"E15.0-437\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_uneven_medium &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_uneven_mediumPL &lt;- TwoClusters_uneven_medium + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_uneven_mediumPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_uneven_far",
    "href": "FDR_analysisResultsLFC.html#clusters_uneven_far",
    "title": "Results - Log Fold Change",
    "section": "2_Clusters_uneven_far",
    "text": "2_Clusters_uneven_far\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"2_Clusters_uneven_far\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set              set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                      &lt;int&gt;\n1 Neil2 E17.5-516 FALSE 2_Clusters_uneven_far          1\n2 Neil2 E13.5-187 FALSE 2_Clusters_uneven_far          1\n3 Lamc1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n4 Lamc1 E13.5-187 FALSE 2_Clusters_uneven_far          1\n5 Lama1 E17.5-516 FALSE 2_Clusters_uneven_far          1\n6 Lama1 E13.5-187 FALSE 2_Clusters_uneven_far          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 4020\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-187\"\n[1] \"E17.5-516\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-509\"\n[1] \"E13.5-184\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nTwoClusters_uneven_far &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nTwoClusters_uneven_farPL &lt;- TwoClusters_uneven_far + xlab(\"FPR\") + ylab(\"TPR\")\nTwoClusters_uneven_farPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_even",
    "href": "FDR_analysisResultsLFC.html#clusters_even",
    "title": "Results - Log Fold Change",
    "section": "3_Clusters_even",
    "text": "3_Clusters_even\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_even\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set        set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                &lt;int&gt;\n1 Neil2 E15.0-437 FALSE 3_Clusters_even          1\n2 Neil2 E13.5-510 FALSE 3_Clusters_even          1\n3 Neil2 E13.5-437 FALSE 3_Clusters_even          1\n4 Lamc1 E15.0-437 FALSE 3_Clusters_even          1\n5 Lamc1 E13.5-510 FALSE 3_Clusters_even          1\n6 Lamc1 E13.5-437 FALSE 3_Clusters_even          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 2608\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E17.5-516\"\n[1] \"E13.5-437\"\n[1] \"E17.5-505\"\n[1] \"E15.0-510\"\n[1] \"E15.0-428\"\n[1] \"E13.5-510\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThreeClusters_even &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThreeClusters_evenPL &lt;- ThreeClusters_even + xlab(\"FPR\") + ylab(\"TPR\")\nThreeClusters_evenPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_uneven",
    "href": "FDR_analysisResultsLFC.html#clusters_uneven",
    "title": "Results - Log Fold Change",
    "section": "3_Clusters_uneven",
    "text": "3_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"3_Clusters_uneven\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E15.0-428 FALSE 3_Clusters_uneven          1\n2 Neil2 E13.5-434 FALSE 3_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 3_Clusters_uneven          1\n4 Lamc1 E15.0-428 FALSE 3_Clusters_uneven          1\n5 Lamc1 E13.5-434 FALSE 3_Clusters_uneven          1\n6 Lamc1 E15.0-510 FALSE 3_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 3293\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E15.0-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E13.5-187\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-184\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nThreeClusters_uneven &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nThreeClusters_unevenPL &lt;- ThreeClusters_uneven + xlab(\"FPR\") + ylab(\"TPR\")\nThreeClusters_unevenPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters_uneven-1",
    "href": "FDR_analysisResultsLFC.html#clusters_uneven-1",
    "title": "Results - Log Fold Change",
    "section": "5_Clusters_uneven",
    "text": "5_Clusters_uneven\n\nTrue vector\n\nsubset.datasets_csv &lt;-datasets_csv[datasets_csv$Group == \"5_Clusters_uneven\", ]\n\nground_truth_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  clusters &lt;- str_split(subset.datasets_csv$Collection[ind], pattern = \"_[+]_\", simplify = T)\n  \n  reads.LM.subset &lt;- readsLogMeansPerCluster[, clusters]\n  \n  ground_truth &lt;- as.data.frame(matrix(nrow = nrow(reads.LM.subset),\n                                       ncol = ncol(reads.LM.subset)))\n  rownames(ground_truth) &lt;- rownames(reads.LM.subset)\n  colnames(ground_truth) &lt;- colnames(reads.LM.subset)\n\n  for (col in 1:ncol(ground_truth)) {\n    # log fold change\n    ground_truth[, col] &lt;- reads.LM.subset[, col] - rowMeans(reads.LM.subset[, -col, drop = FALSE])\n    ground_truth[, col] &lt;- ground_truth[, col] &gt; thresholdLFC & reads.LM.subset[, col] &gt; thresholdLFM\n  }\n\n  ground_truth$genes &lt;- rownames(ground_truth)\n  ground_truth &lt;- pivot_longer(ground_truth,\n                               cols = 1:(ncol(ground_truth)-1),\n                               names_to = \"clusters\")\n  ground_truth$data_set &lt;- subset.datasets_csv[ind, 1]\n  ground_truth$set_number &lt;- ind \n  ground_truth_tot &lt;- rbind(ground_truth_tot, ground_truth)\n}\nground_truth_tot &lt;- ground_truth_tot[2:nrow(ground_truth_tot),]\n\nhead(ground_truth_tot)\n\n# A tibble: 6 × 5\n  genes clusters  value data_set          set_number\n  &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt; &lt;chr&gt;                  &lt;int&gt;\n1 Neil2 E13.5-510 FALSE 5_Clusters_uneven          1\n2 Neil2 E15.0-437 FALSE 5_Clusters_uneven          1\n3 Neil2 E15.0-510 FALSE 5_Clusters_uneven          1\n4 Neil2 E13.5-432 FALSE 5_Clusters_uneven          1\n5 Neil2 E13.5-437 FALSE 5_Clusters_uneven          1\n6 Lamc1 E13.5-510 FALSE 5_Clusters_uneven          1\n\n\n\nlength(unique(ground_truth_tot$genes))\n\n[1] 14695\n\nsum(ground_truth_tot$value)\n\n[1] 3653\n\n\n\n\nROC for COTAN\n\nonlyPositive.pVal.Cotan_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",\n                      subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  deaCOTAN &lt;- getClusterizationData(dataset,clName = \"mergedClusters\")[[2]]\n  pvalCOTAN &lt;- pValueFromDEA(deaCOTAN,\n              numCells = getNumCells(dataset),method = \"none\")\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.names &lt;- c(cl.names,\n                  str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1])\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  }\n  colnames(deaCOTAN) &lt;- cl.names\n  colnames(pvalCOTAN) &lt;- cl.names\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  onlyPositive.pVal.Cotan &lt;- pvalCOTAN\n\n    for (cl in cl.names) {\n    print(cl)\n    #temp.DEA.CotanSign &lt;- deaCOTAN[rownames(pvalCOTAN[pvalCOTAN[,cl] &lt; 0.05,]) ,]\n    onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl] &lt;-  1 #onlyPositive.pVal.Cotan[rownames(deaCOTAN[deaCOTAN[,cl] &lt; 0,]),cl]+1\n    }\n    \n    onlyPositive.pVal.Cotan$genes &lt;- rownames(onlyPositive.pVal.Cotan) \n    onlyPositive.pVal.Cotan &lt;- pivot_longer(onlyPositive.pVal.Cotan,\n                                            values_to = \"p_values\",\n                               cols = 1:(ncol(onlyPositive.pVal.Cotan)-1),\n                               names_to = \"clusters\")\n  onlyPositive.pVal.Cotan$data_set &lt;- subset.datasets_csv[ind,1]\n  onlyPositive.pVal.Cotan$set_number &lt;- ind \n  onlyPositive.pVal.Cotan_tot &lt;- rbind(onlyPositive.pVal.Cotan_tot, onlyPositive.pVal.Cotan)\n  \n  }\n\n[1] \"E13.5-432\"\n[1] \"E15.0-510\"\n[1] \"E13.5-437\"\n[1] \"E15.0-437\"\n[1] \"E13.5-510\"\n[1] \"E13.5-434\"\n[1] \"E15.0-428\"\n[1] \"E13.5-184\"\n[1] \"E15.0-434\"\n[1] \"E17.5-505\"\n[1] \"E15.0-432\"\n[1] \"E13.5-432\"\n[1] \"E15.0-509\"\n[1] \"E15.0-508\"\n[1] \"E13.5-187\"\n\n\n\nonlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[2:nrow(onlyPositive.pVal.Cotan_tot),]\n\nonlyPositive.pVal.Cotan_tot &lt;- merge.data.frame(onlyPositive.pVal.Cotan_tot,\n                                                ground_truth_tot,by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),all.x = T,all.y = F)\n\n#onlyPositive.pVal.Cotan_tot &lt;- onlyPositive.pVal.Cotan_tot[order(onlyPositive.pVal.Cotan_tot$p_values,\n #                                                                decreasing = F),]\n# df &lt;- as.data.frame(matrix(nrow = nrow(onlyPositive.pVal.Cotan_tot),ncol = 3)) \n# colnames(df) &lt;- c(\"TPR\",\"FPR\",\"Method\")\n# df$Method &lt;- \"COTAN\"\n# \n# Positive &lt;- sum(onlyPositive.pVal.Cotan_tot$value) \n# Negative &lt;- sum(!onlyPositive.pVal.Cotan_tot$value)\n# \n# for (i in 1:nrow(onlyPositive.pVal.Cotan_tot)) {\n#   df[i,\"TPR\"] &lt;- sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"])/Positive\n#   df[i,\"FPR\"] &lt;- (i-sum(onlyPositive.pVal.Cotan_tot[1:i,\"value\"]))/Negative\n  \n# Convert TRUE/FALSE to 1/0\nonlyPositive.pVal.Cotan_tot$value &lt;- as.numeric(onlyPositive.pVal.Cotan_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultCOTAN &lt;- roc(onlyPositive.pVal.Cotan_tot$value, 1 - onlyPositive.pVal.Cotan_tot$p_values)\n\n# Plot the ROC curve\n#plot(roc_resultCOTAN)\n\n\n\nROC for Seurat\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat scTransform\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_ScTransform_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_scTr &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Seurat Bimod\n\ndeaSeurat_tot &lt;- NA\n\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  #print(ind)\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  \n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  \n  deaSeurat &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Seurat_DEA_Bimod_genes.csv\")), row.names = 1)\n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaSeurat[deaSeurat$cluster == cl.val,]$cluster &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"cluster\",\n                                     replacement = \"clusters\") \n  colnames(deaSeurat) &lt;- str_replace(colnames(deaSeurat),\n                                     pattern = \"gene\",\n                                     replacement = \"genes\") \n  \n  deaSeurat$data_set &lt;- subset.datasets_csv[ind,1]\n  deaSeurat$set_number &lt;- ind \n  deaSeurat_tot &lt;- rbind(deaSeurat_tot, deaSeurat)\n  \n  \n  }\n deaSeurat_tot &lt;-  deaSeurat_tot[2:nrow(deaSeurat_tot),]\n \n deaSeurat_tot &lt;- merge.data.frame(deaSeurat_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaSeurat_tot$value &lt;- as.numeric(deaSeurat_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultSeurat_Bimod &lt;- roc(deaSeurat_tot$value, 1 - deaSeurat_tot$p_val)\n\n# Plot the ROC curve\n#plot(roc_resultSeurat)\n\n\n\nROC for Monocle\n\ndeaMonocle_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n  \n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaMonocle &lt;- read.csv(file.path(dirOut,paste0(file.code,\"Monocle_DEA_genes.csv\")),row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaMonocle[deaMonocle$cell_group == cl.val,\"cell_group\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n  \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"cell_group\",\n                                     replacement = \"clusters\") \n  colnames(deaMonocle) &lt;- str_replace(colnames(deaMonocle),\n                                     pattern = \"gene_id\",\n                                     replacement = \"genes\")\n  \n  deaMonocle$data_set &lt;- subset.datasets_csv[ind,1]\n  deaMonocle$set_number &lt;- ind \n  deaMonocle &lt;- as.data.frame(deaMonocle)\n  deaMonocle_tot &lt;- rbind(deaMonocle_tot, deaMonocle)\n  \n  \n  }\n deaMonocle_tot &lt;-  deaMonocle_tot[2:nrow(deaMonocle_tot),]\n \n deaMonocle_tot &lt;- merge.data.frame(deaMonocle_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaMonocle_tot$value &lt;- as.numeric(deaMonocle_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultMonocle &lt;- roc(deaMonocle_tot$value, 1 - deaMonocle_tot$marker_test_p_value)\n\n# Plot the ROC curve\n#plot(roc_resultMonocle)\n\n\n\nROC from ScamPy\n\ndeaScamPy_tot &lt;- NA\nfor (ind in 1:dim(subset.datasets_csv)[1]) {\n  file.code &lt;- paste0(subset.datasets_csv$Group[ind],\"_\",subset.datasets_csv$Collection[ind])\n  dataset &lt;- readRDS(file = file.path(dataSetDir,paste0(file.code,\".RDS\")))\n\n  clusterization &lt;- getClusterizationData(dataset, clName = \"mergedClusters\")[[1]]\n  #print(file.code)\n  \n  deaScamPy &lt;- read.csv(file.path(dirOut,paste0(file.code,\"ScamPy_DEA_genes.csv\")),\n                        row.names = 1) \n  \n  cl.names &lt;- NA\n  \n  for (cl.val in  unique(clusterization)) {\n    #print(cl.val)\n    cl.name &lt;- str_split(names(clusterization[clusterization == cl.val])[1],\n                            pattern = \"_\",simplify = T)[1]\n    cl.names &lt;- c(cl.names,cl.name)\n    cl.names &lt;- cl.names[!is.na(cl.names)]\n  \n    deaScamPy[deaScamPy$clusters == paste0(\"cl\",cl.val),\"clusters\"] &lt;- cl.name   \n  \n  }\n  \n  clusters &lt;- str_split(datasets_csv$Collection[ind],pattern = \"_[+]_\",simplify = T)\n\n\n  deaScamPy$data_set &lt;- subset.datasets_csv[ind,1]\n  deaScamPy$set_number &lt;- ind \n  deaScamPy_tot &lt;- rbind(deaScamPy_tot, deaScamPy)\n  \n  \n  }\n deaScamPy_tot &lt;-  deaScamPy_tot[2:nrow(deaScamPy_tot),]\n \n deaScamPy_tot &lt;- merge.data.frame(deaScamPy_tot,\n                                   ground_truth_tot,\n                                   by = c(\"genes\",\"clusters\",\"data_set\",\"set_number\"),\n                                   all.x = T,all.y = F)\n\n# Convert TRUE/FALSE to 1/0\ndeaScamPy_tot$value &lt;- as.numeric(deaScamPy_tot$value)\n\n# Compute the ROC curve - note that we invert the p-values with 1 - p_values\nroc_resultScamPy &lt;- roc(deaScamPy_tot$value, 1 - deaScamPy_tot$pval)\n\n# Plot the ROC curve\n#plot(roc_resultScamPy)\n\n\n\nSummary ROC for all methods\n\nFiveClusters_uneven &lt;- ggroc(list(COTAN=roc_resultCOTAN, Seurat=roc_resultSeurat,\n                 Seurat_scTr = roc_resultSeurat_scTr, Seurat_Bimod = roc_resultSeurat_Bimod,\n                 Monocle=roc_resultMonocle, ScamPy=roc_resultScamPy))\n\nFiveClusters_unevenPL &lt;- FiveClusters_uneven + xlab(\"FPR\") + ylab(\"TPR\")\nFiveClusters_unevenPL"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#clusters-2",
    "href": "FDR_analysisResultsLFC.html#clusters-2",
    "title": "Results - Log Fold Change",
    "section": "2 Clusters",
    "text": "2 Clusters\n\nggarrange(TwoClusters_even_nearPL,TwoClusters_even_mediumPL, TwoClusters_even_farPL,TwoClusters_uneven_nearPL, TwoClusters_uneven_mediumPL,TwoClusters_uneven_farPL,\n          labels = c(\"Even_Near\", \"Even_Medium\", \"Even_Far\", \"Uneven_Near\",\"Uneven_Medium\",\"Uneven_Far\"),\n          ncol = 3, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#and-5-clusters",
    "href": "FDR_analysisResultsLFC.html#and-5-clusters",
    "title": "Results - Log Fold Change",
    "section": "3 and 5 Clusters",
    "text": "3 and 5 Clusters\n\nggarrange(ThreeClusters_evenPL,ThreeClusters_unevenPL, NULL, FiveClusters_unevenPL,\n          labels = c(\"3_Even\", \"3_Uneven\", \"\", \"5_Uneven\"),\n          ncol = 2, nrow = 2, common.legend = T, legend = \"bottom\")"
  },
  {
    "objectID": "FDR_analysisResultsLFC.html#footer",
    "href": "FDR_analysisResultsLFC.html#footer",
    "title": "Results - Log Fold Change",
    "section": "Footer",
    "text": "Footer\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggpubr_0.6.0  ggplot2_3.4.2 tidyr_1.3.0   dplyr_1.1.2   stringr_1.5.0\n[6] pROC_1.18.4   COTAN_2.3.3  \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               tibble_3.2.1             \n  [5] polyclip_1.10-4           fastDummies_1.7.3        \n  [7] lifecycle_1.0.3           rstatix_0.7.2            \n  [9] doParallel_1.0.17         globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] backports_1.4.1           dendextend_1.17.1        \n [15] magrittr_2.0.3            plotly_4.10.2            \n [17] rmarkdown_2.24            yaml_2.3.7               \n [19] httpuv_1.6.11             Seurat_5.0.0             \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             sp_2.1-1                 \n [25] spatstat.sparse_3.0-2     reticulate_1.35.0        \n [27] cowplot_1.1.1             pbapply_1.7-2            \n [29] RColorBrewer_1.1-3        abind_1.4-5              \n [31] Rtsne_0.16                purrr_1.0.1              \n [33] BiocGenerics_0.46.0       circlize_0.4.15          \n [35] IRanges_2.34.1            S4Vectors_0.38.1         \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       tidyselect_1.2.0         \n [53] shape_1.4.6               farver_2.1.1             \n [55] ScaledMatrix_1.8.1        viridis_0.6.4            \n [57] matrixStats_1.2.0         stats4_4.3.2             \n [59] spatstat.explore_3.2-1    jsonlite_1.8.7           \n [61] GetoptLong_1.0.5          ellipsis_0.3.2           \n [63] progressr_0.14.0          ggridges_0.5.4           \n [65] survival_3.5-7            iterators_1.0.14         \n [67] foreach_1.5.2             tools_4.3.2              \n [69] ica_1.0-3                 Rcpp_1.0.11              \n [71] glue_1.7.0                gridExtra_2.3            \n [73] xfun_0.39                 MatrixGenerics_1.12.3    \n [75] ggthemes_5.0.0            withr_3.0.0              \n [77] fastmap_1.1.1             fansi_1.0.4              \n [79] openssl_2.1.0             digest_0.6.33            \n [81] rsvd_1.0.5                parallelDist_0.2.6       \n [83] R6_2.5.1                  mime_0.12                \n [85] colorspace_2.1-0          scattermore_1.2          \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] utf8_1.2.3                generics_0.1.3           \n [91] data.table_1.15.0         httr_1.4.6               \n [93] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [95] uwot_0.1.16               pkgconfig_2.0.3          \n [97] gtable_0.3.3              ComplexHeatmap_2.16.0    \n [99] lmtest_0.9-40             htmltools_0.5.7          \n[101] carData_3.0-5             dotCall64_1.1-0          \n[103] clue_0.3-64               SeuratObject_5.0.0       \n[105] scales_1.3.0              png_0.1-8                \n[107] knitr_1.43                rstudioapi_0.15.0        \n[109] reshape2_1.4.4            rjson_0.2.21             \n[111] nlme_3.1-163              zoo_1.8-12               \n[113] GlobalOptions_0.1.2       KernSmooth_2.23-22       \n[115] parallel_4.3.2            miniUI_0.1.1.1           \n[117] RcppZiggurat_0.1.6        pillar_1.9.0             \n[119] grid_4.3.2                vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] car_3.1-2                 BiocSingular_1.16.0      \n[125] beachmat_2.16.0           xtable_1.8-4             \n[127] cluster_2.1.6             evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              future.apply_1.11.0      \n[135] ggsignif_0.6.4            labeling_0.4.2           \n[137] plyr_1.8.8                stringi_1.8.1            \n[139] viridisLite_0.4.2         deldir_2.0-2             \n[141] BiocParallel_1.34.2       assertthat_0.2.1         \n[143] munsell_0.5.0             lazyeval_0.2.2           \n[145] spatstat.geom_3.2-4       PCAtools_2.14.0          \n[147] Matrix_1.6-3              RcppHNSW_0.6.0           \n[149] patchwork_1.2.0           sparseMatrixStats_1.12.2 \n[151] future_1.33.0             shiny_1.8.0              \n[153] ROCR_1.0-11               Rfast_2.1.0              \n[155] broom_1.0.5               igraph_1.6.0             \n[157] RcppParallel_5.1.7"
  },
  {
    "objectID": "ForebrainDorsal_E135-analysis.html",
    "href": "ForebrainDorsal_E135-analysis.html",
    "title": "Forebrain Dorsal E13.5 Data-set Anaysis",
    "section": "",
    "text": "library(ggplot2)\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"Data/MouseCortexFromLoom/\"\n\nsetLoggingLevel(1)\nsetLoggingFile(file.path(outDir, \"ForebrainDorsal_E135-analysis.log\"))\n\nRead the already created COTAN object\n\nfb135Obj &lt;- readRDS(\"Data/MouseCortexFromLoom/SourceData/e13.5_ForebrainDorsal.cotan.RDS\")\nsampleCondition &lt;- getMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nsampleCondition\n\n[1] \"e13.5_ForebrainDorsal\"\n\n\nInspect cells’ sizes\n\ncellSizePlot(fb135Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nDrop cells with too many ritz reads as they are probably duplets\n\ncellsSizeThr &lt;- 10000\nfb135Obj &lt;- addElementToMetaDataset(fb135Obj, \"Cells size threshold\", cellsSizeThr)\n\ncells_to_rem &lt;- getCells(fb135Obj)[getCellsSize(fb135Obj) &gt; cellsSizeThr]\nfb135Obj &lt;- dropGenesCells(fb135Obj, cells = cells_to_rem)\n\ncellSizePlot(fb135Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(fb135Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nDrop cells with too low genes expession as they are probably dead\n\ngenesSizeLowThr &lt;- 700\nfb135Obj &lt;- addElementToMetaDataset(fb135Obj, \"Num genes low threshold\", genesSizeLowThr)\n\nnumExprGenes &lt;- getNumGenes(fb135Obj)\ncells_to_rem &lt;- names(numExprGenes)[numExprGenes &lt; genesSizeLowThr]\nfb135Obj &lt;- dropGenesCells(fb135Obj, cells = cells_to_rem)\n\ngenesSizePlot(fb135Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nCheck number of mitocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^mt.\"\ngetGenes(fb135Obj)[grep(mitGenesPattern, getGenes(fb135Obj))]\n\n[1] \"mt.Co1\"  \"mt.Co3\"  \"mt.Nd4\"  \"mt.Nd5\"  \"mt.Nd1\"  \"mt.Nd2\"  \"mt.Atp6\"\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(fb135Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \":\", numCol = 1)\n\nplot(mitPlot)\n\n\n\n\nCells with a too high percentage of mitocondrial genes are likely dead (or at the last problematic) cells. So we drop them!\n\nmitPercThr &lt;- 1.0\nfb135Obj &lt;- addElementToMetaDataset(fb135Obj, \"Mitoc. perc. threshold\", mitPercThr)\n\ncells_to_rem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\nfb135Obj &lt;- dropGenesCells(fb135Obj, cells = cells_to_rem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(fb135Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \":\", numCol = 1)\n\nplot(mitPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(fb135Obj, splitPattern = \":\", numCol = 1)\n\n\n\ngenesSizePlot(fb135Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nClean: round 1\n\nfb135Obj &lt;- clean(fb135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %&lt;-% cleanPlots(fb135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb135Obj &lt;- addElementToMetaDataset(fb135Obj, \"Num drop B group\", 0)\n\nB group contains high number of hemoglobin genes: so they are not interesting\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\nfb135Obj &lt;- dropGenesCells(fb135Obj, cells = cells_to_rem)\n\nClean: round 2\n\nfb135Obj &lt;- clean(fb135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %&lt;-% cleanPlots(fb135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb135Obj &lt;- addElementToMetaDataset(fb135Obj, \"Num drop B group\", 1)\n\nB group contains high number of hemoglobin genes: so they are not interesting\n\ncells_to_rem &lt;- rownames(pcaCellsData)[pcaCellsData[[\"groups\"]] == \"B\"]\n\nfb135Obj &lt;- dropGenesCells(fb135Obj, cells = cells_to_rem)\n\nClean: round 3\n\nfb135Obj &lt;- clean(fb135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %&lt;-% cleanPlots(fb135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb135Obj &lt;- addElementToMetaDataset(fb135Obj, \"Num drop B group\", 2)\n\nVisualize if all is ok:\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nlowUDEThr &lt;- 0.3 # the threshold to remove low UDE cells\n\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(fb135Obj)), \"n\" = seq_along(getNu(fb135Obj)))\nUDEPlot_zoomed &lt;- ggplot(nuDf, aes(x = n, y = nu)) +\n            geom_point(colour = \"#8491B4B2\", size = 1.0) +\n            xlim(0L, 400L) +\n            ylim(0.0, 1.0) +\n            geom_hline(yintercept = lowUDEThr, linetype = \"dashed\",\n                       color = \"darkred\") +\n            annotate(geom = \"text\", x = 200L, y = 0.25,\n                     label = paste0(\"to remove cells with nu &lt; \", lowUDEThr),\n                     color = \"darkred\", size = 4.5)\n\nplot(UDEPlot_zoomed)\n\n\n\n\nFinal cleaning to check all is OK\n\nfb135Obj &lt;- clean(fb135Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %&lt;-% cleanPlots(fb135Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(cellSizePlot(fb135Obj, splitPattern = \":\", numCol = 1))\n\n\n\nplot(genesSizePlot(fb135Obj, splitPattern = \":\", numCol = 1))\n\n\n\n\nCalculate genes’ COEX\n\nfb135Obj &lt;- proceedToCoex(fb135Obj, calcCoex = TRUE, cores = 12,\n                          saveObj = TRUE, outDir = outDir)\n\ngdiData &lt;- calculateGDI(fb135Obj)\n\ngenesToLabel &lt;- head(rownames(gdiData[order(gdiData[[\"GDI\"]],\n                                            decreasing = TRUE), ]), n = 10L)\n\ngenesToLabel\n\n [1] \"Myt1l\"   \"Ccser1\"  \"Hes1\"    \"Neurod2\" \"Neurod6\" \"Aldoc\"   \"Hes5\"   \n [8] \"Nsg2\"    \"Rab3a\"   \"Rbfox1\" \n\ngdiPlot &lt;- GDIPlot(fb135Obj, GDIIn = gdiData, GDIThreshold = 1.4,\n                   genes = list(\"Top 10 GDI genes\" = genesToLabel))\n\nplot(gdiPlot)\n\n\n\n\nSave the COTAN object\n\nsaveRDS(fb135Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nfb135Obj &lt;- readRDS(file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nsplitClusters &lt;- cellsUniformClustering(fb135Obj, GDIThreshold = 1.4, cores = 13,\n                                        saveObj = TRUE, outDir = outDir)\n\nc(splitCoexDF, splitPValueDF) %&lt;-% DEAOnClusters(fb135Obj, clusters = splitClusters)\n\nfb135Obj &lt;- addClusterization(fb135Obj, clName = \"split\",\n                              clusters = splitClusters,\n                              coexDF = splitCoexDF, override = TRUE)\n\ntable(splitClusters)\n\n\nsaveRDS(fb135Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nc(mergedClusters, mergedCoexDF, mergedPValueDF) %&lt;-%\n  mergeUniformCellsClusters(fb135Obj, clusters = splitClusters,\n                            GDIThreshold = 1.4, cores = 13,\n                            saveObj = TRUE, outDir = outDir)\n\nfb135Obj &lt;- addClusterization(fb135Obj, clName = \"merge\",\n                              clusters = mergedClusters,\n                              coexDF = mergedCoexDF,\n                              override = TRUE)\n\ntable(mergedClusters)\n\n\nsaveRDS(fb135Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Berlin\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.1.5   zeallot_0.1.0 tibble_3.2.1  ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.14        jsonlite_1.8.4        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.21        \n [10] GlobalOptions_0.1.2    vctrs_0.6.1            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-20    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.1          zoo_1.8-12             igraph_1.4.2          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.5-4.1         R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-8     future_1.32.0         \n [34] shiny_1.7.4            clue_0.3-64            digest_0.6.31         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.0      \n [40] Seurat_4.3.0           tensor_1.5             RSpectra_0.16-1       \n [43] irlba_2.3.5.1          labeling_0.4.2         progressr_0.13.0      \n [46] RcppZiggurat_0.1.6     fansi_1.0.4            spatstat.sparse_3.0-1 \n [49] httr_1.4.5             polyclip_1.10-4        abind_1.4-5           \n [52] compiler_4.3.0         withr_2.5.0            doParallel_1.0.17     \n [55] viridis_0.6.2          dendextend_1.17.1      MASS_7.3-59           \n [58] openssl_2.0.6          rjson_0.2.21           tools_4.3.0           \n [61] lmtest_0.9-40          httpuv_1.6.9           future.apply_1.11.0   \n [64] goftest_1.2-3          glue_1.6.2             nlme_3.1-162          \n [67] promises_1.2.0.1       grid_4.3.0             Rtsne_0.16            \n [70] cluster_2.1.4          reshape2_1.4.4         generics_0.1.3        \n [73] gtable_0.3.3           spatstat.data_3.0-1    tidyr_1.3.0           \n [76] data.table_1.14.8      sp_1.6-0               utf8_1.2.3            \n [79] BiocGenerics_0.46.0    spatstat.geom_3.2-1    RcppAnnoy_0.0.20      \n [82] ggrepel_0.9.3          RANN_2.6.1             foreach_1.5.2         \n [85] pillar_1.9.0           stringr_1.5.0          later_1.3.0           \n [88] circlize_0.4.15        splines_4.3.0          dplyr_1.1.2           \n [91] lattice_0.21-8         survival_3.5-5         deldir_1.0-6          \n [94] tidyselect_1.2.0       ComplexHeatmap_2.16.0  miniUI_0.1.1.1        \n [97] pbapply_1.7-0          knitr_1.42             gridExtra_2.3         \n[100] IRanges_2.34.0         scattermore_1.1        stats4_4.3.0          \n[103] xfun_0.39              factoextra_1.0.7       matrixStats_1.0.0     \n[106] stringi_1.7.12         lazyeval_0.2.2         yaml_2.3.7            \n[109] evaluate_0.20          codetools_0.2-19       cli_3.6.1             \n[112] RcppParallel_5.1.7     uwot_0.1.14            xtable_1.8-4          \n[115] reticulate_1.28        munsell_0.5.0          Rcpp_1.0.10           \n[118] globals_0.16.2         spatstat.random_3.1-4  png_0.1-8             \n[121] parallel_4.3.0         Rfast_2.0.7            ellipsis_0.3.2        \n[124] assertthat_0.2.1       parallelDist_0.2.6     listenv_0.9.0         \n[127] ggthemes_4.2.4         viridisLite_0.4.1      scales_1.2.1          \n[130] ggridges_0.5.4         SeuratObject_4.1.3     leiden_0.4.3          \n[133] purrr_1.0.1            crayon_1.5.2           GetoptLong_1.0.5      \n[136] rlang_1.1.0            cowplot_1.1.1"
  },
  {
    "objectID": "ForebrainDorsal_E175-analysis.html",
    "href": "ForebrainDorsal_E175-analysis.html",
    "title": "Forebrain Dorsal E17.5 Data-set Anaysis",
    "section": "",
    "text": "library(ggplot2)\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\n#devtools::load_all(\"../COTAN/\")\n\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"Data/MouseCortexFromLoom/\"\nif (!file.exists(outDir)) {\n  dir.create(outDir)\n}\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"ForebrainDorsal_E175-analysis.log\"))\n\nRead the already created COTAN object\n\nfb175Obj &lt;- readRDS(file.path(\"Data/MouseCortexFromLoom/SourceData/\", \"e17.5_ForebrainDorsal.cotan.RDS\"))\nsampleCondition &lt;- getMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])\n\nsampleCondition\n\n[1] \"e17.5_ForebrainDorsal\"\n\n\nInspect cells’ sizes\n\ncellSizePlot(fb175Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nDrop cells with too many reads reads as they are probably doublets\n\ncellsSizeThr &lt;- 10000\nfb175Obj &lt;- addElementToMetaDataset(fb175Obj, \"Cells size threshold\", cellsSizeThr)\n\ncells_to_rem &lt;- getCells(fb175Obj)[getCellsSize(fb175Obj) &gt; cellsSizeThr]\nfb175Obj &lt;- dropGenesCells(fb175Obj, cells = cells_to_rem)\n\ncellSizePlot(fb175Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(fb175Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nDrop cells with too low genes expression as they are probably dead\n\ngenesSizeLowThr &lt;- 700\nfb175Obj &lt;- addElementToMetaDataset(fb175Obj, \"Num genes low threshold\", genesSizeLowThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(fb175Obj)\ncells_to_rem &lt;- names(numExprGenes)[numExprGenes &lt; genesSizeLowThr]\nfb175Obj &lt;- dropGenesCells(fb175Obj, cells = cells_to_rem)\n\ngenesSizePlot(fb175Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nCheck number of mitochondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^mt.\"\ngetGenes(fb175Obj)[grep(mitGenesPattern, getGenes(fb175Obj))]\n\n[1] \"mt.Co1\" \"mt.Co3\" \"mt.Nd4\" \"mt.Nd5\" \"mt.Nd1\" \"mt.Nd2\"\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(fb175Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \":\", numCol = 1)\n\nplot(mitPlot)\n\n\n\n\nCells with a too high percentage of mitochondrial genes are likely dead (or at the last problematic) cells. So we drop them!\n\nmitPercThr &lt;- 1.5\nfb175Obj &lt;- addElementToMetaDataset(fb175Obj, \"Mitoc. perc. threshold\", mitPercThr)\n\ncells_to_rem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\nfb175Obj &lt;- dropGenesCells(fb175Obj, cells = cells_to_rem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(fb175Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \":\", numCol = 1)\n\nplot(mitPlot)\n\n\n\n\nCheck no further outlines after all the culling\n\ncellSizePlot(fb175Obj, splitPattern = \":\", numCol = 1)\n\n\n\ngenesSizePlot(fb175Obj, splitPattern = \":\", numCol = 1)\n\n\n\n\nClean: round 1\n\nfb175Obj &lt;- clean(fb175Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb175Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\nfb175Obj &lt;- addElementToMetaDataset(fb175Obj, \"Num drop B group\", 0)\n\nVisualize if all is ok:\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\nFinal cleaning to check all is OK\n\nfb175Obj &lt;- clean(fb175Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot,\n  UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(fb175Obj)\n\nplot(pcaCellsPlot)\nplot(genesPlot)\nplot(UDEPlot)\nplot(nuPlot)\nplot(zoomedNuPlot)\n\nplot(cellSizePlot(fb175Obj, splitPattern = \":\", numCol = 1))\nplot(genesSizePlot(fb175Obj, splitPattern = \":\", numCol = 1))\n\nCalculate genes’ COEX\n\nfb175Obj &lt;- proceedToCoex(fb175Obj, calcCoex = TRUE, cores = 12,\n                          saveObj = TRUE, outDir = outDir)\n\n\ngdiData &lt;- calculateGDI(fb175Obj)\n\ngenesToLabel &lt;- head(rownames(gdiData[order(gdiData[[\"GDI\"]],\n                                            decreasing = TRUE), ]), n = 10L)\n\ngenesToLabel\n\n [1] \"Mfge8\"    \"Myt1l\"    \"Atp1a2\"   \"Sparc\"    \"Apoe\"     \"Phgdh\"   \n [7] \"Slc9a3r1\" \"Tnc\"      \"Ccdc80\"   \"Aldoc\"   \n\ngdiPlot &lt;- GDIPlot(fb175Obj, GDIIn = gdiData, GDIThreshold = 1.4,\n                   genes = list(\"Top 10 GDI genes\" = genesToLabel))\n\nplot(gdiPlot)\n\n\n\n\nSave the COTAN object\n\nsaveRDS(fb175Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nc(splitClusters, splitCoexDF) %&lt;-%\n  cellsUniformClustering(fb175Obj, GDIThreshold = 1.4, cores = 13L,\n                         saveObj = TRUE, outDir = outDir)\n\nfb175Obj &lt;- addClusterization(fb175Obj, clName = \"split\",\n                              clusters = splitClusters,\n                              coexDF = splitCoexDF, override = TRUE)\n\n\nsplitClusters &lt;- getClusterizationData(fb175Obj,clName = \"split\")$clusters\n\ntable(splitClusters)\n\nsplitClusters\n -1  20  04  05  06  07  10  22  11  08  21  23  16  12  18  24  09  14  15  13 \n 10 384 130 119  82  53  44  40  32  22 413 166 159  91  55  50  15 202 146  70 \n 02  01  03  17  19 \n 50  37  32  35  30 \n\n\n\nc(mergedClusters, mergedCoexDF) %&lt;-%\n  mergeUniformCellsClusters(fb175Obj, clusters = splitClusters,\n                            GDIThreshold = 1.4, batchSize = 20L, cores = 13L,\n                            saveObj = TRUE, outDir = outDir)\n\nfb175Obj &lt;- addClusterization(fb175Obj, clName = \"merge\",\n                              clusters = mergedClusters,\n                              coexDF = mergedCoexDF,\n                              override = TRUE)\n\n\nmergedClusters &lt;- getClusterizationData(fb175Obj,clName = \"merge\")$clusters\ntable(mergedClusters)\n\nmergedClusters\n 16  03  04  05  06  07  18  01  02  12  19  14  13  15  17  08  09  10  11 \n 65  37  50  32 130 119 135  22  15  44  32 237 100 202 194 384 413  90 166 \n\n\n\n\nSys.time()\n\n[1] \"2023-08-22 11:46:58 CEST\"\n\n\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.1.7   zeallot_0.1.0 tibble_3.2.1  ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.15.0      jsonlite_1.8.7        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.24        \n [10] GlobalOptions_0.1.2    vctrs_0.6.3            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-22    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.2          zoo_1.8-12             igraph_1.5.1          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.6-0           R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-11    future_1.33.0         \n [34] shiny_1.7.5            clue_0.3-64            digest_0.6.33         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.1      \n [40] Seurat_4.3.0.1         tensor_1.5             RSpectra_0.16-1       \n [43] irlba_2.3.5.1          labeling_0.4.2         progressr_0.14.0      \n [46] RcppZiggurat_0.1.6     fansi_1.0.4            spatstat.sparse_3.0-2 \n [49] httr_1.4.6             polyclip_1.10-4        abind_1.4-5           \n [52] compiler_4.3.1         withr_2.5.0            doParallel_1.0.17     \n [55] viridis_0.6.4          dendextend_1.17.1      MASS_7.3-60           \n [58] openssl_2.1.0          rjson_0.2.21           tools_4.3.1           \n [61] lmtest_0.9-40          httpuv_1.6.11          future.apply_1.11.0   \n [64] goftest_1.2-3          glue_1.6.2             nlme_3.1-162          \n [67] promises_1.2.0.1       grid_4.3.1             Rtsne_0.16            \n [70] cluster_2.1.4          reshape2_1.4.4         generics_0.1.3        \n [73] gtable_0.3.3           spatstat.data_3.0-1    tidyr_1.3.0           \n [76] data.table_1.14.8      sp_2.0-0               utf8_1.2.3            \n [79] BiocGenerics_0.46.0    spatstat.geom_3.2-4    RcppAnnoy_0.0.21      \n [82] ggrepel_0.9.3          RANN_2.6.1             foreach_1.5.2         \n [85] pillar_1.9.0           stringr_1.5.0          later_1.3.1           \n [88] circlize_0.4.15        splines_4.3.1          dplyr_1.1.2           \n [91] lattice_0.21-8         survival_3.5-5         deldir_1.0-9          \n [94] tidyselect_1.2.0       ComplexHeatmap_2.16.0  miniUI_0.1.1.1        \n [97] pbapply_1.7-2          knitr_1.43             gridExtra_2.3         \n[100] IRanges_2.34.1         scattermore_1.2        stats4_4.3.1          \n[103] xfun_0.39              factoextra_1.0.7       matrixStats_1.0.0     \n[106] stringi_1.7.12         lazyeval_0.2.2         yaml_2.3.7            \n[109] evaluate_0.21          codetools_0.2-19       cli_3.6.1             \n[112] RcppParallel_5.1.7     uwot_0.1.16            xtable_1.8-4          \n[115] reticulate_1.30        munsell_0.5.0          Rcpp_1.0.11           \n[118] globals_0.16.2         spatstat.random_3.1-5  png_0.1-8             \n[121] parallel_4.3.1         Rfast_2.0.8            ellipsis_0.3.2        \n[124] assertthat_0.2.1       parallelDist_0.2.6     listenv_0.9.0         \n[127] ggthemes_4.2.4         viridisLite_0.4.2      scales_1.2.1          \n[130] ggridges_0.5.4         SeuratObject_4.1.3     leiden_0.4.3          \n[133] purrr_1.0.1            crayon_1.5.2           GetoptLong_1.0.5      \n[136] rlang_1.1.1            cowplot_1.1.1"
  },
  {
    "objectID": "ForebrainLaManno2021ClustersGDI.html",
    "href": "ForebrainLaManno2021ClustersGDI.html",
    "title": "Forebrain La Manno 2021 Clusters GDI",
    "section": "",
    "text": "For the evaluation of GDI sensitivity and also to test type I error and FDR for the differential expressed gene in a cluster we need to have some Coherent Transcript Cell Cluster (cluster formed by cells as similar as possible). So we tested all clusters defined in the original paper for this data set (focusing on E13.5, E15.0, and E17.5).\n\nlibrary(rlang)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\n#devtools::load_all(\"~/dev/COTAN/COTAN/\")\n\noptions(parallelly.fork.enable = TRUE)\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(\".\", \"ClusterizationsGDI_AllForebrainDorsal.log\"))\n\n\n\n\ngetClData &lt;- function(objCOTAN, clList, cl) {\n  cluster &lt;- names(clList)[[cl]]\n  cells &lt;- clList[[cl]]\n  res &lt;- checkClusterUniformity(objCOTAN, cluster = cluster, cells = cells,\n                                GDIThreshold = 1.4, cores = 6, saveObj = FALSE)\n  res &lt;- c(list(\"cluster\" = cluster, \"size\" = length(cells)), res)\n  res &lt;- as.data.frame(res)\n  rownames(res) &lt;- cluster\n  colnames(res)\n  return(res)\n}\n\nclDataVal &lt;- list(\"cluster\" = NULL, \"size\" = NULL, \"isUniform\" = NULL,\n                  \"fractionAbove\" = NULL, \"1stPercentile\" = NULL)"
  },
  {
    "objectID": "ForebrainLaManno2021ClustersGDI.html#preamble",
    "href": "ForebrainLaManno2021ClustersGDI.html#preamble",
    "title": "Forebrain La Manno 2021 Clusters GDI",
    "section": "",
    "text": "For the evaluation of GDI sensitivity and also to test type I error and FDR for the differential expressed gene in a cluster we need to have some Coherent Transcript Cell Cluster (cluster formed by cells as similar as possible). So we tested all clusters defined in the original paper for this data set (focusing on E13.5, E15.0, and E17.5).\n\nlibrary(rlang)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\n#devtools::load_all(\"~/dev/COTAN/COTAN/\")\n\noptions(parallelly.fork.enable = TRUE)\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(\".\", \"ClusterizationsGDI_AllForebrainDorsal.log\"))\n\n\n\n\ngetClData &lt;- function(objCOTAN, clList, cl) {\n  cluster &lt;- names(clList)[[cl]]\n  cells &lt;- clList[[cl]]\n  res &lt;- checkClusterUniformity(objCOTAN, cluster = cluster, cells = cells,\n                                GDIThreshold = 1.4, cores = 6, saveObj = FALSE)\n  res &lt;- c(list(\"cluster\" = cluster, \"size\" = length(cells)), res)\n  res &lt;- as.data.frame(res)\n  rownames(res) &lt;- cluster\n  colnames(res)\n  return(res)\n}\n\nclDataVal &lt;- list(\"cluster\" = NULL, \"size\" = NULL, \"isUniform\" = NULL,\n                  \"fractionAbove\" = NULL, \"1stPercentile\" = NULL)"
  },
  {
    "objectID": "ForebrainLaManno2021ClustersGDI.html#forebrain-dorsal-e13.5",
    "href": "ForebrainLaManno2021ClustersGDI.html#forebrain-dorsal-e13.5",
    "title": "Forebrain La Manno 2021 Clusters GDI",
    "section": "Forebrain Dorsal E13.5",
    "text": "Forebrain Dorsal E13.5\n\nLoad dataset\n\nfb135Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e13.5_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition &lt;- getMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nlogThis(sampleCondition)\n\nallClust &lt;- getClusterizations(fb135Obj)\n\nlogThis(\"\")\nlogThis(paste(\"Number of cells:\", getNumCells(fb135Obj)))\n\nlogThis(\"\")\nlogThis(\"Available clusterizations:\")\nlogThis(paste0(allClust, collapse = \", \"))\n\nclSizes &lt;- vapply(allClust, function(x) { nlevels(getClusters(fb135Obj, x))}, integer(1L))\nclSizes\n\n            split             merge original.clusters original.subclass \n               35                31               159                40 \n   original.class       cell.typist            seurat   seurat.high.res \n               13                13                19                36 \n          monocle  monocle.high.res \n               11                27 \n\nlogThis(paste(names(clSizes), clSizes, sep = \": \", collapse = \", \"))\n\n\n\nExtract original cluster\n\noriginalFB135 &lt;- getClusters(fb135Obj, clName = \"original.clusters\")\n\nnlevels(originalFB135)\n\n[1] 159\n\nsort(table(originalFB135), decreasing = TRUE)\n\noriginalFB135\n432 186 187 434 184 437 510 509 183 185 438 433 525 443 446 192 568 188 441 565 \n536 423 334 326 292 259 248 239 178 168 155 141 130  82  74  65  65  63  56  53 \n428 181 679 440 189 118 507 431 442 445 497 444 193 426 511 439 178 436 508 135 \n 52  51  49  46  39  36  35  32  30  29  29  26  25  25  23  22  20  20  20  19 \n 68 177 427 435 175 225 120 271  67 173 430 494 524 176 429 493 496 502 566 117 \n 17  14  14  13  12  12  11  11  11  10  10  10  10   9   9   9   9   9   9   8 \n136 161 194 332 504 112 174 222 228 675 115 158 270 505 670 114 133 159 227 267 \n  8   8   8   8   8   7   7   6   6   6   5   5   5   5   5   4   4   4   4   4 \n359  41 470 564 162 179 329 447 492 519 535 671 119 130 146 163 168 195 224 226 \n  4   4   4   4   3   3   3   3   3   3   3   3   2   2   2   2   2   2   2   2 \n251 263 273 326 453 516 520 528 538 569 575 672 676 677 683 691 793 107 113 125 \n  2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   1   1   1 \n137 138 144 180 182 196 216 254 259 269 333 355 358 374  40 420 454 458 468 471 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n495 498 499 523 549  55 559 658 666 673 678 686 688 689 731 744 760 795  82 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n\n# drop too small clusters: those whose size is less than 15\nlargeClFB135 &lt;- which(table(originalFB135) &gt;= 50)\nlargeOrigFB135 &lt;- originalFB135[(originalFB135 %in% names(largeClFB135)),\n                                drop = TRUE]\n\nlargeOrigFB135 &lt;- toClustersList(largeOrigFB135)\n\n\n\nCalculate GDI for each cluster in E13.5\n\nprint(\"Length larger clusters\")\nvapply(largeOrigFB135, length, integer(1))\n\nresDataFB135 &lt;- lapply(seq_along(largeOrigFB135), FUN = getClData,\n                       objCOTAN = fb135Obj, clList = largeOrigFB135)\n\n\nclDataFB135 &lt;- data.table::rbindlist(resDataFB135)\nclDataFB135 &lt;- column_to_rownames(clDataFB135, var = \"cluster\")\n\n\nsaveRDS(clDataFB135,\n        file = file.path(\"Data/MouseCortexFromLoom/ClustersGDI/\", \"e13.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\n\n\nclDataFB135 &lt;- readRDS(\"Data/MouseCortexFromLoom/ClustersGDI/e13.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\")\nclDataFB135[order(clDataFB135$size, decreasing = T),]\n\n    size isUniform fractionAbove X1stPercentile\n432  536     FALSE  3.770380e-02       1.484698\n186  423     FALSE  4.307131e-02       1.609718\n187  334     FALSE  1.303433e-02       1.423035\n434  326      TRUE  4.379562e-03       1.376828\n184  292     FALSE  1.170610e-02       1.414304\n437  259      TRUE  4.410239e-03       1.364885\n510  248      TRUE  9.610563e-03       1.397472\n509  239      TRUE  4.471580e-03       1.373229\n183  178     FALSE  1.458630e-02       1.427795\n185  168     FALSE  1.630482e-02       1.428907\n438  155      TRUE  1.080901e-03       1.320271\n433  141      TRUE  4.997501e-03       1.363220\n525  130      TRUE  1.488711e-03       1.329041\n443   82      TRUE  2.276508e-03       1.344695\n446   74      TRUE  8.701706e-05       1.300874\n192   65      TRUE  2.597852e-04       1.310808\n568   65      TRUE  0.000000e+00       1.233130\n188   63      TRUE  1.147802e-03       1.314789\n441   56      TRUE  0.000000e+00       1.277716\n565   53      TRUE  0.000000e+00       1.232690\n428   52      TRUE  0.000000e+00       1.263561\n181   51      TRUE  3.013116e-03       1.330148\n\n\nSo we can use the following clusters (at least 100 cells - cell number in the parenthesis - and GDI lower than 1.5):\n\ncl432 (n.cells 536),\ncl187 (334),\ncl434 (326),\ncl184 (292),\ncl437 (259),\ncl510 (248)"
  },
  {
    "objectID": "ForebrainLaManno2021ClustersGDI.html#forebrain-dorsal-e15.0",
    "href": "ForebrainLaManno2021ClustersGDI.html#forebrain-dorsal-e15.0",
    "title": "Forebrain La Manno 2021 Clusters GDI",
    "section": "Forebrain Dorsal E15.0",
    "text": "Forebrain Dorsal E15.0\n\nLoad dataset\n\nfb150Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e15.0_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition &lt;- getMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\nlogThis(sampleCondition)\n\nallClust &lt;- getClusterizations(fb150Obj)\n\nlogThis(\"\")\nlogThis(paste(\"Number of cells:\", getNumCells(fb150Obj)))\n\nlogThis(\"\")\nlogThis(\"Available clusterizations:\")\nlogThis(paste0(allClust, collapse = \", \"))\n\nclSizes &lt;- vapply(allClust, function(x) { nlevels(getClusters(fb150Obj, x))}, integer(1L))\nclSizes\n\n            split             merge            seurat   seurat.high.res \n               57                50                21                40 \noriginal.clusters original.subclass    original.class           monocle \n              229                47                14                11 \n monocle.high.res       cell.typist \n               46                13 \n\nlogThis(paste(names(clSizes), clSizes, sep = \": \", collapse = \", \"))\n\n\n\nExtract original cluster\n\noriginalFB150 &lt;- getClusters(fb150Obj, clName = \"original.clusters\")\n\nnlevels(originalFB150)\n\n[1] 229\n\nsort(table(originalFB150), decreasing = TRUE)\n\noriginalFB150\n525 432 511 509 510 508 184 428 434 437 507 568 433 504 426 185 187 505 516 565 \n826 586 540 402 402 397 322 318 273 258 183 181 176 174 173 172 163 147 137 133 \n427 524 679 439 436 493 498 446 438 441 183 497 192 506 188 443 502 494 574 575 \n120 108 105 102  93  93  79  66  63  60  54  51  46  46  43  42  42  41  41  41 \n492 118 177 519 526 566 182 181 501 573 193 429 445 499 518 440 560 178 442 514 \n 38  36  31  31  28  28  27  26  24  24  23  23  23  23  22  21  20  19  19  19 \n523 186 569 444 557 271 452 495 520 535 542 677 527 431 135 455 458 496 512 676 \n 19  18  18  17  16  15  15  15  15  14  14  14  13  12  11  11  11  11  11  11 \n120 159 517 145 161 174 179 558 227 332 457 470 503 739 117 175 176 189 559 564 \n 10  10  10   9   9   9   9   9   8   8   8   8   8   8   7   7   7   7   7   7 \n180 225 538 549 561 671  68 695 738 747 136 144 222 226 273 500 536 678 112 114 \n  6   6   6   6   6   6   6   6   6   6   5   5   5   5   5   5   5   5   4   4 \n115 157 267 328 453 456 534 550 570 686 731 737 133 146 147 158 172 173 270 326 \n  4   4   4   4   4   4   4   4   4   4   4   4   3   3   3   3   3   3   3   3 \n430 513 515 528 533 539 544 571 674 675 732 113 125 130 143 152 162 163 195 259 \n  3   3   3   3   3   3   3   3   3   3   3   2   2   2   2   2   2   2   2   2 \n435 451 454 531 543 548 552 554 562 670 689 740 119 122 134 137 142 151 156 191 \n  2   2   2   2   2   2   2   2   2   2   2   2   1   1   1   1   1   1   1   1 \n194 223 224 228 234 240 262 268 269 275 286 296 308 314 329 333 359  41 448 450 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n468 529 530 532 537 540 553 567 572 601 614 634 647 649  67 672 680 681 684 693 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n696 726 734 749 750 751 760 771  88 \n  1   1   1   1   1   1   1   1   1 \n\n# drop too small clusters: those whose size is less than 15\nlargeClFB150 &lt;- which(table(originalFB150) &gt;= 50)\nlargeOrigFB150 &lt;- originalFB150[(originalFB150 %in% names(largeClFB150)),\n                                drop = TRUE]\n\nlargeOrigFB150 &lt;- toClustersList(largeOrigFB150)\n\n\n\nCalculate GDI for each cluster\n\nprint(\"Length larger clusters\")\nvapply(largeOrigFB150, length, integer(1))\n\nresDataFB150 &lt;- lapply(seq_along(largeOrigFB150), FUN = getClData,\n                       objCOTAN = fb150Obj, clList = largeOrigFB150)\n\n\nclDataFB150 &lt;- data.table::rbindlist(resDataFB150)\nclDataFB150 &lt;- column_to_rownames(clDataFB150, var = \"cluster\")\n\n\nsaveRDS(clDataFB150,\n        file = file.path(\"Data/MouseCortexFromLoom/ClustersGDI/\", \"e15.0_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\n\n\nclDataFB150 &lt;- readRDS(\"Data/MouseCortexFromLoom/ClustersGDI/e15.0_ForebrainDorsal_GDI_of_original_clusterization.RDS\")\n\nclDataFB150[order(clDataFB150$size,decreasing = T),]\n\n    size isUniform fractionAbove X1stPercentile\n525  826     FALSE  0.3016472479       2.352178\n432  586     FALSE  0.0254880232       1.459100\n511  540     FALSE  0.1510725315       1.913734\n509  402      TRUE  0.0067395414       1.381121\n510  402     FALSE  0.0152561426       1.420390\n508  397      TRUE  0.0046488461       1.370125\n184  322     FALSE  0.0268745853       1.498304\n428  318      TRUE  0.0012377332       1.342660\n434  273      TRUE  0.0004509380       1.329601\n437  258      TRUE  0.0025343004       1.342904\n507  183      TRUE  0.0094123856       1.393946\n568  181      TRUE  0.0000000000       1.305810\n433  176      TRUE  0.0011034483       1.336980\n504  174      TRUE  0.0039181957       1.361682\n426  173      TRUE  0.0004750143       1.330498\n185  172     FALSE  0.0101354303       1.400158\n187  163      TRUE  0.0054207120       1.359734\n505  147      TRUE  0.0001728011       1.293017\n516  137      TRUE  0.0014539856       1.328445\n565  133      TRUE  0.0073304826       1.385537\n427  120      TRUE  0.0000000000       1.274314\n524  108     FALSE  0.0187910535       1.439259\n679  105      TRUE  0.0023903726       1.339173\n439  102      TRUE  0.0000000000       1.267754\n436   93      TRUE  0.0000000000       1.253222\n493   93      TRUE  0.0007476325       1.324079\n498   79      TRUE  0.0010643016       1.321372\n446   66      TRUE  0.0000000000       1.296987\n438   63      TRUE  0.0000000000       1.265541\n441   60      TRUE  0.0000000000       1.277497\n183   54      TRUE  0.0002659810       1.305260\n497   51      TRUE  0.0003751993       1.301691\n\n\nSo we can use the following clusters (at least 100 cells - cell number in the parenthesis - and GDI lower than 1.5):\n\ncl432 (586),\ncl509 (402),\ncl510 (402),\ncl508 (397),\ncl428 (318),\ncl434 (273),\ncl437 (258)"
  },
  {
    "objectID": "ForebrainLaManno2021ClustersGDI.html#forebrain-dorsal-e17.5",
    "href": "ForebrainLaManno2021ClustersGDI.html#forebrain-dorsal-e17.5",
    "title": "Forebrain La Manno 2021 Clusters GDI",
    "section": "Forebrain Dorsal E17.5",
    "text": "Forebrain Dorsal E17.5\n\nLoad dataset\n\nfb175Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e17.5_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition &lt;- getMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])\n\nlogThis(sampleCondition)\n\nallClust &lt;- getClusterizations(fb175Obj)\n\nlogThis(\"\")\nlogThis(paste(\"Number of cells:\", getNumCells(fb175Obj)))\n\nlogThis(\"\")\nlogThis(\"Available clusterizations:\")\nlogThis(paste0(allClust, collapse = \", \"))\n\nclSizes &lt;- vapply(allClust, function(x) { nlevels(getClusters(fb175Obj, x))}, integer(1L))\nclSizes\n\n            split             merge original.clusters original.subclass \n               25                19               136                27 \n   original.class       cell.typist            seurat   seurat.high.res \n                9                10                19                21 \n          monocle  monocle.high.res \n                7                24 \n\nlogThis(paste(names(clSizes), clSizes, sep = \": \", collapse = \", \"))\n\n\n\nExtract original cluster\n\noriginalFB175 &lt;- getClusters(fb175Obj, clName = \"original.clusters\")\n\nnlevels(originalFB175)\n\n[1] 136\n\nsort(table(originalFB175), decreasing = TRUE)\n\noriginalFB175\n516 505 515 427 504 514 428 493 506 513 508 517 523 177 436 498 512 507 524 172 \n297 203 159 147 135 119 110  80  72  69  58  58  55  38  38  38  37  36  29  28 \n568 439 492 495 503 574 575 179 426 526 521 441 433 442 494 497 502 178 501 565 \n 27  26  23  22  22  22  20  18  17  17  16  15  13  13  13  13  13  12  12  12 \n678 446 518 677 180 536 573 135 159 174 309 564 225 452 453 522 525 676 679 161 \n 11  10  10  10   9   8   8   7   7   7   7   7   6   6   6   6   6   6   6   5 \n176 184 277 437 458 520 535 539 144 175 182 187 457 499 519 537 569 117 185 262 \n  5   5   5   5   5   5   5   5   4   4   4   4   4   4   4   4   4   3   3   3 \n355 359 425 509 511 689 142 158 189 307 315 429 432 434 443 448 538 543 690 737 \n  3   3   3   3   3   3   2   2   2   2   2   2   2   2   2   2   2   2   2   2 \n115 120 124 132 136 151 160 173 183 188 227 245 261 273 286 298 306 308 310 316 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n317 438 440 455 500 510 557 560 562 570 572 671 673 688 740 796 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n\n# drop too small clusters: those whose size is less than 15\nlargeClFB175 &lt;- which(table(originalFB175) &gt;= 50)\nlargeOrigFB175 &lt;- originalFB175[(originalFB175 %in% names(largeClFB175)),\n                                drop = TRUE]\n\nlargeOrigFB175 &lt;- toClustersList(largeOrigFB175)\n\n\n\nCalculate GDI for each cluster\n\nprint(\"Length larger clusters\")\nvapply(largeOrigFB175, length, integer(1))\n\nresDataFB175 &lt;- lapply(seq_along(largeOrigFB175), FUN = getClData,\n                       objCOTAN = fb175Obj, clList = largeOrigFB175)\n\n\nclDataFB175 &lt;- data.table::rbindlist(resDataFB175)\nclDataFB175 &lt;- column_to_rownames(clDataFB175, var = \"cluster\")\n\n\nsaveRDS(clDataFB175,\n        file = file.path(\"Data/MouseCortexFromLoom/ClustersGDI/\", \"e17.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\n\n\nclDataFB175 &lt;- readRDS(\"Data/MouseCortexFromLoom/ClustersGDI/e17.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\")\nclDataFB175[order(clDataFB175$size,decreasing = T),]\n\n    size isUniform fractionAbove X1stPercentile\n516  297      TRUE  5.787234e-03       1.380640\n505  203      TRUE  7.261505e-04       1.330011\n515  159     FALSE  8.098331e-02       1.736907\n427  147      TRUE  0.000000e+00       1.275390\n504  135      TRUE  0.000000e+00       1.265854\n514  119     FALSE  3.665886e-02       1.517923\n428  110      TRUE  0.000000e+00       1.263149\n493   80      TRUE  1.512224e-03       1.331605\n506   72      TRUE  8.827684e-05       1.285308\n513   69     FALSE  7.475535e-02       1.649405\n508   58      TRUE  0.000000e+00       1.255277\n517   58      TRUE  8.074475e-03       1.383811\n523   55     FALSE  1.395007e-02       1.416125\n\n\nSo we can use the following clusters (at least 100 cells - cell number in the parenthesis - and GDI lower than 1.5):\n\ncl516 (297),\ncl505 (203)\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.3.0       data.table_1.14.8 zeallot_0.1.0     rlang_1.1.1      \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3        rstudioapi_0.15.0        \n  [3] jsonlite_1.8.7            shape_1.4.6              \n  [5] umap_0.2.10.0             magrittr_2.0.3           \n  [7] spatstat.utils_3.0-3      rmarkdown_2.24           \n  [9] GlobalOptions_0.1.2       vctrs_0.6.3              \n [11] ROCR_1.0-11               spatstat.explore_3.2-1   \n [13] DelayedMatrixStats_1.22.5 askpass_1.2.0            \n [15] htmltools_0.5.5           S4Arrays_1.2.0           \n [17] sctransform_0.4.1         parallelly_1.36.0        \n [19] KernSmooth_2.23-22        htmlwidgets_1.6.2        \n [21] ica_1.0-3                 plyr_1.8.8               \n [23] plotly_4.10.2             zoo_1.8-12               \n [25] igraph_1.5.1              mime_0.12                \n [27] lifecycle_1.0.3           iterators_1.0.14         \n [29] pkgconfig_2.0.3           rsvd_1.0.5               \n [31] Matrix_1.6-2              R6_2.5.1                 \n [33] fastmap_1.1.1             MatrixGenerics_1.12.3    \n [35] fitdistrplus_1.1-11       future_1.33.0            \n [37] shiny_1.7.5               clue_0.3-64              \n [39] digest_0.6.33             colorspace_2.1-0         \n [41] patchwork_1.1.2           S4Vectors_0.38.1         \n [43] tensor_1.5                Seurat_5.0.0             \n [45] dqrng_0.3.0               RSpectra_0.16-1          \n [47] irlba_2.3.5.1             beachmat_2.16.0          \n [49] PCAtools_2.14.0           progressr_0.14.0         \n [51] RcppZiggurat_0.1.6        spatstat.sparse_3.0-2    \n [53] fansi_1.0.4               polyclip_1.10-4          \n [55] httr_1.4.6                abind_1.4-5              \n [57] compiler_4.3.2            withr_2.5.0              \n [59] doParallel_1.0.17         BiocParallel_1.34.2      \n [61] viridis_0.6.4             fastDummies_1.7.3        \n [63] dendextend_1.17.1         MASS_7.3-60              \n [65] openssl_2.1.0             DelayedArray_0.26.7      \n [67] rjson_0.2.21              tools_4.3.2              \n [69] lmtest_0.9-40             httpuv_1.6.11            \n [71] future.apply_1.11.0       goftest_1.2-3            \n [73] glue_1.6.2                nlme_3.1-163             \n [75] promises_1.2.0.1          grid_4.3.2               \n [77] Rtsne_0.16                cluster_2.1.4            \n [79] reshape2_1.4.4            generics_0.1.3           \n [81] spatstat.data_3.0-1       gtable_0.3.3             \n [83] tidyr_1.3.0               BiocSingular_1.16.0      \n [85] ScaledMatrix_1.8.1        sp_2.1-1                 \n [87] utf8_1.2.3                spatstat.geom_3.2-4      \n [89] BiocGenerics_0.46.0       RcppAnnoy_0.0.21         \n [91] ggrepel_0.9.3             RANN_2.6.1               \n [93] foreach_1.5.2             pillar_1.9.0             \n [95] stringr_1.5.0             spam_2.10-0              \n [97] RcppHNSW_0.5.0            later_1.3.1              \n [99] circlize_0.4.15           splines_4.3.2            \n[101] dplyr_1.1.2               lattice_0.22-5           \n[103] deldir_1.0-9              survival_3.5-7           \n[105] tidyselect_1.2.0          ComplexHeatmap_2.16.0    \n[107] miniUI_0.1.1.1            pbapply_1.7-2            \n[109] knitr_1.43                gridExtra_2.3            \n[111] IRanges_2.34.1            scattermore_1.2          \n[113] stats4_4.3.2              xfun_0.39                \n[115] matrixStats_1.1.0         stringi_1.8.1            \n[117] lazyeval_0.2.2            yaml_2.3.7               \n[119] evaluate_0.21             codetools_0.2-19         \n[121] tibble_3.2.1              cli_3.6.1                \n[123] uwot_0.1.16               RcppParallel_5.1.7       \n[125] xtable_1.8-4              reticulate_1.34.0        \n[127] munsell_0.5.0             Rcpp_1.0.11              \n[129] spatstat.random_3.2-1     globals_0.16.2           \n[131] png_0.1-8                 parallel_4.3.2           \n[133] Rfast_2.1.0               ellipsis_0.3.2           \n[135] assertthat_0.2.1          ggplot2_3.4.2            \n[137] dotCall64_1.1-0           parallelDist_0.2.6       \n[139] sparseMatrixStats_1.12.2  listenv_0.9.0            \n[141] ggthemes_4.2.4            viridisLite_0.4.2        \n[143] scales_1.2.1              ggridges_0.5.4           \n[145] SeuratObject_5.0.0        leiden_0.4.3             \n[147] purrr_1.0.1               crayon_1.5.2             \n[149] GetoptLong_1.0.5          cowplot_1.1.1"
  },
  {
    "objectID": "OriginalClustersDistanceEvaluation.html",
    "href": "OriginalClustersDistanceEvaluation.html",
    "title": "Original Clusters Distance Evaluation",
    "section": "",
    "text": "library(COTAN)\nlibrary(stringr)\nlibrary(tidyverse)"
  },
  {
    "objectID": "OriginalClustersDistanceEvaluation.html#extract-the-row-matrix-for-each-cluster",
    "href": "OriginalClustersDistanceEvaluation.html#extract-the-row-matrix-for-each-cluster",
    "title": "Original Clusters Distance Evaluation",
    "section": "Extract the row matrix for each cluster",
    "text": "Extract the row matrix for each cluster\nThis is done on the La Manno Mouse Brain dataset (2021)\n\nE13.5\n\nE13.5Clusters.code &lt;- c(432,187,434,184,437,510)\n\nfb135Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e13.5_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition &lt;- getMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nfor (cl in E13.5Clusters.code) {\n  cells &lt;- names(getClusters(fb135Obj, \n      clName = \"original.clusters\")[getClusters(fb135Obj, \n                          clName = \"original.clusters\") == cl])\n\nCLRawData &lt;- getRawData(fb135Obj)[,cells]\n\nsaveRDS(CLRawData,file = paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/Cl\",cl,sampleCondition,\"RawData.RDS\"))  \n}\n\n\n\nE15.0\n\nE15.0Clusters.code &lt;- c(432,509,510,508,428,434,437)\n\nfb150Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e15.0_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition &lt;- getMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\nfor (cl in E15.0Clusters.code) {\n  cells &lt;- names(getClusters(fb150Obj, \n      clName = \"original.clusters\")[getClusters(fb150Obj, \n                          clName = \"original.clusters\") == cl])\n\nCLRawData &lt;- getRawData(fb150Obj)[,cells]\n\nsaveRDS(CLRawData,file = paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/Cl\",cl,sampleCondition,\"RawData.RDS\"))  \n}\n\n\n\nE17.5\n\nE17.5Clusters.code &lt;- c(516,505)\n\nfb175Obj &lt;- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"E17.5_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition &lt;- getMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])\n\nfor (cl in E17.5Clusters.code) {\n  cells &lt;- names(getClusters(fb175Obj, \n      clName = \"original.clusters\")[getClusters(fb175Obj, \n                          clName = \"original.clusters\") == cl])\n\nCLRawData &lt;- getRawData(fb175Obj)[,cells]\n\nsaveRDS(CLRawData,file = paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/Cl\",cl,sampleCondition,\"RawData.RDS\"))  \n}"
  },
  {
    "objectID": "OriginalClustersDistanceEvaluation.html#defining-the-two-distances",
    "href": "OriginalClustersDistanceEvaluation.html#defining-the-two-distances",
    "title": "Original Clusters Distance Evaluation",
    "section": "Defining the two distances",
    "text": "Defining the two distances\nTo roughly determine the cluster distances we decided to test two simple Euclidean distances:\n\nover the mean of the 0/1 raw matrix\nover the \\(1-e^{-\\lambda}\\) where \\(\\lambda\\) is the average expression for the genes.\n\n\nClFiles &lt;- list.files(\"Data/MouseCortexFromLoom/SingleClusterRawData/\")\n\ntot.Df.ZeroOne &lt;- NA\ntot.Df.Lambda &lt;- NA\nfor(Fl in ClFiles) {\n  print(Fl)\n  cl &lt;- str_split(Fl,pattern = \"_\",simplify = T)[1]\n  data &lt;- readRDS(paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/\",\n                         Fl))\n  \n  obj &lt;- COTAN(data)\n  \n  ZeroOne &lt;- rowMeans(as.matrix(getZeroOneProj(obj)))\n  tot.Df.ZeroOne &lt;- merge(tot.Df.ZeroOne,ZeroOne,by = 0,all = T)\n  tot.Df.ZeroOne[is.na(tot.Df.ZeroOne)] &lt;- 0\n  colnames(tot.Df.ZeroOne)[ncol(tot.Df.ZeroOne)] &lt;- cl\n  tot.Df.ZeroOne &lt;- column_to_rownames(tot.Df.ZeroOne,var = \"Row.names\")\n  \n  obj &lt;- estimateLambdaLinear(obj)\n  Lambda &lt;- getLambda(obj)\n  tot.Df.Lambda &lt;- merge(tot.Df.Lambda,1-exp(-Lambda),by = 0, all = T)\n  tot.Df.Lambda[is.na(tot.Df.Lambda)] &lt;- 0\n  colnames(tot.Df.Lambda)[ncol(tot.Df.Lambda)] &lt;- cl\n  tot.Df.Lambda &lt;- column_to_rownames(tot.Df.Lambda,var = \"Row.names\")\n  \n}\ntot.Df.Lambda &lt;- tot.Df.Lambda[,2:ncol(tot.Df.Lambda)]\ntot.Df.ZeroOne &lt;- tot.Df.ZeroOne[,2:ncol(tot.Df.ZeroOne)]\n\ntot.Df.Lambda &lt;- tot.Df.Lambda[2:nrow(tot.Df.Lambda),]\ntot.Df.ZeroOne &lt;- tot.Df.ZeroOne[2:nrow(tot.Df.Lambda),]\n\n\nhead(tot.Df.Lambda)\nhead(tot.Df.ZeroOne)\n\n\nsaveRDS(tot.Df.Lambda, \"Data/MouseCortexFromLoom/ClustersDistances/Tot.Df.Lambda.RDS\")\nsaveRDS(tot.Df.ZeroOne, \"Data/MouseCortexFromLoom/ClustersDistances/Tot.Df.ZeroOne.RDS\")\n\n\nlibrary(ComplexHeatmap)\ndistance.df.Lambda &lt;- as.matrix(dist(t(tot.Df.Lambda),diag = T,upper = T))\n\nHeatmap(distance.df.Lambda,\n        name = \"Lambda\\ndistance\", \n        cell_fun = function(j, i, x, y, width, height, fill) \n        {\n          grid.text(sprintf(\"%.1f\", distance.df.Lambda[i, j]), x, y, gp = gpar(fontsize = 10))\n        },\n        show_row_dend = F, \n        show_row_names = F)\n\n\n\n\n\ndistance.df.ZeroOne &lt;- as.matrix(dist(t(tot.Df.ZeroOne),diag = T,upper = T))\n\nHeatmap(distance.df.ZeroOne,\n        name = \"ZeroOne\\ndistance\", \n        cell_fun = function(j, i, x, y, width, height, fill) \n        {\n          grid.text(sprintf(\"%.1f\", distance.df.ZeroOne[i, j]), x, y, gp = gpar(fontsize = 10))\n        },\n        show_row_dend = F, \n        show_row_names = F)\n\n\n\n\nThe distances are very similar with the Zero One a little lower as values…\n\ndistance.df.Lambda.Plot &lt;- rownames_to_column(as.data.frame(distance.df.Lambda),\n                                              var = \"Cl.1\")\ndistance.df.Lambda.Plot &lt;-pivot_longer(distance.df.Lambda.Plot,\n                                       cols = !Cl.1,\n                                       names_to = \"Cl.2\", \n                                       values_to = \"Lambda.Dist\")\n\ndistance.df.ZeroOne.Plot &lt;- rownames_to_column(as.data.frame(distance.df.ZeroOne),\n                                              var = \"Cl.1\")\ndistance.df.ZeroOne.Plot &lt;-pivot_longer(distance.df.ZeroOne.Plot,\n                                       cols = !Cl.1,\n                                       names_to = \"Cl.2\", \n                                       values_to = \"ZeroOne.Dist\")\n\ndistance.df.Tot &lt;- merge(distance.df.ZeroOne.Plot,distance.df.Lambda.Plot,by= c(\"Cl.1\",\"Cl.2\"),all=T)\n\nggplot(as.data.frame(distance.df.Tot),aes(x=ZeroOne.Dist, y=Lambda.Dist))+geom_point()\n\n\n\n\nSo for what we are using it is the same.\nThe key information is that we can define couple of, in one case, triplets of very near clusters:\n\nCl510e13.5 and Cl510e15.0\nCl516e17.5 and Cl505e17.5\nCl509e15.0 and Cl508e15.0 which are also similar to Cl432e13.5 and Cl432e15.0\nCl432e13.5 and Cl432e15.0\nCl437e13.5 and Cl437e15.0\nCl428e15.0, Cl434e15.0 and Cl434e13.5\n\nBased on these distances we can consider three thresholds (with number of cluster pair):\n\nless than 7 (first quartile)\n\nsum(distance.df.ZeroOne &lt; 7.1 & distance.df.ZeroOne &gt; 0)/2\n\n[1] 19\n\n\nbetween 9 and 11 (around median)\n\nsum(distance.df.ZeroOne &gt; 9 & distance.df.ZeroOne &lt; 11)/2\n\n[1] 20\n\n\nmore than 13 (3rd quartile)\n\nsum(distance.df.ZeroOne &gt; 13)/2\n\n[1] 32\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ComplexHeatmap_2.16.0 lubridate_1.9.2       forcats_1.0.0        \n [4] dplyr_1.1.2           purrr_1.0.1           readr_2.1.4          \n [7] tidyr_1.3.0           tibble_3.2.1          ggplot2_3.4.2        \n[10] tidyverse_2.0.0       stringr_1.5.0         COTAN_2.3.0          \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               polyclip_1.10-4          \n  [5] fastDummies_1.7.3         lifecycle_1.0.3          \n  [7] doParallel_1.0.17         globals_0.16.2           \n  [9] lattice_0.22-5            MASS_7.3-60              \n [11] dendextend_1.17.1         magrittr_2.0.3           \n [13] plotly_4.10.2             rmarkdown_2.24           \n [15] yaml_2.3.7                httpuv_1.6.11            \n [17] Seurat_5.0.0              sctransform_0.4.1        \n [19] spam_2.10-0               askpass_1.2.0            \n [21] sp_2.1-1                  spatstat.sparse_3.0-2    \n [23] reticulate_1.34.0         cowplot_1.1.1            \n [25] pbapply_1.7-2             RColorBrewer_1.1-3       \n [27] abind_1.4-5               Rtsne_0.16               \n [29] BiocGenerics_0.46.0       circlize_0.4.15          \n [31] IRanges_2.34.1            S4Vectors_0.38.1         \n [33] ggrepel_0.9.3             irlba_2.3.5.1            \n [35] listenv_0.9.0             spatstat.utils_3.0-3     \n [37] umap_0.2.10.0             goftest_1.2-3            \n [39] RSpectra_0.16-1           spatstat.random_3.2-1    \n [41] dqrng_0.3.0               fitdistrplus_1.1-11      \n [43] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [45] leiden_0.4.3              codetools_0.2-19         \n [47] DelayedArray_0.26.7       tidyselect_1.2.0         \n [49] shape_1.4.6               farver_2.1.1             \n [51] ScaledMatrix_1.8.1        viridis_0.6.4            \n [53] matrixStats_1.1.0         stats4_4.3.2             \n [55] spatstat.explore_3.2-1    jsonlite_1.8.7           \n [57] GetoptLong_1.0.5          ellipsis_0.3.2           \n [59] progressr_0.14.0          ggridges_0.5.4           \n [61] survival_3.5-7            iterators_1.0.14         \n [63] foreach_1.5.2             tools_4.3.2              \n [65] ica_1.0-3                 Rcpp_1.0.11              \n [67] glue_1.6.2                gridExtra_2.3            \n [69] xfun_0.39                 MatrixGenerics_1.12.3    \n [71] ggthemes_4.2.4            withr_2.5.0              \n [73] fastmap_1.1.1             fansi_1.0.4              \n [75] openssl_2.1.0             digest_0.6.33            \n [77] rsvd_1.0.5                timechange_0.2.0         \n [79] parallelDist_0.2.6        R6_2.5.1                 \n [81] mime_0.12                 colorspace_2.1-0         \n [83] Cairo_1.6-1               scattermore_1.2          \n [85] tensor_1.5                spatstat.data_3.0-1      \n [87] utf8_1.2.3                generics_0.1.3           \n [89] data.table_1.14.8         httr_1.4.6               \n [91] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [93] uwot_0.1.16               pkgconfig_2.0.3          \n [95] gtable_0.3.3              lmtest_0.9-40            \n [97] htmltools_0.5.5           dotCall64_1.1-0          \n [99] clue_0.3-64               SeuratObject_5.0.0       \n[101] scales_1.2.1              png_0.1-8                \n[103] knitr_1.43                rstudioapi_0.15.0        \n[105] tzdb_0.4.0                reshape2_1.4.4           \n[107] rjson_0.2.21              nlme_3.1-163             \n[109] zoo_1.8-12                GlobalOptions_0.1.2      \n[111] KernSmooth_2.23-22        parallel_4.3.2           \n[113] miniUI_0.1.1.1            RcppZiggurat_0.1.6       \n[115] pillar_1.9.0              vctrs_0.6.3              \n[117] RANN_2.6.1                promises_1.2.0.1         \n[119] BiocSingular_1.16.0       beachmat_2.16.0          \n[121] xtable_1.8-4              cluster_2.1.4            \n[123] evaluate_0.21             zeallot_0.1.0            \n[125] cli_3.6.1                 compiler_4.3.2           \n[127] rlang_1.1.1               crayon_1.5.2             \n[129] future.apply_1.11.0       labeling_0.4.2           \n[131] plyr_1.8.8                stringi_1.8.1            \n[133] viridisLite_0.4.2         deldir_1.0-9             \n[135] BiocParallel_1.34.2       assertthat_0.2.1         \n[137] munsell_0.5.0             lazyeval_0.2.2           \n[139] spatstat.geom_3.2-4       PCAtools_2.14.0          \n[141] Matrix_1.6-2              RcppHNSW_0.5.0           \n[143] hms_1.1.3                 patchwork_1.1.2          \n[145] sparseMatrixStats_1.12.2  future_1.33.0            \n[147] shiny_1.7.5               ROCR_1.0-11              \n[149] Rfast_2.1.0               igraph_1.5.1             \n[151] RcppParallel_5.1.7"
  },
  {
    "objectID": "PBMC2_filtering.html",
    "href": "PBMC2_filtering.html",
    "title": "Filtering of PBMC2 using COTAN",
    "section": "",
    "text": "Library import\n\nlibrary(dplyr)\nlibrary(COTAN)\nlibrary(Seurat)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(DropletUtils)\n\nSettings\n\ndatasetName = 'PBMC2'\ndatasetFolder = './Data/'\n\ninDir  = paste(datasetFolder, datasetName, '/raw/10X/', sep='')\noutDir = paste(datasetFolder, datasetName, '/filtered/', sep='')\ndir10X = paste(outDir, '10X/', sep='')\n\nif (!dir.exists(outDir)) {\n  dir.create(outDir, recursive = TRUE, showWarnings = FALSE)\n}\n\nsetLoggingLevel(2)\nsetLoggingFile(paste(outDir, \"logfile.log\", sep=\"\"))\noptions(parallelly.fork.enable = TRUE)\n\nData loading\n\ndataset = Read10X(data.dir = inDir, strip.suffix = TRUE)\ndataset = dataset[[1]]\nsampleCond &lt;- datasetName\nPBMC2 &lt;- COTAN(raw = dataset)\nPBMC2 &lt;- initializeMetaDataset(\n  PBMC2,\n  GEO = paste(\"10X \", datasetName, sep=\"\"),\n  sequencingMethod = \"10X\",\n  sampleCond = sampleCond\n)\n\nInspect cells’ sizes\n\ncellSizePlot(PBMC2)\n\n\n\n\nDrop cells with too many reads as they are probably doublets\n\ncellsSizeThr &lt;- 20000\nPBMC2 &lt;- addElementToMetaDataset(PBMC2, \"Cells size threshold\", cellsSizeThr)\n\ncellsToRem &lt;- getCells(PBMC2)[getCellsSize(PBMC2) &gt; cellsSizeThr]\nPBMC2 &lt;- dropGenesCells(PBMC2, cells = cellsToRem)\n\ncellSizePlot(PBMC2, splitPattern = \"-\", numCol = 2)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(PBMC2, splitPattern = \"-\", numCol = 2)\n\n\n\n\nDrop cells with too high genes expression as they are probably doublets\n\ngeneSizeThr &lt;- 3500\nPBMC2 &lt;- addElementToMetaDataset(PBMC2, \"Num genes threshold\", geneSizeThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(PBMC2)\ncellsToRem &lt;- names(numExprGenes)[numExprGenes &gt; geneSizeThr]\nPBMC2 &lt;- dropGenesCells(PBMC2, cells = cellsToRem)\n\ngenesSizePlot(PBMC2, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCheck number of mithocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^[Mm][Tt]-\"\ngetGenes(PBMC2)[grep(mitGenesPattern, getGenes(PBMC2))]\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\n\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC2, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nWe drop cells with a too high percentage of mitocondrial genes (are likely dead)\n\nmitPercThr &lt;- 10\nPBMC2 &lt;- addElementToMetaDataset(PBMC2, \"Mitoc. perc. threshold\", mitPercThr)\n\ncellsToRem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\nPBMC2 &lt;- dropGenesCells(PBMC2, cells = cellsToRem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC2, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nCheck number of ribosomial genes expressed in each cell\n\nribGenesPattern &lt;- \"^RP[SL]\\\\d+\"\ngetGenes(PBMC2)[grep(ribGenesPattern, getGenes(PBMC2))]\n\n [1] \"RPL22\"       \"RPL11\"       \"RPS6KA1\"     \"RPS8\"        \"RPL5\"       \n [6] \"RPS27\"       \"RPS6KC1\"     \"RPS7\"        \"RPS27A\"      \"RPL31\"      \n[11] \"RPL37A\"      \"RPL32\"       \"RPL15\"       \"RPL14\"       \"RPL29\"      \n[16] \"RPL24\"       \"RPL22L1\"     \"RPL39L\"      \"RPL35A\"      \"RPL9\"       \n[21] \"RPL34-AS1\"   \"RPL34\"       \"RPS3A\"       \"RPL37\"       \"RPS23\"      \n[26] \"RPS14\"       \"RPL26L1\"     \"RPS18\"       \"RPS10-NUDT3\" \"RPS10\"      \n[31] \"RPL10A\"      \"RPL7L1\"      \"RPS12\"       \"RPS6KA2\"     \"RPS6KA2-IT1\"\n[36] \"RPS6KA2-AS1\" \"RPS20\"       \"RPL7\"        \"RPL30\"       \"RPL8\"       \n[41] \"RPS6\"        \"RPL35\"       \"RPL12\"       \"RPL7A\"       \"RPS24\"      \n[46] \"RPL27A\"      \"RPS13\"       \"RPS6KA4\"     \"RPS6KB2\"     \"RPS6KB2-AS1\"\n[51] \"RPS3\"        \"RPS25\"       \"RPS26\"       \"RPL41\"       \"RPL6\"       \n[56] \"RPL21\"       \"RPL10L\"      \"RPS29\"       \"RPL36AL\"     \"RPS6KL1\"    \n[61] \"RPS6KA5\"     \"RPS27L\"      \"RPL4\"        \"RPS17\"       \"RPL3L\"      \n[66] \"RPS2\"        \"RPS15A\"      \"RPL13\"       \"RPL26\"       \"RPL23A\"     \n[71] \"RPL23\"       \"RPL19\"       \"RPL27\"       \"RPS6KB1\"     \"RPL38\"      \n[76] \"RPL17\"       \"RPS15\"       \"RPL36\"       \"RPS28\"       \"RPL18A\"     \n[81] \"RPS16\"       \"RPS19\"       \"RPL18\"       \"RPL13A\"      \"RPS11\"      \n[86] \"RPS9\"        \"RPL28\"       \"RPS5\"        \"RPS21\"       \"RPL3\"       \n[91] \"RPS19BP1\"    \"RPS6KA3\"     \"RPS4X\"       \"RPS6KA6\"     \"RPL36A\"     \n[96] \"RPL39\"       \"RPL10\"       \"RPS4Y1\"      \"RPS4Y2\"     \n\n\n\nc(ribPlot, ribSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC2, genePrefix = ribGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(ribPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(PBMC2, splitPattern = \"-\", numCol = 2)\n\n\n\n\n\ngenesSizePlot(PBMC2, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCleaning, round 1\n\nPBMC2 &lt;- clean(PBMC2)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC2)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nPBMC2 &lt;- addElementToMetaDataset(PBMC2, \"Num drop B group\", 0)\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)  \n\n\n\n\n\nyset=0.16\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(PBMC2)), \"n\" = seq_along(getNu(PBMC2)))\nPBMC2 &lt;- addElementToMetaDataset(PBMC2, \"Threshold low UDE cells:\", yset)\ncellsToRem &lt;-rownames(nuDf)[nuDf[[\"nu\"]] &lt; yset]\nPBMC2 &lt;- dropGenesCells(PBMC2, cells = cellsToRem)\n\nCleaning, round 2\n\nPBMC2 &lt;- clean(PBMC2)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC2)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(pcaCellsData)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\n\nplot(cellSizePlot(PBMC2, splitPattern = \"-\", numCol = 2))\n\n\n\n\n\nplot(genesSizePlot(PBMC2, splitPattern = \"-\", numCol = 2))\n\n\n\n\nSave the filtered dataset\n\nif (!dir.exists(dir10X)) {\n  write10xCounts(dir10X, getRawData(PBMC2))\n}\n\n\nsaveRDS(PBMC2, file = paste0(outDir, sampleCond, \".cotan.RDS\"))\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] DropletUtils_1.20.0         SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 Biobase_2.60.0             \n [5] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1        \n [7] IRanges_2.34.1              S4Vectors_0.38.1           \n [9] BiocGenerics_0.46.0         MatrixGenerics_1.12.3      \n[11] matrixStats_1.2.0           zeallot_0.1.0              \n[13] ggplot2_3.4.2               tibble_3.2.1               \n[15] Seurat_5.0.0                SeuratObject_5.0.0         \n[17] sp_2.1-1                    COTAN_2.3.0                \n[19] dplyr_1.1.2                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] R.oo_1.25.0               polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] edgeR_3.42.4              doParallel_1.0.17        \n [11] globals_0.16.2            lattice_0.22-5           \n [13] MASS_7.3-60               dendextend_1.17.1        \n [15] magrittr_2.0.3            limma_3.56.2             \n [17] plotly_4.10.2             rmarkdown_2.24           \n [19] yaml_2.3.7                httpuv_1.6.11            \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.34.0         cowplot_1.1.1            \n [27] pbapply_1.7-2             RColorBrewer_1.1-3       \n [29] zlibbioc_1.46.0           abind_1.4-5              \n [31] Rtsne_0.16                R.utils_2.12.2           \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] circlize_0.4.15           GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       scuttle_1.10.2           \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              ScaledMatrix_1.8.1       \n [57] viridis_0.6.4             spatstat.explore_3.2-1   \n [59] jsonlite_1.8.7            GetoptLong_1.0.5         \n [61] ellipsis_0.3.2            progressr_0.14.0         \n [63] ggridges_0.5.4            survival_3.5-7           \n [65] iterators_1.0.14          foreach_1.5.2            \n [67] tools_4.3.2               ica_1.0-3                \n [69] Rcpp_1.0.11               glue_1.6.2               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            HDF5Array_1.28.1         \n [75] withr_2.5.0               fastmap_1.1.1            \n [77] rhdf5filters_1.12.1       fansi_1.0.4              \n [79] openssl_2.1.0             digest_0.6.33            \n [81] rsvd_1.0.5                parallelDist_0.2.6       \n [83] R6_2.5.1                  mime_0.12                \n [85] colorspace_2.1-0          scattermore_1.2          \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] R.methodsS3_1.8.2         utf8_1.2.3               \n [91] tidyr_1.3.0               generics_0.1.3           \n [93] data.table_1.14.8         httr_1.4.6               \n [95] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [97] uwot_0.1.16               pkgconfig_2.0.3          \n [99] gtable_0.3.3              ComplexHeatmap_2.16.0    \n[101] lmtest_0.9-40             XVector_0.40.0           \n[103] htmltools_0.5.7           dotCall64_1.1-0          \n[105] clue_0.3-64               scales_1.3.0             \n[107] png_0.1-8                 knitr_1.43               \n[109] rstudioapi_0.15.0         reshape2_1.4.4           \n[111] rjson_0.2.21              nlme_3.1-163             \n[113] rhdf5_2.44.0              zoo_1.8-12               \n[115] GlobalOptions_0.1.2       stringr_1.5.0            \n[117] KernSmooth_2.23-22        parallel_4.3.2           \n[119] miniUI_0.1.1.1            RcppZiggurat_0.1.6       \n[121] pillar_1.9.0              grid_4.3.2               \n[123] vctrs_0.6.3               RANN_2.6.1               \n[125] promises_1.2.0.1          BiocSingular_1.16.0      \n[127] beachmat_2.16.0           xtable_1.8-4             \n[129] cluster_2.1.6             evaluate_0.21            \n[131] locfit_1.5-9.8            cli_3.6.1                \n[133] compiler_4.3.2            rlang_1.1.1              \n[135] crayon_1.5.2              future.apply_1.11.0      \n[137] labeling_0.4.2            plyr_1.8.8               \n[139] stringi_1.8.1             viridisLite_0.4.2        \n[141] deldir_2.0-2              BiocParallel_1.34.2      \n[143] assertthat_0.2.1          munsell_0.5.0            \n[145] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[147] PCAtools_2.14.0           Matrix_1.6-3             \n[149] RcppHNSW_0.5.0            patchwork_1.1.2          \n[151] sparseMatrixStats_1.12.2  future_1.33.0            \n[153] Rhdf5lib_1.22.0           shiny_1.8.0              \n[155] ROCR_1.0-11               Rfast_2.1.0              \n[157] igraph_1.6.0              RcppParallel_5.1.7"
  },
  {
    "objectID": "PBMC4_filtering.html",
    "href": "PBMC4_filtering.html",
    "title": "Filtering of PBMC4 using COTAN",
    "section": "",
    "text": "Library import\n\nlibrary(dplyr)\nlibrary(COTAN)\nlibrary(Seurat)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(DropletUtils)\n\nSettings\n\ndatasetName = 'PBMC4'\ndatasetFolder = './Data/'\n\ninDir  = paste(datasetFolder, datasetName, '/raw/10X/', sep='')\noutDir = paste(datasetFolder, datasetName, '/filtered/', sep='')\ndir10X = paste(outDir, '10X/', sep='')\n\nif (!dir.exists(outDir)) {\n  dir.create(outDir, recursive = TRUE, showWarnings = FALSE)\n}\n\nsetLoggingLevel(2)\nsetLoggingFile(paste(outDir, \"logfile.log\", sep=\"\"))\noptions(parallelly.fork.enable = TRUE)\n\nData loading\n\ndataset = Read10X(data.dir = inDir, strip.suffix = TRUE)\ndataset = dataset[[1]]\nsampleCond &lt;- datasetName\nPBMC4 &lt;- COTAN(raw = dataset)\nPBMC4 &lt;- initializeMetaDataset(\n  PBMC4,\n  GEO = paste(\"10X \", datasetName, sep=\"\"),\n  sequencingMethod = \"10X\",\n  sampleCond = sampleCond\n)\n\nInspect cells’ sizes\n\ncellSizePlot(PBMC4)\n\n\n\n\nDrop cells with too many reads as they are probably doublets\n\ncellsSizeThr &lt;- 20000\nPBMC4 &lt;- addElementToMetaDataset(PBMC4, \"Cells size threshold\", cellsSizeThr)\n\ncellsToRem &lt;- getCells(PBMC4)[getCellsSize(PBMC4) &gt; cellsSizeThr]\nPBMC4 &lt;- dropGenesCells(PBMC4, cells = cellsToRem)\n\ncellSizePlot(PBMC4, splitPattern = \"-\", numCol = 2)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(PBMC4, splitPattern = \"-\", numCol = 2)\n\n\n\n\nDrop cells with too high genes expression as they are probably doublets\n\ngeneSizeThr &lt;- 3500\nPBMC4 &lt;- addElementToMetaDataset(PBMC4, \"Num genes threshold\", geneSizeThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(PBMC4)\ncellsToRem &lt;- names(numExprGenes)[numExprGenes &gt; geneSizeThr]\nPBMC4 &lt;- dropGenesCells(PBMC4, cells = cellsToRem)\n\ngenesSizePlot(PBMC4, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCheck number of mithocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^[Mm][Tt]-\"\ngetGenes(PBMC4)[grep(mitGenesPattern, getGenes(PBMC4))]\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\n\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC4, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nWe drop cells with a too high percentage of mitocondrial genes (are likely dead)\n\nmitPercThr &lt;- 10\nPBMC4 &lt;- addElementToMetaDataset(PBMC4, \"Mitoc. perc. threshold\", mitPercThr)\n\ncellsToRem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\nPBMC4 &lt;- dropGenesCells(PBMC4, cells = cellsToRem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC4, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nCheck number of ribosomial genes expressed in each cell\n\nribGenesPattern &lt;- \"^RP[SL]\\\\d+\"\ngetGenes(PBMC4)[grep(ribGenesPattern, getGenes(PBMC4))]\n\n  [1] \"RPL22\"          \"RPL11\"          \"RPS6KA1\"        \"RPS8\"          \n  [5] \"RPL5\"           \"RPS27\"          \"RPS6KC1\"        \"RPS7\"          \n  [9] \"RPS27A\"         \"RPL31\"          \"RPL37A\"         \"RPL32\"         \n [13] \"RPL15\"          \"RPL14\"          \"RPL29\"          \"RPL24\"         \n [17] \"RPL22L1\"        \"RPL39L\"         \"RPL35A\"         \"RPL9\"          \n [21] \"RPL34-AS1\"      \"RPL34\"          \"RPS3A\"          \"RPL37\"         \n [25] \"RPS23\"          \"RPS14\"          \"RPL26L1\"        \"RPS18\"         \n [29] \"RPS10-NUDT3\"    \"RPS10\"          \"RPL10A\"         \"RPL7L1\"        \n [33] \"RPS12\"          \"RPS6KA2\"        \"RPS6KA2-AS1\"    \"RPS6KA3\"       \n [37] \"RPS4X\"          \"RPS6KA6\"        \"RPL36A\"         \"RPL36A-HNRNPH2\"\n [41] \"RPL39\"          \"RPL10\"          \"RPS20\"          \"RPL7\"          \n [45] \"RPL30\"          \"RPL8\"           \"RPS6\"           \"RPL35\"         \n [49] \"RPL12\"          \"RPL7A\"          \"RPL27A\"         \"RPS13\"         \n [53] \"RPS6KA4\"        \"RPS6KB2\"        \"RPS6KB2-AS1\"    \"RPS3\"          \n [57] \"RPS25\"          \"RPS24\"          \"RPS26\"          \"RPL41\"         \n [61] \"RPL6\"           \"RPL21\"          \"RPL10L\"         \"RPS29\"         \n [65] \"RPL36AL\"        \"RPS6KL1\"        \"RPS6KA5\"        \"RPS27L\"        \n [69] \"RPL4\"           \"RPS17\"          \"RPL3L\"          \"RPS2\"          \n [73] \"RPS15A\"         \"RPL13\"          \"RPL26\"          \"RPL23A\"        \n [77] \"RPL23\"          \"RPL19\"          \"RPL27\"          \"RPS6KB1\"       \n [81] \"RPL38\"          \"RPL17-C18orf32\" \"RPL17\"          \"RPS21\"         \n [85] \"RPS15\"          \"RPL36\"          \"RPS28\"          \"RPL18A\"        \n [89] \"RPS16\"          \"RPS19\"          \"RPL18\"          \"RPL13A\"        \n [93] \"RPS11\"          \"RPS9\"           \"RPL28\"          \"RPS5\"          \n [97] \"RPS4Y1\"         \"RPS4Y2\"         \"RPL3\"           \"RPS19BP1\"      \n\n\n\nc(ribPlot, ribSizes) %&lt;-%\n  mitochondrialPercentagePlot(PBMC4, genePrefix = ribGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(ribPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(PBMC4, splitPattern = \"-\", numCol = 2)\n\n\n\n\n\ngenesSizePlot(PBMC4, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCleaning, round 1\n\nPBMC4 &lt;- clean(PBMC4)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC4)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nPBMC4 &lt;- addElementToMetaDataset(PBMC4, \"Num drop B group\", 0)\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)  \n\n\n\n\n\nyset=0.16\nnuDf &lt;- data.frame(\"nu\" = sort(getNu(PBMC4)), \"n\" = seq_along(getNu(PBMC4)))\nPBMC4 &lt;- addElementToMetaDataset(PBMC4, \"Threshold low UDE cells:\", yset)\ncellsToRem &lt;-rownames(nuDf)[nuDf[[\"nu\"]] &lt; yset]\nPBMC4 &lt;- dropGenesCells(PBMC4, cells = cellsToRem)\n\nCleaning, round 2\n\nPBMC4 &lt;- clean(PBMC4)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(PBMC4)\n\nplot(pcaCellsPlot)\n\n\n\n\n\nplot(pcaCellsData)\n\n\n\n\n\nplot(genesPlot)\n\n\n\n\n\nplot(UDEPlot)\n\n\n\n\n\nplot(nuPlot)\n\n\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\n\nplot(cellSizePlot(PBMC4, splitPattern = \"-\", numCol = 2))\n\n\n\n\n\nplot(genesSizePlot(PBMC4, splitPattern = \"-\", numCol = 2))\n\n\n\n\nSave the filtered dataset\n\nif (!dir.exists(dir10X)) {\n  write10xCounts(dir10X, getRawData(PBMC4))\n}\n\n\nsaveRDS(PBMC4, file = paste0(outDir, sampleCond, \".cotan.RDS\"))\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] DropletUtils_1.20.0         SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 Biobase_2.60.0             \n [5] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1        \n [7] IRanges_2.34.1              S4Vectors_0.38.1           \n [9] BiocGenerics_0.46.0         MatrixGenerics_1.12.3      \n[11] matrixStats_1.2.0           zeallot_0.1.0              \n[13] ggplot2_3.4.2               tibble_3.2.1               \n[15] Seurat_5.0.0                SeuratObject_5.0.0         \n[17] sp_2.1-1                    COTAN_2.3.0                \n[19] dplyr_1.1.2                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] R.oo_1.25.0               polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] edgeR_3.42.4              doParallel_1.0.17        \n [11] globals_0.16.2            lattice_0.22-5           \n [13] MASS_7.3-60               dendextend_1.17.1        \n [15] magrittr_2.0.3            limma_3.56.2             \n [17] plotly_4.10.2             rmarkdown_2.24           \n [19] yaml_2.3.7                httpuv_1.6.11            \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.34.0         cowplot_1.1.1            \n [27] pbapply_1.7-2             RColorBrewer_1.1-3       \n [29] zlibbioc_1.46.0           abind_1.4-5              \n [31] Rtsne_0.16                R.utils_2.12.2           \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] circlize_0.4.15           GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] umap_0.2.10.0             goftest_1.2-3            \n [43] RSpectra_0.16-1           spatstat.random_3.2-1    \n [45] dqrng_0.3.0               fitdistrplus_1.1-11      \n [47] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [49] leiden_0.4.3              codetools_0.2-19         \n [51] DelayedArray_0.26.7       scuttle_1.10.2           \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              ScaledMatrix_1.8.1       \n [57] viridis_0.6.4             spatstat.explore_3.2-1   \n [59] jsonlite_1.8.7            GetoptLong_1.0.5         \n [61] ellipsis_0.3.2            progressr_0.14.0         \n [63] ggridges_0.5.4            survival_3.5-7           \n [65] iterators_1.0.14          foreach_1.5.2            \n [67] tools_4.3.2               ica_1.0-3                \n [69] Rcpp_1.0.11               glue_1.6.2               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            HDF5Array_1.28.1         \n [75] withr_2.5.0               fastmap_1.1.1            \n [77] rhdf5filters_1.12.1       fansi_1.0.4              \n [79] openssl_2.1.0             digest_0.6.33            \n [81] rsvd_1.0.5                parallelDist_0.2.6       \n [83] R6_2.5.1                  mime_0.12                \n [85] colorspace_2.1-0          scattermore_1.2          \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] R.methodsS3_1.8.2         utf8_1.2.3               \n [91] tidyr_1.3.0               generics_0.1.3           \n [93] data.table_1.14.8         httr_1.4.6               \n [95] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [97] uwot_0.1.16               pkgconfig_2.0.3          \n [99] gtable_0.3.3              ComplexHeatmap_2.16.0    \n[101] lmtest_0.9-40             XVector_0.40.0           \n[103] htmltools_0.5.7           dotCall64_1.1-0          \n[105] clue_0.3-64               scales_1.3.0             \n[107] png_0.1-8                 knitr_1.43               \n[109] rstudioapi_0.15.0         reshape2_1.4.4           \n[111] rjson_0.2.21              nlme_3.1-163             \n[113] rhdf5_2.44.0              zoo_1.8-12               \n[115] GlobalOptions_0.1.2       stringr_1.5.0            \n[117] KernSmooth_2.23-22        parallel_4.3.2           \n[119] miniUI_0.1.1.1            RcppZiggurat_0.1.6       \n[121] pillar_1.9.0              grid_4.3.2               \n[123] vctrs_0.6.3               RANN_2.6.1               \n[125] promises_1.2.0.1          BiocSingular_1.16.0      \n[127] beachmat_2.16.0           xtable_1.8-4             \n[129] cluster_2.1.6             evaluate_0.21            \n[131] locfit_1.5-9.8            cli_3.6.1                \n[133] compiler_4.3.2            rlang_1.1.1              \n[135] crayon_1.5.2              future.apply_1.11.0      \n[137] labeling_0.4.2            plyr_1.8.8               \n[139] stringi_1.8.1             viridisLite_0.4.2        \n[141] deldir_2.0-2              BiocParallel_1.34.2      \n[143] assertthat_0.2.1          munsell_0.5.0            \n[145] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[147] PCAtools_2.14.0           Matrix_1.6-3             \n[149] RcppHNSW_0.5.0            patchwork_1.1.2          \n[151] sparseMatrixStats_1.12.2  future_1.33.0            \n[153] Rhdf5lib_1.22.0           shiny_1.8.0              \n[155] ROCR_1.0-11               Rfast_2.1.0              \n[157] igraph_1.6.0              RcppParallel_5.1.7"
  },
  {
    "objectID": "cd14_analysis.html",
    "href": "cd14_analysis.html",
    "title": "CD14 Data-set Anaysis with cleaning",
    "section": "",
    "text": "#library(SingleCellExperiment)\n#library(DuoClustering2018)\n#library(tidyr)\nlibrary(ggplot2)\n#library(ggsankey) # remotes::install_github(\"davidsjoberg/ggsankey\")\nlibrary(tibble)\nlibrary(zeallot)\nlibrary(COTAN)\noptions(parallelly.fork.enable = TRUE)\n\noutDir &lt;- \"Data/CD14Cleaned/\"\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"cd14_analysis.log\"))\n\n\nlibrary(Seurat)\ndataset &lt;- Read10X(file.path(outDir, \"/OrigialDatahg19\"))\n\n\nsampleCondition &lt;- \"CD14_Monocytes\"\ncd14Obj &lt;- COTAN(raw = dataset)\ncd14Obj &lt;- initializeMetaDataset(cd14Obj,\n                                 GEO = \"10X CD14+ Monocytes\",\n                                 sequencingMethod = \"10X\",\n                                 sampleCondition = sampleCondition)\n\nsampleCondition\n\n[1] \"CD14_Monocytes\"\n\n\nInspect cells’ sizes\n\ncellSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2)\n\n\n\n\nDrop cells with too many ritz reads as they are probably duplets\n\ncellsSizeThr &lt;- 2500\ncd14Obj &lt;- addElementToMetaDataset(cd14Obj, \"Cells size threshold\", cellsSizeThr)\n\ncells_to_rem &lt;- getCells(cd14Obj)[getCellsSize(cd14Obj) &gt; cellsSizeThr]\ncd14Obj &lt;- dropGenesCells(cd14Obj, cells = cells_to_rem)\n\ncellSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2)\n\n\n\n\nInspect the number of expressed genes per cell\n\ngenesSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2)\n\n\n\n\nDrop cells with too high genes expession as they are probably duplets\n\ngenesSizeThr &lt;- 800\ncd14Obj &lt;- addElementToMetaDataset(cd14Obj, \"Num genes threshold\", genesSizeThr)\n\nnumExprGenes &lt;- getNumExpressedGenes(cd14Obj)\ncells_to_rem &lt;- names(numExprGenes)[numExprGenes &gt; genesSizeThr]\ncd14Obj &lt;- dropGenesCells(cd14Obj, cells = cells_to_rem)\n\ngenesSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2)\n\n\n\n\nCheck number of mitocondrial genes expressed in each cell\n\nmitGenesPattern &lt;- \"^[Mm][Tt]-\"\ngetGenes(cd14Obj)[grep(mitGenesPattern, getGenes(cd14Obj))]\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(cd14Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nCells with a too high percentage of mitocondrial genes are likely dead (or at the last problematic) cells. So we drop them!\n\nmitPercThr &lt;- 6.5\ncd14Obj &lt;- addElementToMetaDataset(cd14Obj, \"Mitoc. perc. threshold\", mitPercThr)\n\ncells_to_rem &lt;- rownames(mitSizes)[mitSizes[[\"mit.percentage\"]] &gt; mitPercThr]\n\ncd14Obj &lt;- dropGenesCells(cd14Obj, cells = cells_to_rem)\n\nc(mitPlot, mitSizes) %&lt;-%\n  mitochondrialPercentagePlot(cd14Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(mitPlot)\n\n\n\n\nCheck number of ribosomial genes expressed in each cell\n\nribGenesPattern &lt;- \"^RP[SL]\\\\d+\"\ngetGenes(cd14Obj)[grep(ribGenesPattern, getGenes(cd14Obj))]\n\n  [1] \"RPL22\"          \"RPL11\"          \"RPS6KA1\"        \"RPS8\"          \n  [5] \"RPL5\"           \"RPS27\"          \"RPS10P7\"        \"RPS6KC1\"       \n  [9] \"RPS7\"           \"RPS27A\"         \"RPL31\"          \"RPL37A\"        \n [13] \"RPL32\"          \"RPL15\"          \"RPL14\"          \"RPL29\"         \n [17] \"RPL24\"          \"RPL22L1\"        \"RPL39L\"         \"RPL35A\"        \n [21] \"RPL9\"           \"RPL34-AS1\"      \"RPL34\"          \"RPS3A\"         \n [25] \"RPL37\"          \"RPS23\"          \"RPS14\"          \"RPL26L1\"       \n [29] \"RPS18\"          \"RPS10-NUDT3\"    \"RPS10\"          \"RPL10A\"        \n [33] \"RPL7L1\"         \"RPS12\"          \"RPS6KA2\"        \"RPS6KA2-AS1\"   \n [37] \"RPS6KA3\"        \"RPS4X\"          \"RPS6KA6\"        \"RPL36A\"        \n [41] \"RPL36A-HNRNPH2\" \"RPL39\"          \"RPL10\"          \"RPS20\"         \n [45] \"RPL7\"           \"RPL30\"          \"RPL8\"           \"RPS6\"          \n [49] \"RPL35\"          \"RPL12\"          \"RPL7A\"          \"RPS24\"         \n [53] \"RPL27A\"         \"RPS13\"          \"RPS6KA4\"        \"RPS6KB2\"       \n [57] \"RPS3\"           \"RPS25\"          \"RPS26\"          \"RPL41\"         \n [61] \"RPL6\"           \"RPL21\"          \"RPL10L\"         \"RPS29\"         \n [65] \"RPL36AL\"        \"RPS6KL1\"        \"RPS6KA5\"        \"RPS27L\"        \n [69] \"RPL4\"           \"RPS17\"          \"RPS17L\"         \"RPL3L\"         \n [73] \"RPS2\"           \"RPS15A\"         \"RPL13\"          \"RPL26\"         \n [77] \"RPL23A\"         \"RPL23\"          \"RPL19\"          \"RPL27\"         \n [81] \"RPS6KB1\"        \"RPL38\"          \"RPL17-C18orf32\" \"RPL17\"         \n [85] \"RPS21\"          \"RPS15\"          \"RPL36\"          \"RPS28\"         \n [89] \"RPL18A\"         \"RPS16\"          \"RPS19\"          \"RPL18\"         \n [93] \"RPL13A\"         \"RPS11\"          \"RPS9\"           \"RPL28\"         \n [97] \"RPS5\"           \"RPS4Y1\"         \"RPS4Y2\"         \"RPL3\"          \n[101] \"RPS19BP1\"      \n\nc(ribPlot, ribSizes) %&lt;-%\n  mitochondrialPercentagePlot(cd14Obj, genePrefix = mitGenesPattern,\n                              splitPattern = \"-\", numCol = 2)\n\nplot(ribPlot)\n\n\n\n\nCheck no further outliers after all the culling\n\ncellSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2)\n\n\n\ngenesSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2)\n\n\n\n\nClean: round 1\n\ncd14Obj &lt;- clean(cd14Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cd14Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(genesPlot)\n\n\n\ncd14Obj &lt;- addElementToMetaDataset(cd14Obj, \"Num drop B group\", 0)\n\nVisualize if all is ok:\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(zoomedNuPlot)\n\n\n\n\nFinal cleaning to check all is OK\n\ncd14Obj &lt;- clean(cd14Obj)\n\nc(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot, zoomedNuPlot) %&lt;-% cleanPlots(cd14Obj)\n\nplot(pcaCellsPlot)\n\n\n\nplot(pcaCellsData)\n\n\n\nplot(genesPlot)\n\n\n\nplot(UDEPlot)\n\n\n\nplot(nuPlot)\n\n\n\nplot(zoomedNuPlot)\n\n\n\nplot(cellSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2))\n\n\n\nplot(genesSizePlot(cd14Obj, splitPattern = \"-\", numCol = 2))\n\n\n\n\nCalculate genes’ COEX\n\nSys.time()\n\ncd14Obj &lt;- proceedToCoex(cd14Obj, calcCoex = TRUE, cores = 12,\n                         saveObj = TRUE, outDir = outDir)\n\n\ncd14Obj &lt;- readRDS(file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\ngdiData &lt;- calculateGDI(cd14Obj)\n\ngenesToLabel &lt;- head(rownames(gdiData[order(gdiData[[\"GDI\"]],\n                                            decreasing = TRUE), ]), n = 50L)\n\nsort(genesToLabel)\n\n [1] \"ABI3\"      \"ARHGDIB\"   \"ATP5A1\"    \"ATP6V1G1\"  \"CALM2\"     \"CD53\"     \n [7] \"CD7\"       \"CLEC10A\"   \"CPVL\"      \"CTSW\"      \"FCER1A\"    \"FKBP1A\"   \n[13] \"H2AFY\"     \"HLA-DMB\"   \"HLA-DPA1\"  \"HLA-DPB1\"  \"HLA-DQA1\"  \"HLA-DQA2\" \n[19] \"HLA-DQB1\"  \"HLA-DRA\"   \"HMGN1\"     \"HNRNPA0\"   \"HNRNPA1\"   \"HNRNPA2B1\"\n[25] \"IFITM1\"    \"IL2RG\"     \"IL32\"      \"LDHA\"      \"LDHB\"      \"MYL12A\"   \n[31] \"NPM1\"      \"PARK7\"     \"PDIA6\"     \"PGK1\"      \"PTPRCAP\"   \"RAB7A\"    \n[37] \"RBM3\"      \"RHOA\"      \"RHOC\"      \"RPL5\"      \"S100A6\"    \"S100A8\"   \n[43] \"S100A9\"    \"SELL\"      \"SLC25A5\"   \"TMEM230\"   \"TMEM66\"    \"TUBA1B\"   \n[49] \"TYROBP\"    \"YBX1\"     \n\ngdiData[genesToLabel[[50L]], \"GDI\"]\n\n[1] 1.60883\n\ngdiPlot &lt;- GDIPlot(cd14Obj, GDIIn = gdiData, GDIThreshold = 1.4,\n                   genes = list(\"Top 10 GDI genes\" = genesToLabel[1L:10L]))\n\nplot(gdiPlot)\n\n\n\nSys.time()\n\n[1] \"2023-08-21 11:49:17 CEST\"\n\n\nSave the COTAN object\n\nsaveRDS(cd14Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\ncd14Obj &lt;- readRDS(file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nc(splitClusters, splitCoexDF) %&lt;-%\n  cellsUniformClustering(cd14Obj, GDIThreshold = 1.4, cores = 13,\n                         saveObj = TRUE, outDir = outDir)\n\ncd14Obj &lt;- addClusterization(cd14Obj, clName = \"split\",\n                             clusters = splitClusters,\n                             coexDF = splitCoexDF, override = TRUE)\n\n\nsplitClusters &lt;- getClusterizationData(cd14Obj, clName = \"split\")[[1]]\n\ntable(splitClusters)\n\nsplitClusters\n  1   2   3   4   5   6 \n882  26  11 590 889  36 \n\n\n\nsaveRDS(cd14Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nc(mergedClusters, mergedCoexDF) %&lt;-%\n  mergeUniformCellsClusters(cd14Obj, clusters = splitClusters,\n                            GDIThreshold = 1.4, cores = 13,\n                            saveObj = TRUE, outDir = outDir)\n\ncd14Obj &lt;- addClusterization(cd14Obj, clName = \"merge\",\n                             clusters = mergedClusters,\n                             coexDF = mergedCoexDF,\n                             override = TRUE)\n\n\nmergedClusters &lt;- getClusterizationData(cd14Obj, clName = \"merge\")[[1]]\n\ntable(mergedClusters)\n\nmergedClusters\n   1    2    3 \n1515  882   37 \n\n\n\nsaveRDS(cd14Obj, file = file.path(outDir, paste0(sampleCondition, \".cotan.RDS\")))\n\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] SeuratObject_4.1.3 Seurat_4.3.0.1     COTAN_2.1.7        zeallot_0.1.0     \n[5] tibble_3.2.1       ggplot2_3.4.2     \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3     rstudioapi_0.15.0      jsonlite_1.8.7        \n  [4] shape_1.4.6            umap_0.2.10.0          magrittr_2.0.3        \n  [7] spatstat.utils_3.0-3   farver_2.1.1           rmarkdown_2.24        \n [10] GlobalOptions_0.1.2    vctrs_0.6.3            ROCR_1.0-11           \n [13] spatstat.explore_3.2-1 askpass_1.1            htmltools_0.5.5       \n [16] sctransform_0.3.5      parallelly_1.36.0      KernSmooth_2.23-22    \n [19] htmlwidgets_1.6.2      ica_1.0-3              plyr_1.8.8            \n [22] plotly_4.10.2          zoo_1.8-12             igraph_1.5.1          \n [25] mime_0.12              lifecycle_1.0.3        iterators_1.0.14      \n [28] pkgconfig_2.0.3        Matrix_1.6-0           R6_2.5.1              \n [31] fastmap_1.1.1          fitdistrplus_1.1-11    future_1.33.0         \n [34] shiny_1.7.5            clue_0.3-64            digest_0.6.33         \n [37] colorspace_2.1-0       patchwork_1.1.2        S4Vectors_0.38.1      \n [40] tensor_1.5             RSpectra_0.16-1        irlba_2.3.5.1         \n [43] labeling_0.4.2         progressr_0.14.0       RcppZiggurat_0.1.6    \n [46] fansi_1.0.4            spatstat.sparse_3.0-2  httr_1.4.6            \n [49] polyclip_1.10-4        abind_1.4-5            compiler_4.3.1        \n [52] withr_2.5.0            doParallel_1.0.17      viridis_0.6.4         \n [55] dendextend_1.17.1      MASS_7.3-60            openssl_2.1.0         \n [58] rjson_0.2.21           tools_4.3.1            lmtest_0.9-40         \n [61] httpuv_1.6.11          future.apply_1.11.0    goftest_1.2-3         \n [64] glue_1.6.2             nlme_3.1-162           promises_1.2.0.1      \n [67] grid_4.3.1             Rtsne_0.16             cluster_2.1.4         \n [70] reshape2_1.4.4         generics_0.1.3         gtable_0.3.3          \n [73] spatstat.data_3.0-1    tidyr_1.3.0            data.table_1.14.8     \n [76] sp_2.0-0               utf8_1.2.3             BiocGenerics_0.46.0   \n [79] spatstat.geom_3.2-4    RcppAnnoy_0.0.21       ggrepel_0.9.3         \n [82] RANN_2.6.1             foreach_1.5.2          pillar_1.9.0          \n [85] stringr_1.5.0          later_1.3.1            circlize_0.4.15       \n [88] splines_4.3.1          dplyr_1.1.2            lattice_0.21-8        \n [91] survival_3.5-5         deldir_1.0-9           tidyselect_1.2.0      \n [94] ComplexHeatmap_2.16.0  miniUI_0.1.1.1         pbapply_1.7-2         \n [97] knitr_1.43             gridExtra_2.3          IRanges_2.34.1        \n[100] scattermore_1.2        stats4_4.3.1           xfun_0.39             \n[103] factoextra_1.0.7       matrixStats_1.0.0      stringi_1.7.12        \n[106] lazyeval_0.2.2         yaml_2.3.7             evaluate_0.21         \n[109] codetools_0.2-19       cli_3.6.1              RcppParallel_5.1.7    \n[112] uwot_0.1.16            xtable_1.8-4           reticulate_1.30       \n[115] munsell_0.5.0          Rcpp_1.0.11            globals_0.16.2        \n[118] spatstat.random_3.1-5  png_0.1-8              parallel_4.3.1        \n[121] Rfast_2.0.8            ellipsis_0.3.2         assertthat_0.2.1      \n[124] parallelDist_0.2.6     listenv_0.9.0          ggthemes_4.2.4        \n[127] viridisLite_0.4.2      scales_1.2.1           ggridges_0.5.4        \n[130] leiden_0.4.3           purrr_1.0.1            crayon_1.5.2          \n[133] GetoptLong_1.0.5       rlang_1.1.1            cowplot_1.1.1"
  },
  {
    "objectID": "geneCoexAnalysis.html",
    "href": "geneCoexAnalysis.html",
    "title": "Gene Correlation Analysis",
    "section": "",
    "text": "library(COTAN)\nlibrary(ComplexHeatmap)\n\nLoading required package: grid\n\n\n========================================\nComplexHeatmap version 2.16.0\nBioconductor page: http://bioconductor.org/packages/ComplexHeatmap/\nGithub page: https://github.com/jokergoo/ComplexHeatmap\nDocumentation: http://jokergoo.github.io/ComplexHeatmap-reference\n\nIf you use it in published research, please cite either one:\n- Gu, Z. Complex Heatmap Visualization. iMeta 2022.\n- Gu, Z. Complex heatmaps reveal patterns and correlations in multidimensional \n    genomic data. Bioinformatics 2016.\n\n\nThe new InteractiveComplexHeatmap package can directly export static \ncomplex heatmaps into an interactive Shiny app with zero effort. Have a try!\n\nThis message can be suppressed by:\n  suppressPackageStartupMessages(library(ComplexHeatmap))\n========================================\n\nlibrary(circlize)\n\n========================================\ncirclize version 0.4.15\nCRAN page: https://cran.r-project.org/package=circlize\nGithub page: https://github.com/jokergoo/circlize\nDocumentation: https://jokergoo.github.io/circlize_book/book/\n\nIf you use it in published research, please cite:\nGu, Z. circlize implements and enhances circular visualization\n  in R. Bioinformatics 2014.\n\nThis message can be suppressed by:\n  suppressPackageStartupMessages(library(circlize))\n========================================\nTo compare the ability of COTAN to asses the real correlation between genes we define some pools of genes:\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n    c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\")\n)"
  },
  {
    "objectID": "geneCoexAnalysis.html#cotan",
    "href": "geneCoexAnalysis.html#cotan",
    "title": "Gene Correlation Analysis",
    "section": "COTAN",
    "text": "COTAN\n\nobj &lt;- readRDS(\"Data/MouseCortex/MouseCortex_E14.5.cotan.RDS\")\n\n\n# pValues &lt;- calculatePValue(obj, geneSubsetCol = \n#             c(genesList$NPGs,genesList$PNGs,genesList$hk),\n#             geneSubsetRow = \n#              c(genesList$NPGs,genesList$PNGs,genesList$hk))\ncoexMat &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(coexMat),\n        #width = ncol(coexMat)*unit(2.5, \"mm\"), \n        height = nrow(coexMat)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"COTAN coex\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nGDIPlot(obj,genes = genesList,GDIThreshold = 1.4)\n\nSetting new log level to 1\n\n\nRemoved 0 low GDI genes (such as the fully-expressed) in GDI plot"
  },
  {
    "objectID": "geneCoexAnalysis.html#seurat-correlation",
    "href": "geneCoexAnalysis.html#seurat-correlation",
    "title": "Gene Correlation Analysis",
    "section": "Seurat correlation",
    "text": "Seurat correlation\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(Seurat)\n\nAttaching SeuratObject\n\n\n\nAttaching package: 'Seurat'\n\n\nThe following object is masked from 'package:COTAN':\n\n    UMAPPlot\n\nlibrary(patchwork)\nlibrary(Rfast)\n\nLoading required package: Rcpp\n\n\nLoading required package: RcppZiggurat\n\n\n\nAttaching package: 'Rfast'\n\n\nThe following object is masked from 'package:dplyr':\n\n    nth\n\n\n\nsrat&lt;- CreateSeuratObject(counts = getRawData(obj), project = \"E14.5\", min.cells = 3, min.features = 200)\n\nWarning: Feature names cannot have underscores ('_'), replacing with dashes\n('-')\n\nsrat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(srat, pattern = \"^mt-\")\nsrat &lt;- NormalizeData(srat)\nsrat &lt;- FindVariableFeatures(srat, selection.method = \"vst\", nfeatures = 2000)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(srat)\nLabelPoints(plot = plot1, points = c(genesList$NPGs,genesList$PNGs,genesList$layers), repel = TRUE)\n\nWhen using repel, set xnudge and ynudge to 0 for optimal results\n\n\nWarning: ggrepel: 17 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\nLabelPoints(plot = plot1, points = c(genesList$hk), repel = TRUE)\n\nWhen using repel, set xnudge and ynudge to 0 for optimal results\n\n\nWarning: ggrepel: 5 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\nall.genes &lt;- rownames(srat)\nsrat &lt;- ScaleData(srat, features = all.genes)\n\nCentering and scaling data matrix\n\nseurat.data = srat[[\"RNA\"]]@data\n\n\nseurat.data.cor = cora(t(as.matrix(seurat.data)[c(genesList$NPGs,genesList$hk,genesList$PNGs),]), large = T)\n\nWarning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size\n1.1 GiB\n\nrownames(seurat.data.cor) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs)\ncolnames(seurat.data.cor) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs)\n\ndiag(seurat.data.cor) &lt;- 0\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsrat &lt;-  SCTransform(srat, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nWarning: useNames = NA is deprecated. Instead, specify either useNames = TRUE\nor useNames = TRUE.\n\nseurat.data = srat[[\"SCT\"]]@data\nseurat.data.cor = cora(t(as.matrix(seurat.data)[c(genesList$NPGs,genesList$hk,genesList$PNGs),]), large = T)\n\nWarning in asMethod(object): sparse-&gt;dense coercion: allocating vector of size\n1.1 GiB\n\nrownames(seurat.data.cor) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs)\ncolnames(seurat.data.cor) &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs)\n\ndiag(seurat.data.cor) &lt;- 0\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Berlin\ntzcode source: system (glibc)\n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] Rfast_2.0.7           RcppZiggurat_0.1.6    Rcpp_1.0.10          \n [4] patchwork_1.1.2       SeuratObject_4.1.3    Seurat_4.3.0         \n [7] dplyr_1.1.2           circlize_0.4.15       ComplexHeatmap_2.16.0\n[10] COTAN_2.1.2          \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3          rstudioapi_0.14            \n  [3] jsonlite_1.8.4              shape_1.4.6                \n  [5] umap_0.2.10.0               magrittr_2.0.3             \n  [7] spatstat.utils_3.0-3        farver_2.1.1               \n  [9] rmarkdown_2.21              zlibbioc_1.46.0            \n [11] GlobalOptions_0.1.2         vctrs_0.6.1                \n [13] ROCR_1.0-11                 DelayedMatrixStats_1.22.0  \n [15] spatstat.explore_3.2-1      RCurl_1.98-1.12            \n [17] askpass_1.1                 S4Arrays_1.0.1             \n [19] htmltools_0.5.5             sctransform_0.3.5          \n [21] parallelly_1.36.0           KernSmooth_2.23-20         \n [23] htmlwidgets_1.6.2           ica_1.0-3                  \n [25] plyr_1.8.8                  plotly_4.10.1              \n [27] zoo_1.8-12                  igraph_1.4.2               \n [29] mime_0.12                   lifecycle_1.0.3            \n [31] iterators_1.0.14            pkgconfig_2.0.3            \n [33] Matrix_1.5-4                R6_2.5.1                   \n [35] fastmap_1.1.1               GenomeInfoDbData_1.2.10    \n [37] MatrixGenerics_1.12.0       fitdistrplus_1.1-8         \n [39] future_1.32.0               shiny_1.7.4                \n [41] clue_0.3-64                 digest_0.6.31              \n [43] colorspace_2.1-0            S4Vectors_0.38.0           \n [45] tensor_1.5                  RSpectra_0.16-1            \n [47] irlba_2.3.5.1               GenomicRanges_1.52.0       \n [49] labeling_0.4.2              progressr_0.13.0           \n [51] fansi_1.0.4                 spatstat.sparse_3.0-1      \n [53] httr_1.4.5                  polyclip_1.10-4            \n [55] abind_1.4-5                 compiler_4.3.0             \n [57] withr_2.5.0                 doParallel_1.0.17          \n [59] viridis_0.6.2               dendextend_1.17.1          \n [61] MASS_7.3-59                 openssl_2.0.6              \n [63] DelayedArray_0.26.1         rjson_0.2.21               \n [65] tools_4.3.0                 lmtest_0.9-40              \n [67] httpuv_1.6.9                future.apply_1.11.0        \n [69] goftest_1.2-3               glmGamPoi_1.12.1           \n [71] glue_1.6.2                  nlme_3.1-162               \n [73] promises_1.2.0.1            Rtsne_0.16                 \n [75] cluster_2.1.4               reshape2_1.4.4             \n [77] generics_0.1.3              gtable_0.3.3               \n [79] spatstat.data_3.0-1         tidyr_1.3.0                \n [81] data.table_1.14.8           XVector_0.40.0             \n [83] sp_1.6-0                    utf8_1.2.3                 \n [85] BiocGenerics_0.46.0         spatstat.geom_3.2-1        \n [87] RcppAnnoy_0.0.20            ggrepel_0.9.3              \n [89] RANN_2.6.1                  foreach_1.5.2              \n [91] pillar_1.9.0                stringr_1.5.0              \n [93] later_1.3.0                 splines_4.3.0              \n [95] lattice_0.21-8              survival_3.5-5             \n [97] deldir_1.0-6                tidyselect_1.2.0           \n [99] miniUI_0.1.1.1              pbapply_1.7-0              \n[101] knitr_1.42                  gridExtra_2.3              \n[103] IRanges_2.34.0              SummarizedExperiment_1.30.1\n[105] scattermore_1.1             stats4_4.3.0               \n[107] xfun_0.39                   Biobase_2.60.0             \n[109] factoextra_1.0.7            matrixStats_1.0.0          \n[111] stringi_1.7.12              lazyeval_0.2.2             \n[113] yaml_2.3.7                  evaluate_0.20              \n[115] codetools_0.2-19            tibble_3.2.1               \n[117] cli_3.6.1                   uwot_0.1.14                \n[119] xtable_1.8-4                reticulate_1.28            \n[121] munsell_0.5.0               GenomeInfoDb_1.36.0        \n[123] globals_0.16.2              spatstat.random_3.1-4      \n[125] zeallot_0.1.0               png_0.1-8                  \n[127] parallel_4.3.0              ellipsis_0.3.2             \n[129] ggplot2_3.4.2               assertthat_0.2.1           \n[131] sparseMatrixStats_1.12.0    bitops_1.0-7               \n[133] listenv_0.9.0               ggthemes_4.2.4             \n[135] viridisLite_0.4.1           scales_1.2.1               \n[137] ggridges_0.5.4              leiden_0.4.3               \n[139] purrr_1.0.1                 crayon_1.5.2               \n[141] GetoptLong_1.0.5            rlang_1.1.0                \n[143] cowplot_1.1.1"
  },
  {
    "objectID": "geneCoexAnalysisE13.5MouseBrain.html",
    "href": "geneCoexAnalysisE13.5MouseBrain.html",
    "title": "Gene Correlation Analysis E13.5 Mouse Brain",
    "section": "",
    "text": "library(COTAN)\nlibrary(Hmisc)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nTo compare the ability of COTAN to asses the real correlation between genes we define some pools of genes:\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n    c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\",\"Ntf3\",\"Rasgrf2\",\"Pvrl3\", \"Cux2\",\"Slc17a6\", \"Sema3c\",\"Thsd7a\", \"Sulf2\", \"Kcnk2\",\"Grik3\", \"Etv1\", \"Tle4\", \"Tmem200a\", \"Glra2\", \"Etv1\",\"Htr1f\", \"Sulf1\",\"Rxfp1\", \"Syt6\") \n  # From https://www.science.org/doi/10.1126/science.aam8999\n)"
  },
  {
    "objectID": "geneCoexAnalysisE13.5MouseBrain.html#cotan",
    "href": "geneCoexAnalysisE13.5MouseBrain.html#cotan",
    "title": "Gene Correlation Analysis E13.5 Mouse Brain",
    "section": "COTAN",
    "text": "COTAN\n\nobj &lt;- readRDS(\"Data/MouseCortexFromLoom/e13.5_ForebrainDorsal.cotan.RDS\")\n\n\nint.genes &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)[c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers) %in% getGenes(obj)]\n\ncoexMat.big &lt;- getGenesCoex(obj)[int.genes,int.genes]\n\ncoexMat &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))\n                        ),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(coexMat),\n        #width = ncol(coexMat)*unit(2.5, \"mm\"), \n        height = nrow(coexMat)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"COTAN coex\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nGDIPlot(obj,genes = genesList,GDIThreshold = 1.4)"
  },
  {
    "objectID": "geneCoexAnalysisE13.5MouseBrain.html#seurat-correlation",
    "href": "geneCoexAnalysisE13.5MouseBrain.html#seurat-correlation",
    "title": "Gene Correlation Analysis E13.5 Mouse Brain",
    "section": "Seurat correlation",
    "text": "Seurat correlation\n\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(Rfast)\nlibrary(parallel)\nlibrary(doParallel)\n\n\nsrat&lt;- CreateSeuratObject(counts = getRawData(obj), project = \"E14.5\", min.cells = 3, min.features = 200)\nsrat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(srat, pattern = \"^mt-\")\nsrat &lt;- NormalizeData(srat)\nsrat &lt;- FindVariableFeatures(srat, selection.method = \"vst\", nfeatures = 2000)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(srat)\nLabelPoints(plot = plot1, points = c(genesList$NPGs,genesList$PNGs,genesList$layers), repel = TRUE)\n\n\n\n\n\nLabelPoints(plot = plot1, points = c(genesList$hk), repel = TRUE)\n\n\n\n\n\nall.genes &lt;- rownames(srat)\nsrat &lt;- ScaleData(srat, features = all.genes)\nseurat.data = GetAssayData(srat,layer = \"data\")\n\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\n\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsrat &lt;-  SCTransform(srat, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\nseurat.data = srat[[\"SCT\"]]@data\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")"
  },
  {
    "objectID": "geneCoexAnalysisE13.5MouseBrain.html#monocle",
    "href": "geneCoexAnalysisE13.5MouseBrain.html#monocle",
    "title": "Gene Correlation Analysis E13.5 Mouse Brain",
    "section": "Monocle",
    "text": "Monocle\n\nlibrary(monocle3)\n\n\ncds &lt;- new_cell_data_set(getRawData(obj),\n                         cell_metadata = getMetadataCells(obj),\n                         gene_metadata = getMetadataGenes(obj)\n                         )\ncds &lt;- preprocess_cds(cds, num_dim = 100)\n\nnormalized_counts &lt;- normalized_counts(cds)\n\n\nint.genes &lt;- rownames(normalized_counts)[rownames(normalized_counts) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(normalized_counts)[int.genes,])\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nmonocle.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(monocle.data.cor.big) &lt;- 0\n\nmonocle.data.cor &lt;- monocle.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(monocle.data.cor),\n        #width = ncol(monocle.corMat)*unit(2.5, \"mm\"), \n        height = nrow(monocle.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"monocle corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\n\nSys.time()\n\n[1] \"2024-03-10 16:01:31 CET\"\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n [1] stats4    parallel  grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n [5] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n [7] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n [9] matrixStats_1.2.0           Biobase_2.60.0             \n[11] BiocGenerics_0.46.0         doParallel_1.0.17          \n[13] iterators_1.0.14            foreach_1.5.2              \n[15] Rfast_2.1.0                 RcppParallel_5.1.7         \n[17] RcppZiggurat_0.1.6          Rcpp_1.0.11                \n[19] patchwork_1.2.0             Seurat_5.0.0               \n[21] SeuratObject_5.0.0          sp_2.1-1                   \n[23] dplyr_1.1.2                 circlize_0.4.15            \n[25] ComplexHeatmap_2.16.0       Hmisc_5.1-0                \n[27] COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] rpart_4.1.23              fastDummies_1.7.3        \n  [9] lifecycle_1.0.3           globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] backports_1.4.1           dendextend_1.17.1        \n [15] magrittr_2.0.3            plotly_4.10.2            \n [17] rmarkdown_2.24            yaml_2.3.7               \n [19] httpuv_1.6.11             glmGamPoi_1.12.2         \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.35.0         minqa_1.2.5              \n [27] cowplot_1.1.1             pbapply_1.7-2            \n [29] RColorBrewer_1.1-3        zlibbioc_1.46.0          \n [31] abind_1.4-5               Rtsne_0.16               \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] nnet_7.3-19               GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] terra_1.7-39              umap_0.2.10.0            \n [43] goftest_1.2-3             RSpectra_0.16-1          \n [45] spatstat.random_3.2-1     dqrng_0.3.0              \n [47] fitdistrplus_1.1-11       parallelly_1.36.0        \n [49] DelayedMatrixStats_1.22.5 leiden_0.4.3             \n [51] codetools_0.2-19          DelayedArray_0.26.7      \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              lme4_1.1-34              \n [57] ScaledMatrix_1.8.1        viridis_0.6.4            \n [59] base64enc_0.1-3           spatstat.explore_3.2-1   \n [61] jsonlite_1.8.7            GetoptLong_1.0.5         \n [63] ellipsis_0.3.2            progressr_0.14.0         \n [65] Formula_1.2-5             ggridges_0.5.4           \n [67] survival_3.5-7            tools_4.3.2              \n [69] ica_1.0-3                 glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] Cairo_1.6-1               scattermore_1.2          \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] utf8_1.2.3                tidyr_1.3.0              \n [91] generics_0.1.3            data.table_1.15.0        \n [93] httr_1.4.6                htmlwidgets_1.6.2        \n [95] S4Arrays_1.2.0            uwot_0.1.16              \n [97] pkgconfig_2.0.3           gtable_0.3.3             \n [99] lmtest_0.9-40             XVector_0.40.0           \n[101] htmltools_0.5.7           dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] checkmate_2.3.0           nlme_3.1-163             \n[113] zoo_1.8-12                GlobalOptions_0.1.2      \n[115] stringr_1.5.0             KernSmooth_2.23-22       \n[117] miniUI_0.1.1.1            foreign_0.8-86           \n[119] pillar_1.9.0              vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] BiocSingular_1.16.0       beachmat_2.16.0          \n[125] xtable_1.8-4              cluster_2.1.6            \n[127] htmlTable_2.4.1           evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              future.apply_1.11.0      \n[135] labeling_0.4.2            plyr_1.8.8               \n[137] stringi_1.8.1             viridisLite_0.4.2        \n[139] deldir_2.0-2              BiocParallel_1.34.2      \n[141] assertthat_0.2.1          munsell_0.5.0            \n[143] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[145] PCAtools_2.14.0           Matrix_1.6-3             \n[147] RcppHNSW_0.6.0            sparseMatrixStats_1.12.2 \n[149] future_1.33.0             ggplot2_3.4.2            \n[151] shiny_1.8.0               ROCR_1.0-11              \n[153] igraph_1.6.0"
  },
  {
    "objectID": "geneCoexAnalysisE15.0MouseBrain.html",
    "href": "geneCoexAnalysisE15.0MouseBrain.html",
    "title": "Gene Correlation Analysis E15.0 Mouse Brain",
    "section": "",
    "text": "library(COTAN)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nTo compare the ability of COTAN to asses the real correlation between genes we define some pools of genes:\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n    c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\",\"Ntf3\",\"Rasgrf2\",\"Pvrl3\", \"Cux2\",\"Slc17a6\", \"Sema3c\",\"Thsd7a\", \"Sulf2\", \"Kcnk2\",\"Grik3\", \"Etv1\", \"Tle4\", \"Tmem200a\", \"Glra2\", \"Etv1\",\"Htr1f\", \"Sulf1\",\"Rxfp1\", \"Syt6\") \n  # From https://www.science.org/doi/10.1126/science.aam8999\n)"
  },
  {
    "objectID": "geneCoexAnalysisE15.0MouseBrain.html#cotan",
    "href": "geneCoexAnalysisE15.0MouseBrain.html#cotan",
    "title": "Gene Correlation Analysis E15.0 Mouse Brain",
    "section": "COTAN",
    "text": "COTAN\n\nobj &lt;- readRDS(\"Data/MouseCortexFromLoom/e15.0_ForebrainDorsal.cotan.RDS\")\n\n\nint.genes &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)[c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers) %in% getGenes(obj)]\n\n\ncoexMat.big &lt;- getGenesCoex(obj)[int.genes,int.genes]\n\n\ncoexMat &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))\n                        ),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(coexMat),\n        #width = ncol(coexMat)*unit(2.5, \"mm\"), \n        height = nrow(coexMat)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"COTAN coex\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nGDIPlot(obj,genes = genesList,GDIThreshold = 1.4)"
  },
  {
    "objectID": "geneCoexAnalysisE15.0MouseBrain.html#seurat-correlation",
    "href": "geneCoexAnalysisE15.0MouseBrain.html#seurat-correlation",
    "title": "Gene Correlation Analysis E15.0 Mouse Brain",
    "section": "Seurat correlation",
    "text": "Seurat correlation\n\nlibrary(dplyr)\nlibrary(Hmisc)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(Rfast)\nlibrary(parallel)\nlibrary(doParallel)\n\n\nsrat&lt;- CreateSeuratObject(counts = getRawData(obj), project = \"E14.5\", min.cells = 3, min.features = 200)\nsrat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(srat, pattern = \"^mt-\")\nsrat &lt;- NormalizeData(srat)\nsrat &lt;- FindVariableFeatures(srat, selection.method = \"vst\", nfeatures = 2000)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(srat)\nLabelPoints(plot = plot1, points = c(genesList$NPGs,genesList$PNGs,genesList$layers), repel = TRUE)\n\n\n\n\n\nLabelPoints(plot = plot1, points = c(genesList$hk), repel = TRUE)\n\n\n\n\n\nall.genes &lt;- rownames(srat)\nsrat &lt;- ScaleData(srat, features = all.genes)\nseurat.data = GetAssayData(srat,layer = \"data\")\n\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsrat &lt;-  SCTransform(srat, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\nseurat.data = srat[[\"SCT\"]]@data\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\ndiag(seurat.data.cor) &lt;- 0\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")"
  },
  {
    "objectID": "geneCoexAnalysisE15.0MouseBrain.html#monocle",
    "href": "geneCoexAnalysisE15.0MouseBrain.html#monocle",
    "title": "Gene Correlation Analysis E15.0 Mouse Brain",
    "section": "Monocle",
    "text": "Monocle\n\nlibrary(monocle3)\n\n\ncds &lt;- new_cell_data_set(getRawData(obj),\n                         cell_metadata = getMetadataCells(obj),\n                         gene_metadata = getMetadataGenes(obj)\n                         )\ncds &lt;- preprocess_cds(cds, num_dim = 100)\n\nnormalized_counts &lt;- normalized_counts(cds)\n\n\nint.genes &lt;- rownames(normalized_counts)[rownames(normalized_counts) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(normalized_counts)[int.genes,])\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nmonocle.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(monocle.data.cor.big) &lt;- 0\n\nmonocle.data.cor &lt;- monocle.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(monocle.data.cor),\n        #width = ncol(monocle.corMat)*unit(2.5, \"mm\"), \n        height = nrow(monocle.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"monocle corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\n\nSys.time()\n\n[1] \"2024-03-10 16:14:02 CET\"\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n [1] stats4    parallel  grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n [5] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n [7] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n [9] matrixStats_1.2.0           Biobase_2.60.0             \n[11] BiocGenerics_0.46.0         doParallel_1.0.17          \n[13] iterators_1.0.14            foreach_1.5.2              \n[15] Rfast_2.1.0                 RcppParallel_5.1.7         \n[17] RcppZiggurat_0.1.6          Rcpp_1.0.11                \n[19] patchwork_1.2.0             Seurat_5.0.0               \n[21] SeuratObject_5.0.0          sp_2.1-1                   \n[23] Hmisc_5.1-0                 dplyr_1.1.2                \n[25] circlize_0.4.15             ComplexHeatmap_2.16.0      \n[27] COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] rpart_4.1.23              fastDummies_1.7.3        \n  [9] lifecycle_1.0.3           globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] backports_1.4.1           dendextend_1.17.1        \n [15] magrittr_2.0.3            plotly_4.10.2            \n [17] rmarkdown_2.24            yaml_2.3.7               \n [19] httpuv_1.6.11             glmGamPoi_1.12.2         \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.35.0         minqa_1.2.5              \n [27] cowplot_1.1.1             pbapply_1.7-2            \n [29] RColorBrewer_1.1-3        zlibbioc_1.46.0          \n [31] abind_1.4-5               Rtsne_0.16               \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] nnet_7.3-19               GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] terra_1.7-39              umap_0.2.10.0            \n [43] goftest_1.2-3             RSpectra_0.16-1          \n [45] spatstat.random_3.2-1     dqrng_0.3.0              \n [47] fitdistrplus_1.1-11       parallelly_1.36.0        \n [49] DelayedMatrixStats_1.22.5 leiden_0.4.3             \n [51] codetools_0.2-19          DelayedArray_0.26.7      \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              lme4_1.1-34              \n [57] ScaledMatrix_1.8.1        viridis_0.6.4            \n [59] base64enc_0.1-3           spatstat.explore_3.2-1   \n [61] jsonlite_1.8.7            GetoptLong_1.0.5         \n [63] Formula_1.2-5             ellipsis_0.3.2           \n [65] progressr_0.14.0          ggridges_0.5.4           \n [67] survival_3.5-7            tools_4.3.2              \n [69] ica_1.0-3                 glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] scattermore_1.2           Cairo_1.6-1              \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] utf8_1.2.3                tidyr_1.3.0              \n [91] generics_0.1.3            data.table_1.15.0        \n [93] httr_1.4.6                htmlwidgets_1.6.2        \n [95] S4Arrays_1.2.0            uwot_0.1.16              \n [97] pkgconfig_2.0.3           gtable_0.3.3             \n [99] lmtest_0.9-40             XVector_0.40.0           \n[101] htmltools_0.5.7           dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] checkmate_2.3.0           nlme_3.1-163             \n[113] zoo_1.8-12                GlobalOptions_0.1.2      \n[115] stringr_1.5.0             KernSmooth_2.23-22       \n[117] miniUI_0.1.1.1            foreign_0.8-86           \n[119] pillar_1.9.0              vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] BiocSingular_1.16.0       beachmat_2.16.0          \n[125] xtable_1.8-4              cluster_2.1.6            \n[127] htmlTable_2.4.1           evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              future.apply_1.11.0      \n[135] labeling_0.4.2            plyr_1.8.8               \n[137] stringi_1.8.1             viridisLite_0.4.2        \n[139] deldir_2.0-2              BiocParallel_1.34.2      \n[141] assertthat_0.2.1          munsell_0.5.0            \n[143] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[145] PCAtools_2.14.0           Matrix_1.6-3             \n[147] RcppHNSW_0.6.0            sparseMatrixStats_1.12.2 \n[149] future_1.33.0             ggplot2_3.4.2            \n[151] shiny_1.8.0               ROCR_1.0-11              \n[153] igraph_1.6.0"
  },
  {
    "objectID": "geneCoexAnalysisE17.5Yuzwa.html",
    "href": "geneCoexAnalysisE17.5Yuzwa.html",
    "title": "Gene Correlation Analysis E17.5",
    "section": "",
    "text": "library(COTAN)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nTo compare the ability of COTAN to asses the real correlation between genes we define some pools of genes:\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n   c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\",\"Ntf3\",\"Rasgrf2\",\"Pvrl3\", \"Cux2\",\"Slc17a6\", \"Sema3c\",\"Thsd7a\", \"Sulf2\", \"Kcnk2\",\"Grik3\", \"Etv1\", \"Tle4\", \"Tmem200a\", \"Glra2\", \"Etv1\",\"Htr1f\", \"Sulf1\",\"Rxfp1\", \"Syt6\") \n  # From https://www.science.org/doi/10.1126/science.aam8999\n)"
  },
  {
    "objectID": "geneCoexAnalysisE17.5Yuzwa.html#cotan",
    "href": "geneCoexAnalysisE17.5Yuzwa.html#cotan",
    "title": "Gene Correlation Analysis E17.5",
    "section": "COTAN",
    "text": "COTAN\n\nobj &lt;- readRDS(\"Data/Yuzwa_MouseCortex/CorticalCells_GSM2861514_E175.cotan.RDS\")\n\n\nint.genes &lt;- c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers)[c(genesList$NPGs,genesList$hk,genesList$PNGs,genesList$layers) %in% getGenes(obj)]\n\ncoexMat.big &lt;- getGenesCoex(obj)[int.genes,int.genes]\n\ncoexMat &lt;- getGenesCoex(obj)[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))\n                        ),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(coexMat),\n        #width = ncol(coexMat)*unit(2.5, \"mm\"), \n        height = nrow(coexMat)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"COTAN coex\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nGDIPlot(obj,genes = genesList,GDIThreshold = 1.4)"
  },
  {
    "objectID": "geneCoexAnalysisE17.5Yuzwa.html#seurat-correlation",
    "href": "geneCoexAnalysisE17.5Yuzwa.html#seurat-correlation",
    "title": "Gene Correlation Analysis E17.5",
    "section": "Seurat correlation",
    "text": "Seurat correlation\n\nlibrary(dplyr)\nlibrary(Hmisc)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(Rfast)\nlibrary(parallel)\nlibrary(doParallel)\n\n\nsrat&lt;- CreateSeuratObject(counts = getRawData(obj), project = \"E14.5\", min.cells = 3, min.features = 200)\nsrat[[\"percent.mt\"]] &lt;- PercentageFeatureSet(srat, pattern = \"^mt-\")\nsrat &lt;- NormalizeData(srat)\nsrat &lt;- FindVariableFeatures(srat, selection.method = \"vst\", nfeatures = 2000)\n\n# plot variable features with and without labels\nplot1 &lt;- VariableFeaturePlot(srat)\nLabelPoints(plot = plot1, points = c(genesList$NPGs,genesList$PNGs,genesList$layers), repel = TRUE)\n\n\n\n\n\nLabelPoints(plot = plot1, points = c(genesList$hk), repel = TRUE)\n\n\n\n\n\nall.genes &lt;- rownames(srat)\nsrat &lt;- ScaleData(srat, features = all.genes)\nseurat.data = GetAssayData(srat,layer = \"data\")\n\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\nsrat &lt;-  SCTransform(srat, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\nseurat.data = srat[[\"SCT\"]]@data\n\nint.genes &lt;- rownames(seurat.data)[rownames(seurat.data) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(seurat.data)[int.genes,])\n\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nseurat.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(seurat.data.cor.big) &lt;- 0\n\nseurat.data.cor &lt;- seurat.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\ndiag(seurat.data.cor) &lt;- 0\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(seurat.data.cor),\n        #width = ncol(seurat.corMat)*unit(2.5, \"mm\"), \n        height = nrow(seurat.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"Seurat corr SCT\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")"
  },
  {
    "objectID": "geneCoexAnalysisE17.5Yuzwa.html#monocle",
    "href": "geneCoexAnalysisE17.5Yuzwa.html#monocle",
    "title": "Gene Correlation Analysis E17.5",
    "section": "Monocle",
    "text": "Monocle\n\nlibrary(monocle3)\n\n\ncds &lt;- new_cell_data_set(getRawData(obj),\n                         cell_metadata = getMetadataCells(obj),\n                         gene_metadata = getMetadataGenes(obj)\n                         )\ncds &lt;- preprocess_cds(cds, num_dim = 100)\n\nnormalized_counts &lt;- normalized_counts(cds)\n\n\nint.genes &lt;- rownames(normalized_counts)[rownames(normalized_counts) %in% c(genesList$NPGs, genesList$hk, genesList$PNGs, genesList$layers)]\nsubset_data &lt;- t(as.matrix(normalized_counts)[int.genes,])\n# Get gene names for the subset\nsubset_gene_names &lt;- colnames(subset_data)\n\nnum_cores &lt;- 12  # Change this to the desired number of cores\ncl &lt;- parallel::makeCluster(num_cores)\nregisterDoParallel(cl)\n\ncor_p_values &lt;- foreach(i = 1:ncol(subset_data), .combine = \"cbind\") %dopar% {\n  p_values &lt;- numeric(ncol(subset_data))\n  for (j in 1:ncol(subset_data)) {\n    if (i == j) {\n      p_values[j] &lt;- 1\n    } else {\n      cor_result &lt;- cor.test(subset_data[, i], subset_data[, j], method = \"pearson\")\n      p_values[j] &lt;- cor_result$p.value\n    }\n  }\n  return(p_values)\n}\n\n# Stop the parallel backend\nstopCluster(cl)\n# Extract correlation coefficients and p-values\nmonocle.data.cor.big &lt;- cor(subset_data, method = \"pearson\")\n\n# Create a named matrix for p-values\nrownames(cor_p_values) &lt;- colnames(cor_p_values) &lt;- subset_gene_names\np_values &lt;- cor_p_values\n\ndiag(monocle.data.cor.big) &lt;- 0\n\nmonocle.data.cor &lt;- monocle.data.cor.big[c(genesList$NPGs,genesList$hk,genesList$PNGs),c(genesList$NPGs,genesList$hk,genesList$PNGs)]\n\n\nf1 = colorRamp2(seq(-0.5,0.5, length = 3), c(\"#DC0000B2\", \"white\",\"#3C5488B2\" ))\n\nsplit.genes &lt;- factor(c(rep(\"NPGs\",length(genesList[[\"NPGs\"]])),\n                         rep(\"HK\",length(genesList[[\"hk\"]])),\n                         rep(\"PNGs\",length(genesList[[\"PNGs\"]]))),\n                         levels = c(\"NPGs\",\"HK\",\"PNGs\"))\n\nlgd = Legend(col_fun = f1, title = \"COTAN coex\")\n\nhtmp &lt;- Heatmap(as.matrix(monocle.data.cor),\n        #width = ncol(monocle.corMat)*unit(2.5, \"mm\"), \n        height = nrow(monocle.data.cor)*unit(3, \"mm\"),\n        cluster_rows = FALSE,\n        cluster_columns = FALSE,\n        col = f1,\n        row_names_side = \"left\",\n        row_names_gp = gpar(fontsize = 11),\n        column_names_gp  = gpar(fontsize = 11),\n        column_split = split.genes,\n        row_split = split.genes,\n        cluster_row_slices = FALSE, \n    cluster_column_slices = FALSE,\n    heatmap_legend_param = list(\n        title = \"monocle corr\", at = c(-0.5, 0, 0.5),direction = \"horizontal\",\n        labels = c(\"-0.5\", \"0\", \"0.5\")\n    )\n   )\ndraw(htmp, heatmap_legend_side=\"right\")\n\n\n\n\n\n\nSys.time()\n\n[1] \"2024-03-10 16:24:21 CET\"\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n [1] stats4    parallel  grid      stats     graphics  grDevices utils    \n [8] datasets  methods   base     \n\nother attached packages:\n [1] monocle3_1.3.4              SingleCellExperiment_1.22.0\n [3] SummarizedExperiment_1.30.2 GenomicRanges_1.52.0       \n [5] GenomeInfoDb_1.36.1         IRanges_2.34.1             \n [7] S4Vectors_0.38.1            MatrixGenerics_1.12.3      \n [9] matrixStats_1.2.0           Biobase_2.60.0             \n[11] BiocGenerics_0.46.0         doParallel_1.0.17          \n[13] iterators_1.0.14            foreach_1.5.2              \n[15] Rfast_2.1.0                 RcppParallel_5.1.7         \n[17] RcppZiggurat_0.1.6          Rcpp_1.0.11                \n[19] patchwork_1.2.0             Seurat_5.0.0               \n[21] SeuratObject_5.0.0          sp_2.1-1                   \n[23] Hmisc_5.1-0                 dplyr_1.1.2                \n[25] circlize_0.4.15             ComplexHeatmap_2.16.0      \n[27] COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] rpart_4.1.23              fastDummies_1.7.3        \n  [9] lifecycle_1.0.3           globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] backports_1.4.1           dendextend_1.17.1        \n [15] magrittr_2.0.3            plotly_4.10.2            \n [17] rmarkdown_2.24            yaml_2.3.7               \n [19] httpuv_1.6.11             glmGamPoi_1.12.2         \n [21] sctransform_0.4.1         spam_2.10-0              \n [23] askpass_1.2.0             spatstat.sparse_3.0-2    \n [25] reticulate_1.35.0         minqa_1.2.5              \n [27] cowplot_1.1.1             pbapply_1.7-2            \n [29] RColorBrewer_1.1-3        zlibbioc_1.46.0          \n [31] abind_1.4-5               Rtsne_0.16               \n [33] purrr_1.0.1               RCurl_1.98-1.12          \n [35] nnet_7.3-19               GenomeInfoDbData_1.2.10  \n [37] ggrepel_0.9.3             irlba_2.3.5.1            \n [39] listenv_0.9.0             spatstat.utils_3.0-3     \n [41] terra_1.7-39              umap_0.2.10.0            \n [43] goftest_1.2-3             RSpectra_0.16-1          \n [45] spatstat.random_3.2-1     dqrng_0.3.0              \n [47] fitdistrplus_1.1-11       parallelly_1.36.0        \n [49] DelayedMatrixStats_1.22.5 leiden_0.4.3             \n [51] codetools_0.2-19          DelayedArray_0.26.7      \n [53] tidyselect_1.2.0          shape_1.4.6              \n [55] farver_2.1.1              lme4_1.1-34              \n [57] ScaledMatrix_1.8.1        viridis_0.6.4            \n [59] base64enc_0.1-3           spatstat.explore_3.2-1   \n [61] jsonlite_1.8.7            GetoptLong_1.0.5         \n [63] Formula_1.2-5             ellipsis_0.3.2           \n [65] progressr_0.14.0          ggridges_0.5.4           \n [67] survival_3.5-7            tools_4.3.2              \n [69] ica_1.0-3                 glue_1.7.0               \n [71] gridExtra_2.3             xfun_0.39                \n [73] ggthemes_5.0.0            withr_3.0.0              \n [75] fastmap_1.1.1             boot_1.3-28              \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] parallelDist_0.2.6        R6_2.5.1                 \n [83] mime_0.12                 colorspace_2.1-0         \n [85] scattermore_1.2           Cairo_1.6-1              \n [87] tensor_1.5                spatstat.data_3.0-1      \n [89] utf8_1.2.3                tidyr_1.3.0              \n [91] generics_0.1.3            data.table_1.15.0        \n [93] httr_1.4.6                htmlwidgets_1.6.2        \n [95] S4Arrays_1.2.0            uwot_0.1.16              \n [97] pkgconfig_2.0.3           gtable_0.3.3             \n [99] lmtest_0.9-40             XVector_0.40.0           \n[101] htmltools_0.5.7           dotCall64_1.1-0          \n[103] clue_0.3-64               scales_1.3.0             \n[105] png_0.1-8                 knitr_1.43               \n[107] rstudioapi_0.15.0         reshape2_1.4.4           \n[109] rjson_0.2.21              nloptr_2.0.3             \n[111] checkmate_2.3.0           nlme_3.1-163             \n[113] zoo_1.8-12                GlobalOptions_0.1.2      \n[115] stringr_1.5.0             KernSmooth_2.23-22       \n[117] miniUI_0.1.1.1            foreign_0.8-86           \n[119] pillar_1.9.0              vctrs_0.6.3              \n[121] RANN_2.6.1                promises_1.2.0.1         \n[123] BiocSingular_1.16.0       beachmat_2.16.0          \n[125] xtable_1.8-4              cluster_2.1.6            \n[127] htmlTable_2.4.1           evaluate_0.21            \n[129] zeallot_0.1.0             cli_3.6.1                \n[131] compiler_4.3.2            rlang_1.1.1              \n[133] crayon_1.5.2              future.apply_1.11.0      \n[135] labeling_0.4.2            plyr_1.8.8               \n[137] stringi_1.8.1             viridisLite_0.4.2        \n[139] deldir_2.0-2              BiocParallel_1.34.2      \n[141] assertthat_0.2.1          munsell_0.5.0            \n[143] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[145] PCAtools_2.14.0           Matrix_1.6-3             \n[147] RcppHNSW_0.6.0            sparseMatrixStats_1.12.2 \n[149] future_1.33.0             ggplot2_3.4.2            \n[151] shiny_1.8.0               ROCR_1.0-11              \n[153] igraph_1.6.0"
  },
  {
    "objectID": "generalCoexAssess.html",
    "href": "generalCoexAssess.html",
    "title": "General Coex Evaluation",
    "section": "",
    "text": "library(tidyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(gghalves)\nlibrary(ggstatsplot)\nlibrary(\"gridExtra\")\nlibrary(cowplot)\nlibrary(Matrix)\nlibrary(ggstance)\nlibrary(scales)\n#library(COTAN)\n\n#Define colors\ncolors.methods &lt;- c(\"#8856A7\",\"#ed5537\",\"#EDF8FB\",\"#B3CDE3\")\ngenesList &lt;- list(\n  \"NPGs\"= \n    c(\"Nes\", \"Vim\", \"Sox2\", \"Sox1\", \"Notch1\", \"Hes1\", \"Hes5\", \"Pax6\"),\n  \"PNGs\"= \n    c(\"Map2\", \"Tubb3\", \"Neurod1\", \"Nefm\", \"Nefl\", \"Dcx\", \"Tbr1\"),\n  \"hk\"= \n    c(\"Calm1\", \"Cox6b1\", \"Ppia\", \"Rpl18\", \"Cox7c\", \"Erh\", \"H3f3a\",\n      \"Taf1\", \"Taf2\", \"Gapdh\", \"Actb\", \"Golph3\", \"Zfr\", \"Sub1\",\n      \"Tars\", \"Amacr\"),\n  \"layers\" = \n    c(\"Reln\",\"Lhx5\",\"Cux1\",\"Satb2\",\"Tle1\",\"Mef2c\",\"Rorb\",\"Sox5\",\"Bcl11b\",\"Fezf2\",\"Foxp2\",\"Ntf3\",\"Rasgrf2\",\"Pvrl3\", \"Cux2\",\"Slc17a6\", \"Sema3c\",\"Thsd7a\", \"Sulf2\", \"Kcnk2\",\"Grik3\", \"Etv1\", \"Tle4\", \"Tmem200a\", \"Glra2\", \"Etv1\",\"Htr1f\", \"Sulf1\",\"Rxfp1\", \"Syt6\") \n  # From https://www.science.org/doi/10.1126/science.aam8999\n)"
  },
  {
    "objectID": "generalCoexAssess.html#coex-and-correlations",
    "href": "generalCoexAssess.html#coex-and-correlations",
    "title": "General Coex Evaluation",
    "section": "COEX and Correlations",
    "text": "COEX and Correlations\nImport COTAN coex and correlations data from file\n\ntable.tot.hk &lt;- NA\ntable.tot.neural &lt;- NA\nfor (file in list.files(\"CoexData/\",pattern = \"Corr|Coex\")) {\n  #print(file)\n  corr &lt;- readRDS(paste0(\"CoexData/\",file))\n  corr &lt;- as.data.frame(as.matrix(corr))\n  if(str_detect(file,pattern = \"CotanCoex\")){\n    code &lt;- \"COTAN coex\"\n  }else if(str_detect(file,pattern = \"CorrSCT\")){\n    code &lt;- \"Seurat SCT corr.\"\n  }else if(str_detect(file,pattern = \"MonocleCorr\")){\n    code &lt;- \"Monocle corr.\"\n    #print(\"ok\")\n  }else if(str_detect(file,pattern = \"Corr\")){\n    code &lt;- \"Seurat corr.\"\n  }\n  \n  table.hk &lt;- as.data.frame(corr[,genesList$hk])\n  table.hk$Gene1 &lt;- rownames(table.hk)\n  \n  table.hk &lt;- pivot_longer(as.data.frame(table.hk),cols = c(1:(ncol(table.hk)-1)),names_to = \"Gene2\")\n  table.hk$Method &lt;- code\n\n  table.tot.hk &lt;- rbind(table.tot.hk,table.hk)\n  table.tot.hk &lt;- table.tot.hk[! table.tot.hk$Gene1 == table.tot.hk$Gene2,]\n \n  #Not hk\n  table.neural &lt;- as.data.frame(corr[rownames(corr) %in% c(genesList$NPGs,genesList$PNGs,genesList$layers),colnames(corr) %in% c(genesList$NPGs,genesList$PNGs,genesList$layers)])\n  table.neural$Gene1 &lt;- rownames(table.neural)\n  \n  table.neural &lt;- pivot_longer(as.data.frame(table.neural),cols = c(1:(ncol(table.neural)-1)),names_to = \"Gene2\")\n  table.neural$Method &lt;- code\n  \n  table.tot.neural &lt;- rbind(table.tot.neural,table.neural)\n  table.tot.neural &lt;- table.tot.neural[! table.tot.neural$Gene1 == table.tot.neural$Gene2,]\n}\n\n\ntable.tot.hk &lt;- table.tot.hk[2:nrow(table.tot.hk),]\ntable.tot.hk$GeneType &lt;- \"Constitutive\" \ntable.tot.neural &lt;- table.tot.neural[2:nrow(table.tot.neural),]\ntable.tot.neural$GeneType &lt;- \"Neural\"\n\n## For ECDL\ntmp.tot &lt;- NA\nfor (method in unique(table.tot.hk$Method)) {\n  tmp &lt;- as.data.frame(table.tot.hk[table.tot.hk$Method == method,])\n  tmp$n &lt;- NA\n  tmp[order(abs(tmp$value)),]$n &lt;- c(1:dim(tmp)[1])/(dim(tmp)[1]+1)\n  tmp$Y_axis &lt;- 1-tmp$n\n  tmp.tot &lt;- rbind(tmp.tot,tmp)\n}\ntmp.tot &lt;- tmp.tot[2:nrow(tmp.tot),]\ntable.tot.hk &lt;- tmp.tot\n\ntmp.tot &lt;- NA\nfor (method in unique(table.tot.neural$Method)) {\n  tmp &lt;- as.data.frame(table.tot.neural[table.tot.neural$Method == method,])\n  tmp$n &lt;- NA\n  tmp[order(abs(tmp$value)),]$n &lt;- c(1:dim(tmp)[1])/(dim(tmp)[1]+1)\n  tmp$Y_axis &lt;- 1-tmp$n\n  tmp.tot &lt;- rbind(tmp.tot,tmp)\n}\ntmp.tot &lt;- tmp.tot[2:nrow(tmp.tot),]\ntable.tot.neural &lt;- tmp.tot\n\n############\n\ntable.tot &lt;- rbind(table.tot.hk,table.tot.neural) \ntable.tot &lt;- table.tot[!table.tot$Gene1 == table.tot$Gene2,]\n\nidentical(table.tot[table.tot$Method == \"COTAN coex\",]$Gene1,\n          table.tot[table.tot$Method == \"Seurat corr.\",]$Gene1 )\n\n[1] FALSE\n\nidentical(table.tot[table.tot$Method == \"COTAN coex\",]$Gene2,\n          table.tot[table.tot$Method == \"Seurat corr.\",]$Gene2 )\n\n[1] FALSE\n\nhead(table.tot)\n\n  Gene1  Gene2      value     Method     GeneType         n     Y_axis\n2   Nes  Calm1 0.07759659 COTAN coex Constitutive 0.9265526 0.07344741\n3   Nes Cox6b1 0.01041200 COTAN coex Constitutive 0.2897520 0.71024803\n4   Nes   Ppia 0.02778287 COTAN coex Constitutive 0.6125745 0.38742550\n5   Nes  Rpl18 0.11794907 COTAN coex Constitutive 0.9865410 0.01345895\n6   Nes  Cox7c 0.01694457 COTAN coex Constitutive 0.4351086 0.56489137\n7   Nes    Erh 0.06612110 COTAN coex Constitutive 0.8919439 0.10805614\n\n\n\ntable.tot$ValAbs &lt;- abs(table.tot$value)\ntable.tot$LogValAbs &lt;- log(table.tot$ValAbs+0.001)\ntable.tot$SqrValAbs &lt;- table.tot$ValAbs**2\n\nggplot(table.tot,aes(x=Method,y=LogValAbs, fill=Method)) +\ngeom_half_violin(alpha=0.8) +\n  #geom_point(position = \"jitter\", size= 0.1,alpha = 0.3)+ \n  geom_half_boxplot(width=0.1, alpha=0.8,side = \"r\") +\n  theme_bw()+   theme(legend.position=\"none\")+#ylim(0,1)+\n  facet_grid(GeneType ~ . , space = \"free_y\", scales = \"free\")+\n  scale_fill_manual(values = colors.methods)\n\n\n\n\n\nggplot(table.tot[table.tot$GeneType == \"Neural\",], aes(x = ValAbs, y = -0.5)) +\n\n  # horizontal box plot\n  geom_boxploth(aes(fill = Method)) +\n\n  # normal density plot\n  geom_density(aes(x = ValAbs), inherit.aes = FALSE) +\n\n  # # vertical lines at Q1 / Q2 / Q3\n  # stat_boxploth(geom = \"vline\", aes(xintercept = ..xlower..)) +\n   stat_boxploth(geom = \"vline\", aes(xintercept = ..xmiddle..)) +\n  # stat_boxploth(geom = \"vline\", aes(xintercept = ..xupper..)) +\n  # \n   facet_grid(Method ~ .) +\n  \n  # reproduce original chart's color scale (o/w ordered factors will result\n  # in viridis scale by default, using the current version of ggplot2)\n  scale_fill_discrete()+scale_fill_manual(values = colors.methods)+\n  theme_bw()+   theme(legend.position=\"none\")\n\n\n\n\nIn this case we don’t see differences between coex and correlations.\n\nggplot(table.tot[table.tot$GeneType == \"Constitutive\",], aes(x = ValAbs, y = -0.5)) +\n\n  # horizontal box plot\n  geom_boxploth(aes(fill = Method), outlier.size = 0.5,width=3) +\n\n  # normal density plot\n  geom_density(aes(x = ValAbs), inherit.aes = FALSE) +\n\n  # # vertical lines at Q1 / Q2 / Q3\n  # stat_boxploth(geom = \"vline\", aes(xintercept = ..xlower..)) +\n   stat_boxploth(geom = \"vline\", aes(xintercept = ..xmiddle..)) +\n  # stat_boxploth(geom = \"vline\", aes(xintercept = ..xupper..)) +\n  # \n   facet_grid(Method ~ .) +\n  \n  # reproduce original chart's color scale (o/w ordered factors will result\n  # in viridis scale by default, using the current version of ggplot2)\n  scale_fill_discrete()+scale_fill_manual(values = colors.methods)+\n  theme_bw()+   theme(legend.position=\"none\")\n\n\n\n\nWe can clearly observe that the coex is generally more near to zero than the correlations.\n\nggplot(table.tot,aes(x=ValAbs, color=Method, y = Y_axis)) + \n  geom_point(alpha=0.8) +\n  scale_color_manual(values = colors.methods)+\n  scale_y_continuous(trans= \"log\",breaks = c(0,0.1,0.25,0.5)\n                         )+\n  scale_x_continuous(trans= \"log\",\n                     breaks = c(0.1,0.2,0.3, 0.4,0.5,0.8), limits = c(0.01,0.85))+\n  theme_bw()+   theme(legend.position=\"bottom\")+ \n  facet_grid(GeneType ~ . )\n\n\n\n\n\nggplot(table.tot.hk,aes(x=abs(value), color=Method))+stat_ecdf(geom = \"point\", size = 0.5 )+scale_color_manual(values = colors.methods)+\n  scale_y_continuous(trans= \"exp\")\n\n\n\n\n\nggplot(table.tot,aes(x=Method,y=ValAbs, fill=Method)) +\n#geom_half_boxplot(alpha=0.8) +\n  #geom_point(position = \"jitter\", size= 0.1,alpha = 0.3)+ \n  geom_boxplot(alpha=0.8,outlier.size = 0.1,outlier.colour='blue', alpha=0.1) +\n  theme_bw()+   theme(legend.position=\"none\")+ylim(0,0.2)+\n  facet_grid(GeneType ~ . , space = \"free_y\", scales = \"free\")+\n  scale_fill_manual(values = colors.methods)\n\n\n\n\n\nggplot(table.tot,aes(x=Method,y=ValAbs, fill=GeneType)) +\n  geom_boxplot(alpha=0.8) +\n  #geom_hline(yintercept = -3.39)+\n  #geom_hline(yintercept = -1.86)+\n  #geom_point(position = \"jitter\", size= 0.1,alpha = 0.3)+ \n  #geom_half_boxplot(width=0.1, alpha=0.8,side = \"r\") +\n  theme_bw()+   #theme(legend.position=\"none\")+\n  scale_fill_manual(values = colors.methods)"
  },
  {
    "objectID": "generalCoexAssess.html#p-values",
    "href": "generalCoexAssess.html#p-values",
    "title": "General Coex Evaluation",
    "section": "p-values",
    "text": "p-values\n\ntable.tot.hk &lt;- NA\ntable.tot.neural &lt;- NA\nfor (file in list.files(\"CoexData/\",pattern = \"PValue\")) {\n  pval &lt;- readRDS(paste0(\"CoexData/\",file))\n  #pval &lt;- as.data.frame(as.matrix(pval))\n  if(str_detect(file,pattern = \"Cotan\")){\n    code &lt;- \"COTAN p-values\"\n    if(all(diag(pval)) == 1){\n      \n      diag(pval) = 0\n    }\n  }else if(str_detect(file,pattern = \"PValuesSCT\")){\n    code &lt;- \"Seurat SCT p-values\"\n  }else if(str_detect(file,pattern = \"SeuratPValues\")){\n    code &lt;- \"Seurat p-values\"\n  }else if(str_detect(file,pattern = \"MonoclePValues\")){\n    code &lt;- \"Monocle p-values\"\n  }\n  \n  \n  table.hk &lt;- as.data.frame(pval[,genesList$hk])\n  table.hk$Gene1 &lt;- rownames(table.hk)\n  \n  table.hk &lt;- pivot_longer(as.data.frame(table.hk),cols = c(1:(ncol(table.hk)-1)),names_to = \"Gene2\")\n  table.hk$Method &lt;- code\n\n  table.tot.hk &lt;- rbind(table.tot.hk,table.hk)\n  table.tot.hk &lt;- table.tot.hk[! table.tot.hk$Gene1 == table.tot.hk$Gene2,]\n \n  #Not hk\n  table.neural &lt;- as.data.frame(pval[rownames(pval) %in% c(genesList$NPGs,genesList$PNGs,genesList$layers),colnames(pval) %in% c(genesList$NPGs,genesList$PNGs,genesList$layers)])\n  table.neural$Gene1 &lt;- rownames(table.neural)\n  \n  table.neural &lt;- pivot_longer(as.data.frame(table.neural),cols = c(1:(ncol(table.neural)-1)),names_to = \"Gene2\")\n  table.neural$Method &lt;- code\n  \n  table.tot.neural &lt;- rbind(table.tot.neural,table.neural)\n  table.tot.neural &lt;- table.tot.neural[! table.tot.neural$Gene1 == table.tot.neural$Gene2,]\n}\n\ntable.tot.hk &lt;- table.tot.hk[2:nrow(table.tot.hk),]\ntable.tot.hk$GeneType &lt;- \"Constitutive\" \ntable.tot.neural &lt;- table.tot.neural[2:nrow(table.tot.neural),]\ntable.tot.neural$GeneType &lt;- \"Neural\"\n\n## For ECDL\ntmp.tot &lt;- NA\nfor (method in unique(table.tot.hk$Method)) {\n  tmp &lt;- as.data.frame(table.tot.hk[table.tot.hk$Method == method,])\n  tmp$n &lt;- NA\n  tmp[order(abs(tmp$value)),]$n &lt;- c(1:dim(tmp)[1])/(dim(tmp)[1]+1)\n  tmp$Y_axis &lt;- 1-tmp$n\n  tmp.tot &lt;- rbind(tmp.tot,tmp)\n}\ntmp.tot &lt;- tmp.tot[2:nrow(tmp.tot),]\ntable.tot.hk &lt;- tmp.tot\n\ntmp.tot &lt;- NA\nfor (method in unique(table.tot.neural$Method)) {\n  tmp &lt;- as.data.frame(table.tot.neural[table.tot.neural$Method == method,])\n  tmp$n &lt;- NA\n  tmp[order(abs(tmp$value)),]$n &lt;- c(1:dim(tmp)[1])/(dim(tmp)[1]+1)\n  tmp$Y_axis &lt;- 1-tmp$n\n  tmp.tot &lt;- rbind(tmp.tot,tmp)\n}\ntmp.tot &lt;- tmp.tot[2:nrow(tmp.tot),]\ntable.tot.neural &lt;- tmp.tot\n\n############\n\ntable.tot &lt;- rbind(table.tot.hk,table.tot.neural) \ntable.tot &lt;- table.tot[!table.tot$Gene1 == table.tot$Gene2,]\n\nidentical(table.tot[table.tot$Method == \"COTAN p-val\",]$Gene1,\n          table.tot[table.tot$Method == \"Seurat p-val.\",]$Gene1 )\n\n[1] TRUE\n\nidentical(table.tot[table.tot$Method == \"COTAN p-val\",]$Gene1,\n          table.tot[table.tot$Method == \"Monocle p-val.\",]$Gene1 )\n\n[1] TRUE\n\nhead(table.tot)\n\n  Gene1  Gene2     value         Method     GeneType         n    Y_axis\n2  Actb  Calm1 0.1154619 COTAN p-values Constitutive 0.3496081 0.6503919\n3  Actb Cox6b1 0.3563300 COTAN p-values Constitutive 0.5415454 0.4584546\n4  Actb   Ppia 0.2790691 COTAN p-values Constitutive 0.4871221 0.5128779\n5  Actb  Rpl18 0.4733509 COTAN p-values Constitutive 0.6257559 0.3742441\n6  Actb  Cox7c 0.8035390 COTAN p-values Constitutive 0.8680851 0.1319149\n7  Actb    Erh 0.6855733 COTAN p-values Constitutive 0.7746920 0.2253080\n\n\n\nConstitutive genes\n\nggplot(table.tot[table.tot$GeneType == \"Constitutive\",], aes(y = value)) +\n  geom_boxplot(aes(fill = Method), outlier.size = 0.5,width=3) +\n  scale_fill_discrete()+scale_fill_manual(values = colors.methods)+\n  theme_bw()#+   theme(legend.position=\"none\")\n\n\n\n\n\nggplot(table.tot.hk,aes(x=value,y=n, color=Method))+geom_point(size = 0.5 )+\n  scale_color_manual(values = colors.methods)+\n  theme_bw()\n\n\n\n\n\nggplot(table.tot.hk,aes(x=value,y=n, color=Method))+geom_point(size = 0.5 )+ scale_x_continuous(trans = log_trans(base = 10),\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x)),limits = c(10^(-100),0.05)) + ylim(0,0.4) +scale_color_manual(values = colors.methods)+\n  theme_bw()\n\n\n\n\nWe can observe from this plot that COTAN has lower false positive error in fact the number of constitutive genes with p-values lower than 0.05 is quite smaller than from Seurat (both normalization).\n\nggplot(table.tot[table.tot$GeneType == \"Constitutive\",],aes(x=value, color=Method))+geom_density()+xlim(0,0.05)+\n  scale_color_manual(values = colors.methods)+\n  theme_bw() \n\n\n\n\n\n\nNeural genes\n\nggplot(table.tot[table.tot$GeneType == \"Neural\",], aes(y = (value))) +\n  geom_boxplot(aes(fill = Method), outlier.size = 0.5,width=3) +\n  scale_fill_discrete()+scale_fill_manual(values = colors.methods)+\n  theme_bw() #+ theme(legend.position=\"none\")\n\n\n\n\n\nggplot(table.tot.neural,aes(x=value,y=n, color=Method))+geom_point(size = 0.5 )+scale_color_manual(values = colors.methods)+\n  theme_bw()\n\n\n\n\n\nggplot(table.tot.neural,aes(x=value,y=n, color=Method))+geom_point(size = 0.5 )+ \n  scale_x_continuous(trans = log_trans(base = 10),\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x)),\n    limits = c(0.0001,0.05)) +\n  scale_color_manual(values = colors.methods)+\n  theme_bw()\n\n\n\n\n\nggplot(table.tot.neural,aes(x=value,y=n, color=Method))+geom_point(size = 0.5 )+ \n  scale_x_continuous(trans = log_trans(base = 10),\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x)),\n    limits = c(10^(-300),0.05)) + ylim(0,0.5)+\n  scale_color_manual(values = colors.methods)+\n  theme_bw()\n\n\n\n\n\n\nDirect comparision\n\nggplot(table.tot,aes(x=value, color=Method))+geom_density()+\n  facet_grid(GeneType ~ .,scales=\"free\")+\n  scale_color_manual(values = colors.methods)+\n  theme_bw()\n\n\n\n\n\nggplot(table.tot,aes(x=value,y=n, color=Method))+geom_point(size = 0.5 )+ \n  scale_x_continuous(trans = log_trans(base = 10),\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x)),\n    limits = c(0.0001,0.05)) + \n  facet_grid(. ~ GeneType ,scales=\"free\") +\n  scale_color_manual(values = colors.methods)+\n  theme_bw()+ theme(legend.position=\"bottom\")\n\n\n\n\n\n\nSys.time()\n\n[1] \"2024-03-10 16:44:13 CET\"\n\n\n\nsessionInfo()\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] scales_1.3.0       ggstance_0.3.6     Matrix_1.6-3       cowplot_1.1.1     \n [5] gridExtra_2.3      ggstatsplot_0.12.0 gghalves_0.1.4     ggplot2_3.4.2     \n [9] stringr_1.5.0      tidyr_1.3.0       \n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.3             generics_0.1.3         stringi_1.8.1         \n [4] lattice_0.22-5         digest_0.6.33          magrittr_2.0.3        \n [7] correlation_0.8.4      evaluate_0.21          grid_4.3.2            \n[10] estimability_1.4.1     mvtnorm_1.2-2          fastmap_1.1.1         \n[13] jsonlite_1.8.7         rematch2_2.1.2         purrr_1.0.1           \n[16] fansi_1.0.4            cli_3.6.1              rlang_1.1.1           \n[19] munsell_0.5.0          withr_3.0.0            yaml_2.3.7            \n[22] statsExpressions_1.5.1 tools_4.3.2            datawizard_0.9.0      \n[25] coda_0.19-4            dplyr_1.1.2            colorspace_2.1-0      \n[28] zeallot_0.1.0          bayestestR_0.13.1      paletteer_1.6.0       \n[31] vctrs_0.6.3            R6_2.5.1               lifecycle_1.0.3       \n[34] emmeans_1.10.0         htmlwidgets_1.6.2      insight_0.19.6        \n[37] pkgconfig_2.0.3        pillar_1.9.0           gtable_0.3.3          \n[40] glue_1.7.0             xfun_0.39              tibble_3.2.1          \n[43] tidyselect_1.2.0       rstudioapi_0.15.0      parameters_0.21.1     \n[46] knitr_1.43             farver_2.1.1           xtable_1.8-4          \n[49] patchwork_1.2.0        htmltools_0.5.7        labeling_0.4.2        \n[52] rmarkdown_2.24         compiler_4.3.2"
  }
]