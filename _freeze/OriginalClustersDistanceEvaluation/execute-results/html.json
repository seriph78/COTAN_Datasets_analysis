{
  "hash": "ce2d130078098ebb8ac00088381470af",
  "result": {
    "markdown": "---\ntitle: \"Original Clusters Distance Evaluation\"\nauthor: \"seriph78\"\ndate: \"2024-06-03\"\noutput: html_document\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(COTAN)\nlibrary(stringr)\nlibrary(tidyverse)\n```\n:::\n\n\n## Extract the row matrix for each cluster\n\nThis is done on the La Manno Mouse Brain dataset (2021)\n\n### E13.5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE13.5Clusters.code <- c(432,187,434,184,437,510)\n\nfb135Obj <- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e13.5_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition <- getMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nfor (cl in E13.5Clusters.code) {\n  cells <- names(getClusters(fb135Obj, \n      clName = \"original.clusters\")[getClusters(fb135Obj, \n                          clName = \"original.clusters\") == cl])\n\nCLRawData <- getRawData(fb135Obj)[,cells]\n\nsaveRDS(CLRawData,file = paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/Cl\",cl,sampleCondition,\"RawData.RDS\"))  \n}\n```\n:::\n\n\n### E15.0\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE15.0Clusters.code <- c(432,509,510,508,428,434,437)\n\nfb150Obj <- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"e15.0_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition <- getMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\nfor (cl in E15.0Clusters.code) {\n  cells <- names(getClusters(fb150Obj, \n      clName = \"original.clusters\")[getClusters(fb150Obj, \n                          clName = \"original.clusters\") == cl])\n\nCLRawData <- getRawData(fb150Obj)[,cells]\n\nsaveRDS(CLRawData,file = paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/Cl\",cl,sampleCondition,\"RawData.RDS\"))  \n}\n```\n:::\n\n\n### E17.5\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE17.5Clusters.code <- c(516,505)\n\nfb175Obj <- readRDS(file = file.path(\"Data/MouseCortexFromLoom/\", \"E17.5_ForebrainDorsal.cotan.RDS\"))\n\nsampleCondition <- getMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])\n\nfor (cl in E17.5Clusters.code) {\n  cells <- names(getClusters(fb175Obj, \n      clName = \"original.clusters\")[getClusters(fb175Obj, \n                          clName = \"original.clusters\") == cl])\n\nCLRawData <- getRawData(fb175Obj)[,cells]\n\nsaveRDS(CLRawData,file = paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/Cl\",cl,sampleCondition,\"RawData.RDS\"))  \n}\n```\n:::\n\n\n## Defining the two distances\n\nTo roughly determine the cluster distances we decided to test two simple Euclidean distances:\n\n1.  over the mean of the 0/1 raw matrix\n\n2.  over the $1-e^{-\\lambda}$ where $\\lambda$ is the average expression for the genes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nClFiles <- list.files(\"Data/MouseCortexFromLoom/SingleClusterRawData/\")\n\ntot.Df.ZeroOne <- NA\ntot.Df.Lambda <- NA\nfor(Fl in ClFiles) {\n  print(Fl)\n  cl <- str_split(Fl,pattern = \"_\",simplify = T)[1]\n  data <- readRDS(paste0(\"Data/MouseCortexFromLoom/SingleClusterRawData/\",\n                         Fl))\n  \n  obj <- COTAN(data)\n  \n  ZeroOne <- rowMeans(as.matrix(getZeroOneProj(obj)))\n  tot.Df.ZeroOne <- merge(tot.Df.ZeroOne,ZeroOne,by = 0,all = T)\n  tot.Df.ZeroOne[is.na(tot.Df.ZeroOne)] <- 0\n  colnames(tot.Df.ZeroOne)[ncol(tot.Df.ZeroOne)] <- cl\n  tot.Df.ZeroOne <- column_to_rownames(tot.Df.ZeroOne,var = \"Row.names\")\n  \n  obj <- estimateLambdaLinear(obj)\n  Lambda <- getLambda(obj)\n  tot.Df.Lambda <- merge(tot.Df.Lambda,1-exp(-Lambda),by = 0, all = T)\n  tot.Df.Lambda[is.na(tot.Df.Lambda)] <- 0\n  colnames(tot.Df.Lambda)[ncol(tot.Df.Lambda)] <- cl\n  tot.Df.Lambda <- column_to_rownames(tot.Df.Lambda,var = \"Row.names\")\n  \n}\ntot.Df.Lambda <- tot.Df.Lambda[,2:ncol(tot.Df.Lambda)]\ntot.Df.ZeroOne <- tot.Df.ZeroOne[,2:ncol(tot.Df.ZeroOne)]\n\ntot.Df.Lambda <- tot.Df.Lambda[2:nrow(tot.Df.Lambda),]\ntot.Df.ZeroOne <- tot.Df.ZeroOne[2:nrow(tot.Df.Lambda),]\n\n\nhead(tot.Df.Lambda)\nhead(tot.Df.ZeroOne)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(tot.Df.Lambda, \"Data/MouseCortexFromLoom/ClustersDistances/Tot.Df.Lambda.RDS\")\nsaveRDS(tot.Df.ZeroOne, \"Data/MouseCortexFromLoom/ClustersDistances/Tot.Df.ZeroOne.RDS\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ComplexHeatmap)\ndistance.df.Lambda <- as.matrix(dist(t(tot.Df.Lambda),diag = T,upper = T))\n\nHeatmapLambda <-  Heatmap(distance.df.Lambda,\n        name = \"Lambda\\ndistance\", \n        cell_fun = function(j, i, x, y, width, height, fill) \n        {\n          grid.text(sprintf(\"%.1f\", distance.df.Lambda[i, j]), x, y, gp = gpar(fontsize = 10))\n        },\n        show_row_dend = F, \n        show_row_names = F)\n\npdf(\"Results/ClustersDistances/HeatmapLambda.pdf\",width = 6,height = 5)\nplot(HeatmapLambda)\ndev.off()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npng \n  2 \n```\n:::\n\n```{.r .cell-code}\nplot(HeatmapLambda)\n```\n\n::: {.cell-output-display}\n![](OriginalClustersDistanceEvaluation_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance.df.ZeroOne <- as.matrix(dist(t(tot.Df.ZeroOne),diag = T,upper = T))\n\nHeatmapZeorOne <- Heatmap(distance.df.ZeroOne,\n        name = \"ZeroOne\\ndistance\", \n        cell_fun = function(j, i, x, y, width, height, fill) \n        {\n          grid.text(sprintf(\"%.1f\", distance.df.ZeroOne[i, j]), x, y, gp = gpar(fontsize = 10))\n        },\n        show_row_dend = F, \n        show_row_names = F)\n\npdf(\"Results/ClustersDistances/HeatmapZeorOne.pdf\",width = 6,height = 5)\nplot(HeatmapZeorOne)\ndev.off()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npng \n  2 \n```\n:::\n\n```{.r .cell-code}\nplot(HeatmapZeorOne)\n```\n\n::: {.cell-output-display}\n![](OriginalClustersDistanceEvaluation_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThe distances are very similar with the Zero One a little lower as values...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance.df.Lambda.Plot <- rownames_to_column(as.data.frame(distance.df.Lambda),\n                                              var = \"Cl.1\")\ndistance.df.Lambda.Plot <-pivot_longer(distance.df.Lambda.Plot,\n                                       cols = !Cl.1,\n                                       names_to = \"Cl.2\", \n                                       values_to = \"Lambda.Dist\")\n\ndistance.df.ZeroOne.Plot <- rownames_to_column(as.data.frame(distance.df.ZeroOne),\n                                              var = \"Cl.1\")\ndistance.df.ZeroOne.Plot <-pivot_longer(distance.df.ZeroOne.Plot,\n                                       cols = !Cl.1,\n                                       names_to = \"Cl.2\", \n                                       values_to = \"ZeroOne.Dist\")\n\ndistance.df.Tot <- merge(distance.df.ZeroOne.Plot,distance.df.Lambda.Plot,by= c(\"Cl.1\",\"Cl.2\"),all=T)\n\nggplot(as.data.frame(distance.df.Tot),aes(x=ZeroOne.Dist, y=Lambda.Dist))+geom_point()\n```\n\n::: {.cell-output-display}\n![](OriginalClustersDistanceEvaluation_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nSo for what we are using it is the same.\n\nThe key information is that we can define couple of, in one case, triplets of very near clusters:\n\n1.  Cl510e13.5 and Cl510e15.0\n2.  Cl516e17.5 and Cl505e17.5\n3.  Cl509e15.0 and Cl508e15.0 which are also similar to Cl432e13.5 and Cl432e15.0\n4.  Cl432e13.5 and Cl432e15.0\n5.  Cl437e13.5 and Cl437e15.0\n6.  Cl428e15.0, Cl434e15.0 and Cl434e13.5\n\nBased on these distances we can consider three thresholds (with number of cluster pair):\n\n1.  less than 7 (first quartile)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum(distance.df.ZeroOne < 7.1 & distance.df.ZeroOne > 0)/2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 19\n    ```\n    :::\n    :::\n\n\n2.  between 9 and 11 (around median)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum(distance.df.ZeroOne > 9 & distance.df.ZeroOne < 11)/2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 20\n    ```\n    :::\n    :::\n\n\n3.  more than 13 (3rd quartile)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum(distance.df.ZeroOne > 13)/2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 32\n    ```\n    :::\n    :::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.4.0 (2024-04-24)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3;  LAPACK version 3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] ComplexHeatmap_2.20.0 lubridate_1.9.3       forcats_1.0.0        \n [4] dplyr_1.1.4           purrr_1.0.2           readr_2.1.5          \n [7] tidyr_1.3.1           tibble_3.2.1          ggplot2_3.5.1        \n[10] tidyverse_2.0.0       stringr_1.5.1         COTAN_2.5.2          \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.22          splines_4.4.0            \n  [3] later_1.3.2               polyclip_1.10-6          \n  [5] fastDummies_1.7.3         lifecycle_1.0.4          \n  [7] doParallel_1.0.17         globals_0.16.3           \n  [9] lattice_0.22-6            MASS_7.3-60.2            \n [11] dendextend_1.17.1         magrittr_2.0.3           \n [13] plotly_4.10.4             rmarkdown_2.27           \n [15] yaml_2.3.8                httpuv_1.6.15            \n [17] Seurat_5.1.0              sctransform_0.4.1        \n [19] spam_2.10-0               askpass_1.2.0            \n [21] sp_2.1-4                  spatstat.sparse_3.0-3    \n [23] reticulate_1.37.0         cowplot_1.1.3            \n [25] pbapply_1.7-2             RColorBrewer_1.1-3       \n [27] abind_1.4-5               zlibbioc_1.50.0          \n [29] Rtsne_0.17                BiocGenerics_0.50.0      \n [31] circlize_0.4.16           IRanges_2.38.0           \n [33] S4Vectors_0.42.0          ggrepel_0.9.5            \n [35] irlba_2.3.5.1             listenv_0.9.1            \n [37] spatstat.utils_3.0-4      umap_0.2.10.0            \n [39] goftest_1.2-3             RSpectra_0.16-1          \n [41] spatstat.random_3.2-3     dqrng_0.4.0              \n [43] fitdistrplus_1.1-11       parallelly_1.37.1        \n [45] DelayedMatrixStats_1.26.0 leiden_0.4.3.1           \n [47] codetools_0.2-20          DelayedArray_0.30.1      \n [49] tidyselect_1.2.1          shape_1.4.6.1            \n [51] farver_2.1.2              ScaledMatrix_1.12.0      \n [53] viridis_0.6.5             matrixStats_1.3.0        \n [55] stats4_4.4.0              spatstat.explore_3.2-7   \n [57] jsonlite_1.8.8            GetoptLong_1.0.5         \n [59] progressr_0.14.0          ggridges_0.5.6           \n [61] survival_3.6-4            iterators_1.0.14         \n [63] foreach_1.5.2             tools_4.4.0              \n [65] ica_1.0-3                 Rcpp_1.0.12              \n [67] glue_1.7.0                gridExtra_2.3            \n [69] SparseArray_1.4.5         xfun_0.44                \n [71] MatrixGenerics_1.16.0     ggthemes_5.1.0           \n [73] withr_3.0.0               fastmap_1.2.0            \n [75] fansi_1.0.6               openssl_2.2.0            \n [77] digest_0.6.35             rsvd_1.0.5               \n [79] timechange_0.3.0          parallelDist_0.2.6       \n [81] R6_2.5.1                  mime_0.12                \n [83] colorspace_2.1-0          Cairo_1.6-2              \n [85] scattermore_1.2           tensor_1.5               \n [87] spatstat.data_3.0-4       utf8_1.2.4               \n [89] generics_0.1.3            data.table_1.15.4        \n [91] httr_1.4.7                htmlwidgets_1.6.4        \n [93] S4Arrays_1.4.1            uwot_0.2.2               \n [95] pkgconfig_2.0.3           gtable_0.3.5             \n [97] lmtest_0.9-40             XVector_0.44.0           \n [99] htmltools_0.5.8.1         dotCall64_1.1-1          \n[101] clue_0.3-65               SeuratObject_5.0.2       \n[103] scales_1.3.0              png_0.1-8                \n[105] knitr_1.46                rstudioapi_0.16.0        \n[107] tzdb_0.4.0                reshape2_1.4.4           \n[109] rjson_0.2.21              nlme_3.1-164             \n[111] zoo_1.8-12                GlobalOptions_0.1.2      \n[113] KernSmooth_2.23-24        parallel_4.4.0           \n[115] miniUI_0.1.1.1            RcppZiggurat_0.1.6       \n[117] pillar_1.9.0              vctrs_0.6.5              \n[119] RANN_2.6.1                promises_1.3.0           \n[121] BiocSingular_1.20.0       beachmat_2.20.0          \n[123] xtable_1.8-4              cluster_2.1.6            \n[125] evaluate_0.23             zeallot_0.1.0            \n[127] cli_3.6.2                 compiler_4.4.0           \n[129] rlang_1.1.3               crayon_1.5.2             \n[131] future.apply_1.11.2       labeling_0.4.3           \n[133] plyr_1.8.9                stringi_1.8.4            \n[135] viridisLite_0.4.2         deldir_2.0-4             \n[137] BiocParallel_1.38.0       assertthat_0.2.1         \n[139] munsell_0.5.1             lazyeval_0.2.2           \n[141] spatstat.geom_3.2-9       PCAtools_2.16.0          \n[143] Matrix_1.7-0              RcppHNSW_0.6.0           \n[145] hms_1.1.3                 patchwork_1.2.0          \n[147] sparseMatrixStats_1.16.0  future_1.33.2            \n[149] shiny_1.8.1.1             ROCR_1.0-11              \n[151] Rfast_2.1.0               igraph_2.0.3             \n[153] RcppParallel_5.1.7       \n```\n:::\n:::\n",
    "supporting": [
      "OriginalClustersDistanceEvaluation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}