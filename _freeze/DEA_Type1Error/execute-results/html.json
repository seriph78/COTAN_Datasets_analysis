{
  "hash": "d441b7d08979accb0900a18342bffcaa",
  "result": {
    "markdown": "---\ntitle: \"Differential expression analysis: type I error\"\nauthor: \"Silvia Giulia Galfr√®\"\ndate: \"2024-02-10\"\noutput: html_document\n---\n\n\n### Automatic functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(COTAN)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(tidyr)\n\n\ndirOut <- \"Results/TypeIError/\"\ndataSetDir <- \"Data/MouseCortexFromLoom/SingleClusterRawData/\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCOTAN.DEA <- function(dataSet,clusters.list, GEO.code, sequencingMethod,sampleCondition, clName,dirOut,percentage){\n  obj <- automaticCOTANObjectCreation(raw = dataSet,\n                                      calcCoex = F,\n                                      cores = 10,\n                                      saveObj = F,\n                                      GEO = GEO.code,\n                                      sequencingMethod = sequencingMethod,\n                                      sampleCondition = sampleCondition)\n  obj <- addClusterization(obj,clName = clName,clusters = clusters.list)\n  \n  DF.DEA <- DEAOnClusters(obj,clName = clName )\n  pval.DEA <- pValueFromDEA(DF.DEA,numCells = getNumCells(obj))\n  adj.pval.DEA <- pval.DEA\n  for (col in colnames(pval.DEA)) {\n    adj.pval.DEA[,col] <- p.adjust(adj.pval.DEA[,col],method = \"bonferroni\")\n  }\n  n.genes.DEA <- sum(adj.pval.DEA < 0.05)\n  res <- list(\"n.genes.DEA\"=n.genes.DEA,\"DF.DEA\"=DF.DEA,\"adj.pval.DEA\" = adj.pval.DEA)\n  \n  write.csv(res$adj.pval.DEA, file = paste0(dirOut,clName,\"_de_genes_COTAN_\",percentage,\".csv\"))\n  \n  return(res)\n\n}\n\nSeurat.DEA <- function(dataSet,clusters.list, project, dirOut,percentage){\n  pbmc <- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n  \n  \n  pbmc <- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n  pbmc <- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n  all.genes <- rownames(pbmc)\n  pbmc <- ScaleData(pbmc, features = all.genes)\n  \n  pbmc <- RunPCA(pbmc)\n  pbmc <- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl <- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl <- factor(clusters.list)\n  \n  pbmc <- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE)\n  \n  \n  \n  n.genes.DEA <- sum(pbmc.markers$p_val_adj < 0.05)\n  \n  print(n.genes.DEA)\n  \n  write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n  }\n\nMonocle.DEA <- function(dataSet,clusters.list,project, dirOut,percentage){\n  \n  cell_metadata = as.data.frame(clusters.list[colnames(dataSet)])\n  colnames(cell_metadata) <- \"Clusters\"\n  cds <- new_cell_data_set(dataSet[rowSums(dataSet) > 3,],\n                         cell_metadata = cell_metadata\n                         )\n  colData(cds)$cluster <- clusters.list[rownames(colData(cds))]\n\n  cds <- preprocess_cds(cds, num_dim = 100)\n  cds <- reduce_dimension(cds)\n  #cds <- cluster_cells(cds, resolution=1e-5)\n\n  de_results <- fit_models(cds,model_formula_str = \" ~ cluster\",cores = 10,verbose = T)\n  fit_coefs <- coefficient_table(de_results)\n  \n  fit_coefs <- fit_coefs %>% filter(term == \"cluster\")\n  \n  write.csv(as.data.frame(fit_coefs[,c(\"num_cells_expressed\" ,\"gene_id\",\"p_value\",\"q_value\")]), file = paste0(dirOut,project,\"_de_genes_Monocle_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=sum(fit_coefs$q_value < 0.05, na.rm = T),\n              \"fit_coefs\"= fit_coefs,\n              \"de_results\"=de_results))\n}\n\n\nScamPy.DEA <- function(dataSet,\n                       clusters.list, \n                       project, \n                       dirOut,\n                       percentage){\n  pbmc <- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  \n  pbmc@meta.data$TestCl <- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl <- clusters.list\n  \n  exprs <- pbmc@assays$RNA$counts\n  \n  meta <- pbmc[[]]\n  #feature_meta <- GetAssay(pbmc)[[]]\n  tmp <- as.data.frame(matrix(data = NA, \n                              ncol = 1, \n                              nrow = nrow(pbmc@assays$RNA$counts)))\n  rownames(tmp) <- rownames(pbmc@assays$RNA$counts)\n  \n  feature_meta <- tmp\n  #embedding <- Embeddings(pbmc, \"umap\")\n  \n  Sys.setenv(RETICULATE_PYTHON = \"../../../bin/python3\")\n  py <- import(\"sys\")\n  \n  source_python(\"src/scanpyTypeIError.py\")\n  scanpyTypeIError(exprs, \n                   meta, \n                   feature_meta, \n                   \"mt\", \n                   dirOut, \n                   project,\n                   percentage)\n\n  out <- read.csv(file = paste0(dirOut,\n                                project,\n                                \"_Scampy_de_genes_\",\n                                percentage,\n                                \".csv\"),\n                  header = T, \n                  row.names = 1)\n  \n  gc()\n\n  return(out)\n}\n```\n:::\n\n\n\nWe would evaluate the Type I error and to do so, we consider some transcriptionally uniform clusters from the Loom dataset. We splitted these cluster in two partitions (with five different dimensions: 1/4, 1/3, 1/3, 2/3, and 3/4) one containing the cells with higher library size and the other with the lower library size. On these two clusters we than tested the four different software.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (perc in c(0.5, 0.33, 0.25,0.67, 0.75)) {\n  outPutMatrix <- as.data.frame(matrix(nrow = 1,ncol = 4))\n  colnames(outPutMatrix) <- c(\"Cotan\",\"Seurat\", \"Monocle\", \"ScamPy\")\n\n  for (dataSet in list.files(dataSetDir)) {\n  \n    cluster.name <- str_split(dataSet,pattern = \"_\", simplify = T)[1]\n    \n    print(cluster.name)\n    outTemp <- NA\n     \n    dataSet <- readRDS(paste0(dataSetDir,dataSet))\n    \n\n    cl1 <- colnames(dataSet)[order(colSums(dataSet),decreasing = T)[1:round(ncol(dataSet)*perc,digits = 0)]]\n    \n    clusters.list <- list(\"cl1\"=cl1,\n                          \"cl2\"=colnames(dataSet)[!colnames(dataSet) %in% cl1])\n  \n    clusters.list <- setNames(rep(1,ncol(dataSet)),\n                              colnames(dataSet))\n    clusters.list[colnames(dataSet)[!colnames(dataSet) %in% cl1]] <- 2 \n  \n    cotan.dea.out <- COTAN.DEA(dataSet = dataSet,\n                               clusters.list = clusters.list,\n                               GEO.code = \"\",\n                               sequencingMethod = \"10x\",\n                               sampleCondition = \"Temp\",\n                               clName =  cluster.name,\n                               dirOut, percentage = perc)\n  \n    outTemp <- c(outTemp,cotan.dea.out$n.genes.DEA)\n    \n    rm(cotan.dea.out)\n    gc()\n  \n    seurat.dea.out <- Seurat.DEA(dataSet = dataSet,\n                               clusters.list = clusters.list,\n                               project = cluster.name,\n                               dirOut, percentage = perc)\n  \n    outTemp <- c(outTemp,seurat.dea.out$n.genes.DEA)\n    \n    rm(seurat.dea.out)\n    gc()\n  \n  \n    monocle.dea.out <- Monocle.DEA(dataSet = dataSet,\n                                   clusters.list = clusters.list,\n                                   project = cluster.name,\n                                   dirOut = dirOut, percentage = perc)\n  \n    outTemp <- c(outTemp,monocle.dea.out$n.genes.DEA)\n    rm(monocle.dea.out)\n    gc()\n  \n    scampy.dea.out <- ScamPy.DEA(dataSet = dataSet, \n                                 clusters.list = clusters.list, \n                                 project = cluster.name, \n                                 dirOut = dirOut, percentage = perc\n                                  )\n    \n  \n    scampy.dea.out.filterd <- scampy.dea.out[scampy.dea.out$pval_adj_cl1 < 0.05,]\n    \n    outTemp <- c(outTemp,dim(scampy.dea.out.filterd)[1])\n    rm(scampy.dea.out.filterd)\n    gc()\n    \n    outTemp <- outTemp[2:length(outTemp)]\n    \n    outPutMatrix <- rbind(outPutMatrix,outTemp)\n    rownames(outPutMatrix)[nrow(outPutMatrix)] <- cluster.name\n    \n    write.csv(outPutMatrix,paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n  }\n  \n  outPutMatrix <-   outPutMatrix[2:nrow(outPutMatrix),]\n  write.csv(outPutMatrix,paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n\n}\n```\n:::\n\n\n### Summarize the output\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_plot <- NA\nfor (perc in c(0.5, 0.33, 0.25,0.67, 0.75)) {\n  outPutMatrix <- read.csv(paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n  \n  outPutMatrix$Division <- perc\n  \n  df_plot <- rbind(df_plot,outPutMatrix)\n  \n}\ndf_plot <- df_plot[2:nrow(df_plot),]\n\n\ndf_plot <- as.data.frame(pivot_longer(df_plot,cols = c(2:5),values_to = \"N.Genes\",names_to = \"Method\"))\n\n\nggplot(df_plot,aes(x = Method, y=N.Genes,fill=Method))+geom_boxplot()+\nscale_fill_viridis(discrete = TRUE, alpha=0.6) + facet_wrap(~Division)+\n    geom_jitter(color=\"black\", size=0.4, alpha=0.9) +theme_light()+\n    theme(\n      legend.position=\"none\",\n      plot.title = element_text(size=11)\n    )\n```\n\n::: {.cell-output-display}\n![](DEA_Type1Error_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] tidyr_1.3.0                 viridis_0.6.4              \n [3] viridisLite_0.4.2           ggplot2_3.4.2              \n [5] dplyr_1.1.2                 stringr_1.5.0              \n [7] reticulate_1.35.0           monocle3_1.3.4             \n [9] SingleCellExperiment_1.22.0 SummarizedExperiment_1.30.2\n[11] GenomicRanges_1.52.0        GenomeInfoDb_1.36.1        \n[13] IRanges_2.34.1              S4Vectors_0.38.1           \n[15] MatrixGenerics_1.12.3       matrixStats_1.2.0          \n[17] Biobase_2.60.0              BiocGenerics_0.46.0        \n[19] Seurat_5.0.0                SeuratObject_5.0.0         \n[21] sp_2.1-1                    COTAN_2.3.3                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               bitops_1.0-7             \n  [5] tibble_3.2.1              polyclip_1.10-4          \n  [7] fastDummies_1.7.3         lifecycle_1.0.3          \n  [9] doParallel_1.0.17         globals_0.16.2           \n [11] lattice_0.22-5            MASS_7.3-60              \n [13] dendextend_1.17.1         magrittr_2.0.3           \n [15] plotly_4.10.2             rmarkdown_2.24           \n [17] yaml_2.3.7                httpuv_1.6.11            \n [19] sctransform_0.4.1         spam_2.10-0              \n [21] askpass_1.2.0             spatstat.sparse_3.0-2    \n [23] minqa_1.2.5               cowplot_1.1.1            \n [25] pbapply_1.7-2             RColorBrewer_1.1-3       \n [27] zlibbioc_1.46.0           abind_1.4-5              \n [29] Rtsne_0.16                purrr_1.0.1              \n [31] RCurl_1.98-1.12           GenomeInfoDbData_1.2.10  \n [33] circlize_0.4.15           ggrepel_0.9.3            \n [35] irlba_2.3.5.1             listenv_0.9.0            \n [37] spatstat.utils_3.0-3      terra_1.7-39             \n [39] umap_0.2.10.0             goftest_1.2-3            \n [41] RSpectra_0.16-1           spatstat.random_3.2-1    \n [43] dqrng_0.3.0               fitdistrplus_1.1-11      \n [45] parallelly_1.36.0         DelayedMatrixStats_1.22.5\n [47] leiden_0.4.3              codetools_0.2-19         \n [49] DelayedArray_0.26.7       tidyselect_1.2.0         \n [51] shape_1.4.6               farver_2.1.1             \n [53] lme4_1.1-34               ScaledMatrix_1.8.1       \n [55] spatstat.explore_3.2-1    jsonlite_1.8.7           \n [57] GetoptLong_1.0.5          ellipsis_0.3.2           \n [59] progressr_0.14.0          ggridges_0.5.4           \n [61] survival_3.5-7            iterators_1.0.14         \n [63] foreach_1.5.2             tools_4.3.2              \n [65] ica_1.0-3                 Rcpp_1.0.11              \n [67] glue_1.7.0                gridExtra_2.3            \n [69] xfun_0.39                 ggthemes_5.0.0           \n [71] withr_3.0.0               fastmap_1.1.1            \n [73] boot_1.3-28               fansi_1.0.4              \n [75] openssl_2.1.0             digest_0.6.33            \n [77] rsvd_1.0.5                parallelDist_0.2.6       \n [79] R6_2.5.1                  mime_0.12                \n [81] colorspace_2.1-0          scattermore_1.2          \n [83] tensor_1.5                spatstat.data_3.0-1      \n [85] utf8_1.2.3                generics_0.1.3           \n [87] data.table_1.15.0         httr_1.4.6               \n [89] htmlwidgets_1.6.2         S4Arrays_1.2.0           \n [91] uwot_0.1.16               pkgconfig_2.0.3          \n [93] gtable_0.3.3              ComplexHeatmap_2.16.0    \n [95] lmtest_0.9-40             XVector_0.40.0           \n [97] htmltools_0.5.7           dotCall64_1.1-0          \n [99] clue_0.3-64               scales_1.3.0             \n[101] png_0.1-8                 knitr_1.43               \n[103] rstudioapi_0.15.0         reshape2_1.4.4           \n[105] rjson_0.2.21              nloptr_2.0.3             \n[107] nlme_3.1-163              zoo_1.8-12               \n[109] GlobalOptions_0.1.2       KernSmooth_2.23-22       \n[111] parallel_4.3.2            miniUI_0.1.1.1           \n[113] RcppZiggurat_0.1.6        pillar_1.9.0             \n[115] grid_4.3.2                vctrs_0.6.3              \n[117] RANN_2.6.1                promises_1.2.0.1         \n[119] BiocSingular_1.16.0       beachmat_2.16.0          \n[121] xtable_1.8-4              cluster_2.1.6            \n[123] evaluate_0.21             zeallot_0.1.0            \n[125] cli_3.6.1                 compiler_4.3.2           \n[127] rlang_1.1.1               crayon_1.5.2             \n[129] future.apply_1.11.0       labeling_0.4.2           \n[131] plyr_1.8.8                stringi_1.8.1            \n[133] deldir_2.0-2              BiocParallel_1.34.2      \n[135] assertthat_0.2.1          munsell_0.5.0            \n[137] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[139] PCAtools_2.14.0           Matrix_1.6-3             \n[141] RcppHNSW_0.6.0            patchwork_1.2.0          \n[143] sparseMatrixStats_1.12.2  future_1.33.0            \n[145] shiny_1.8.0               ROCR_1.0-11              \n[147] Rfast_2.1.0               igraph_1.6.0             \n[149] RcppParallel_5.1.7       \n```\n:::\n:::\n",
    "supporting": [
      "DEA_Type1Error_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}