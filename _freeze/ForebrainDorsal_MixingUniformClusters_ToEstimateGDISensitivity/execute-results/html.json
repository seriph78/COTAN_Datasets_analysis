{
  "hash": "f171e6e77956e9896757f5ded6c783ef",
  "result": {
    "markdown": "---\ntitle: \"Mixing Uniform Clusters To Estimate GDI Sensitivity\"\nauthor: \"Marco Fantozzi\"\ndate: \"2024-01-18\"\noutput: html_document\n---\n\n\n\n\n## Preamble\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\nlibrary(parallelDist)\nlibrary(tibble)\nlibrary(tidyr)\n\noptions(parallelly.fork.enable = TRUE)\n\ninDir <- file.path(\"Data/MouseCortexFromLoom/\")\n\noutDir <- file.path(\"Results/GDI_Sensitivity\")\nif (!file.exists(outDir)) {\n  dir.create(outDir)\n}\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"MixingClustersGDI_ForebrainDorsal.log\"))\n```\n:::\n\n\n## Loading all COTAN Objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfb135Obj <- readRDS(file = file.path(inDir, \"e13.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nfb150Obj <- readRDS(file = file.path(inDir, \"e15.0_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\n\nfb175Obj <- readRDS(file = file.path(inDir, \"e17.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])\n```\n:::\n\n\n## Relevant clusters lists\n\n\n::: {.cell}\n\n:::\n\n\n## Merge clusters from different datasets\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallGenes <- union(union(getGenes(fb135Obj), getGenes(fb150Obj)), getGenes(fb175Obj))\n\n# This function completes the raw data so that the genes list\n# matches the `allGenes` above\nfillGenes <- function(m, prefixName) {\n  # find the missing genes in the given matrix m\n  missingGenes <- !(allGenes %in% rownames(m))\n  # create a matrix with the right sizes for the missing genes\n  # and set their values all to zero\n  fillM <- matrix(0, nrow = sum(missingGenes), ncol = ncol(m))\n  rownames(fillM) <- allGenes[missingGenes]\n  # append the new matrix to the original and reorder the rows\n  # to match overall genes order\n  retM <- rbind(m, fillM)\n  retM <- retM[allGenes, ]\n  # assign unique identifiers to the columns, so that one can discriminate\n  # the source even after merging with other matrices\n  colnames(retM) <- paste0(prefixName, \"_\", colnames(retM))\n  return(retM)\n}\n```\n:::\n\n\n## Create all raw data for each cluster compatible with the full genes' list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallClustersRawData <- list()\nfor (dsName in names(selected)) {\n  clList <- toClustersList(getClusters(objSelector(dsName),\n                                       clName = \"original.clusters\"))\n  for (clName in selected[[dsName]]) {\n    fullName <- paste0(dsName, \":\", clName)\n    fullRawData <- fillGenes(getRawData(objSelector(dsName))[, clList[[clName]]],\n                             fullName)\n    allClustersRawData <- append(allClustersRawData, list(fullRawData))\n    names(allClustersRawData)[length(allClustersRawData)] <- fullName\n  }\n}\n\nassert_that(identical(rownames(allClustersRawData[[1]]), allGenes))\n\n# delete the COTAN objects\nrm(fb135Obj, fb150Obj, fb175Obj)\n```\n:::\n\n\n## Collect `size` and `GDI` for all selected clusters (baseline data)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclDataFB135 <- readRDS(file.path(inDir, \"e13.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\nclDataFB150 <- readRDS(file.path(inDir, \"e15.0_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\nclDataFB175 <- readRDS(file.path(inDir, \"e17.5_ForebrainDorsal_GDI_of_original_clusterization.RDS\"))\n\ndf1 <- clDataFB135[selected[[\"E13.5\"]], c(\"size\", \"X1stPercentile\"), drop = FALSE]\nrownames(df1) <- paste0(\"E13.5:\", rownames(df1))\n\ndf2 <- clDataFB150[selected[[\"E15.0\"]], c(\"size\", \"X1stPercentile\"), drop = FALSE]\nrownames(df2) <- paste0(\"E15.0:\", rownames(df2))\n\ndf3 <- clDataFB175[selected[[\"E17.5\"]], c(\"size\", \"X1stPercentile\"), drop = FALSE]\nrownames(df3) <- paste0(\"E17.5:\", rownames(df3))\n\nbaselineGDI <- rbind(df1, df2, df3)\ncolnames(baselineGDI) <- c(\"size\", \"GDI\")\n\nrm(clDataFB135, clDataFB150, clDataFB175)\nrm(df1, df2, df3)\n\nsaveRDS(baselineGDI,\n        file = file.path(outDir, \"ForebrainDorsal_ClusterizationMixing_BaselineGDI.RDS\"))\n```\n:::\n\n\n## Load baseline data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaselineGDI <- readRDS(file.path(outDir, \"ForebrainDorsal_ClusterizationMixing_BaselineGDI.RDS\"))\n\n# check good alignment of data\nassert_that(identical(rownames(baselineGDI), names(allClustersRawData)))\nassert_that(identical(baselineGDI[, \"size\"],\n                      vapply(allClustersRawData, ncol,\n                             FUN.VALUE = integer(1L), USE.NAMES = FALSE)))\n```\n:::\n\n\n## Calculate the GDI of the mixtures of clusters\n\n### This is to be run once per wanted *mixing-fraction*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# small run\n# \nset.seed(137)\n\nmixingFraction <- 0.80\nmixingStr <- str_pad(scales::label_percent()(mixingFraction), 3, pad = \"0\")\n\nresults <- data.frame()\n\nfor (mainName in rownames(baselineGDI)) {\n  mainSize <- baselineGDI[mainName, \"size\"]\n  mainGDI  <- baselineGDI[mainName, \"GDI\"]\n\n  for (clName in rownames(baselineGDI)) {\n    if (clName == mainName) next\n\n    logThis(paste(\"Mixing\", mainName, \"with extra\",\n                  mixingStr, \"cells from\", clName), logLevel = 1)\n\n    clSize <- baselineGDI[clName, \"size\"]\n    actuallyMixedCells <- min(ceiling(mixingFraction * mainSize), clSize)\n    actualFraction <- actuallyMixedCells / mainSize\n    sampleRawData <- allClustersRawData[[clName]][, sample(clSize, actuallyMixedCells)]\n    mergedRawData <- cbind(allClustersRawData[[mainName]], sampleRawData)\n    rm(sampleRawData)\n\n    # Calculate the merged COEX\n    cond <- paste0(mainName, \"|\", mixingStr, \"|\", clName)\n    mergedObj <- automaticCOTANObjectCreation(raw = mergedRawData,\n                                              GEO = \"MergedClusters\",\n                                              sequencingMethod = \"10X\",\n                                              sampleCondition = cond,\n                                              calcCoex = TRUE, cores = 10L,\n                                              saveObj = FALSE, outDir = outDir)\n    rm(mergedRawData)\n\n    # Extract the GDI quantile\n    mergedGDIData <- calculateGDI(mergedObj)\n    rm(mergedObj)\n\n    gdi <- mergedGDIData[[\"GDI\"]]\n    names(gdi) <- rownames(mergedGDIData)\n    rm(mergedGDIData)\n\n    gdi <- sort(gdi, decreasing = TRUE)\n    lastPercentile <- quantile(gdi, probs = 0.99)\n    rm(gdi)\n\n    results <- rbind(results,\n                     data.frame(\"MainCluster\" = mainName, \"OtherCluster\" = clName,\n                                \"MixingFraction\" = actualFraction, \"GDI\" = lastPercentile,\n                                \"GDIIncrement\" = lastPercentile - mainGDI))\n\n    logThis(paste(\"Mixing\", mainName, \"with\", clName,\n                  \"accomplished with GDI\", lastPercentile), logLevel = 1)\n  }\n}\n\nrownames(results) <- NULL\n\nsaveRDS(results, file.path(outDir, paste0(\"GDI_with_\", mixingStr, \"_Mixing.RDS\")))\n```\n:::\n\n\n## Load calculated data for analysis\n\n\n::: {.cell}\n\n:::\n\n\n## Merge all results and calculate the fitting regression for each cluster pair\n\n\n\n\n\n## Recall cluster distance and add it to the results\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#zeroOneAvg <- readRDS(file.path(inDir, \"ClustersDistances\", \"allZeroOne.RDS\"))\nzeroOneAvg <- readRDS(file.path(outDir, \"distanceZeroOne.RDS\"))\ndistZeroOne <- as.matrix(parDist(t(zeroOneAvg), method = \"hellinger\", diag = TRUE, upper = TRUE))^2\n\ndistZeroOneLong <- rownames_to_column(as.data.frame(distZeroOne), var = \"MainCluster\")\ndistZeroOneLong <-pivot_longer(distZeroOneLong,\n                               cols = !MainCluster,\n                               names_to = \"OtherCluster\", \n                               values_to = \"Distance\")\n\ndistZeroOneLong <- as.data.frame(distZeroOneLong[distZeroOneLong[[\"Distance\"]] != 0.0, ])\n\n#assert_that(identical(distZeroOneLong[, 1:2], resMix20[, 1:2]))\n\nperm <- order(distZeroOneLong[[\"Distance\"]])\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Scatter plot of the effective increment [Y] against estimated increment [X]\ndistDF <- cbind(distZeroOneLong[, \"Distance\", drop = FALSE],\n                sqrt(distZeroOneLong[, \"Distance\", drop = FALSE]))\ncolnames(distDF) <- c(\"Distance\", \"DistanceSqrt\")\n\nD2IPlot <- ggplot(cbind(resMix40, distDF),\n                  aes(x=Distance, y=GDIIncrement)) +\n             geom_point() +\n             geom_smooth(method=lm, formula = y ~ x) \n           # +  xlim(0, 1.5) + ylim(0, 1.5) + coord_fixed()\n\nplot(D2IPlot)\n```\n:::\n\n\n## Merge all data and plot it using *a-priory* (squared) distance as discriminant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallRes <- rbind(resMix05[perm, ], resMix10[perm, ], resMix20[perm, ], resMix40[perm, ], resMix80[perm, ])\nrownames(allRes) <- NULL\nallRes <- cbind(allRes, \"ClusterPair\" = rep.int(c(1:210),5))\nallRes <- cbind(allRes, \"Distance\" = rep(distZeroOneLong[[\"Distance\"]][perm], 5))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmg <- function(mixing) { ceiling(log2(round(mixing*40))) }\nIScPlot <- ggplot(allRes, aes(x=mg(MixingFraction), y=GDIIncrement, color=Distance,\n                              group = mg(MixingFraction))) +\n#  geom_point() +\n  geom_boxplot()\n#  scale_color_continuous(type = \"viridis\") +\n# geom_point(aes(size=log10(GDIIncrement+10))) +\n#  scale_x_log10()\n\nplot(IScPlot)\n```\n\n::: {.cell-output-display}\n![](ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nperm2 <- rep(1:210, each = 5) + rep(seq(1, 5 * 210, by = 210), times = 5) - 1\nallRes2 <- allRes[perm2, ]\n# c(1,44) - c(84,127) - c(167,210)\nILinesPLot <- ggplot(allRes2[allRes2[[\"ClusterPair\"]] %between% c(1,210), ],\n                     aes(x = MixingFraction, y = GDIIncrement,\n                         color = (ClusterPair - 1) %/% 42 + 0.5)) + \n  geom_path(aes(group = ClusterPair)) +\n  theme(legend.position = \"none\") +\n  #scale_x_log10() + \n  scale_colour_stepsn(colours = hcl.colors(5, palette = \"Dark 2\")[5:1])\n\n\nplot(ILinesPLot)\n```\n\n::: {.cell-output-display}\n![](ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n## Calculate the GDI of the mixtures of three clusters\n\n### the total mixture is 20%\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# small run\n# \nset.seed(137)\n\nnumPairsPerCluster <- 10\n\nmixingFraction <- 0.20\n\nresults <- data.frame()\n\nfor (mainName in rownames(baselineGDI)) {\n  mainSize <- baselineGDI[mainName, \"size\"]\n  mainGDI  <- baselineGDI[mainName, \"GDI\"]\n\n  executedPairs <- NULL\n  \n  for (i in c(1:numPairsPerCluster)) {\n    repeat {\n      clPair <- rownames(baselineGDI)[sample(nrow(baselineGDI), 2)]\n      clPair <- clPair[order(clPair)]\n      clPairName <- paste0(clPair[[1L]], \":\", clPair[[2L]])\n      if (!(mainName %in% clPair) && !(clPairName %in% executedPairs)) break\n    }\n\n    logThis(paste(\"Mixing\", mainName, \"with extra 20% cells from\",\n                  clPair[[1L]], \"and\", clPair[[2L]]), logLevel = 1)\n\n    mixingFraction1 <- runif(1L, 0.25 * mixingFraction, 0.75 * mixingFraction)\n    mixingFraction2 <- mixingFraction - mixingFraction1\n    \n    clSize1 <- baselineGDI[clPair[[1L]], \"size\"]\n    clSize2 <- baselineGDI[clPair[[2L]], \"size\"]\n    actuallyMixedCells1 <- min(ceiling(mixingFraction1 * mainSize), clSize1)\n    actuallyMixedCells2 <- min(ceiling(mixingFraction2 * mainSize), clSize2)\n    actualFraction1 <- actuallyMixedCells1 / mainSize\n    actualFraction2 <- actuallyMixedCells2 / mainSize\n    sampleRawData1 <- allClustersRawData[[clPair[[1L]]]][, sample(clSize1, actuallyMixedCells1)]\n    sampleRawData2 <- allClustersRawData[[clPair[[2L]]]][, sample(clSize2, actuallyMixedCells2)]\n    mergedRawData <- cbind(allClustersRawData[[mainName]], sampleRawData1, sampleRawData2)\n    rm(sampleRawData1, sampleRawData2)\n\n    # Calculate the merged COEX\n    cond <- paste0(mainName, \"|20%|\", clPairName)\n    mergedObj <- automaticCOTANObjectCreation(raw = mergedRawData,\n                                              GEO = \"MergedClusters\",\n                                              sequencingMethod = \"10X\",\n                                              sampleCondition = cond,\n                                              calcCoex = TRUE, cores = 10L,\n                                              saveObj = FALSE, outDir = outDir)\n    rm(mergedRawData)\n\n    # Extract the GDI quantile\n    mergedGDIData <- calculateGDI(mergedObj)\n    rm(mergedObj)\n\n    gdi <- mergedGDIData[[\"GDI\"]]\n    names(gdi) <- rownames(mergedGDIData)\n    rm(mergedGDIData)\n\n    gdi <- sort(gdi, decreasing = TRUE)\n    lastPercentile <- quantile(gdi, probs = 0.99)\n    rm(gdi)\n\n    results <- rbind(results,\n                     data.frame(\"MainCluster\" = mainName,\n                                \"OtherCluster1\" = clPair[[1L]],\n                                \"MixingFraction1\" = actualFraction1,\n                                \"OtherCluster2\" = clPair[[2L]],\n                                \"MixingFraction2\" = actualFraction2,\n                                \"GDI\" = lastPercentile,\n                                \"GDIIncrement\" = lastPercentile - mainGDI))\n\n    logThis(paste(\"Mixing\", mainName, \"with\", clPairName,\n                  \"accomplished with GDI\", lastPercentile), logLevel = 1)\n  }\n}\n\nrownames(results) <- NULL\n\nsaveRDS(results, file.path(outDir, paste0(\"GDI_with_20%_Mixing_from_Pairs.RDS\")))\n```\n:::\n\n\n## Estimate predicted `GDI` increment using resultts from two-clusters mixings\n\n### The estimates *assume* GDI increment proportional to mixture\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresMix20_2 <- readRDS(file.path(outDir, paste0(\"GDI_with_20%_Mixing_from_Pairs.RDS\")))\n\nresMix20_2 <- cbind(resMix20_2, NA)\ncolnames(resMix20_2)[ncol(resMix20_2)] <- \"PredictedGDIIncrement\"\n\nfor (r in c(1:nrow(resMix20_2))) {\n  mainName <- resMix20_2[r, \"MainCluster\"]\n  \n  mainMatch20 <- resMix20[resMix20[, \"MainCluster\"] == mainName, ]\n\n  pos1 <- which(mainMatch20[, \"OtherCluster\"] == resMix20_2[r, \"OtherCluster1\"])\n  pos2 <- which(mainMatch20[, \"OtherCluster\"] == resMix20_2[r, \"OtherCluster2\"])\n  \n  GDIIncr1 <- mainMatch20[pos1, \"GDIIncrement\"]\n  GDIIncr2 <- mainMatch20[pos2, \"GDIIncrement\"]\n\n  w1 <- resMix20_2[r, \"MixingFraction1\"] / mainMatch20[pos1, \"MixingFraction\"]\n  w2 <- resMix20_2[r, \"MixingFraction2\"] / mainMatch20[pos2, \"MixingFraction\"]\n  \n  predictedGDIIncr <- (w1 * GDIIncr1 + w2 * GDIIncr2)\n\n  resMix20_2[r, \"PredictedGDIIncrement\"] <- predictedGDIIncr\n}\n\nsaveRDS(resMix20_2, file.path(outDir, paste0(\"GDI_with_20%_Mixing_from_Pairs.RDS\")))\n```\n:::\n\n\n## Load calculated data for analysis\n\n\n::: {.cell}\n\n:::\n\n\n## Compare estimated vs real GDI increment\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Scatter plot of the effective increment [Y] against estimated increment [X]\npg <- ggplot(resMix20_2, aes(x=PredictedGDIIncrement, y=GDIIncrement)) +\n  geom_point() +\n  geom_smooth(method=lm, formula = y ~ x + 0) +\n  coord_fixed() +\n  xlim(0, 1.5) + ylim(0, 1.5)\n  #scale_x_log10() + scale_y_log10() \n\nplot(pg)\n```\n\n::: {.cell-output-display}\n![](ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nThe plot shows that having the 20% extraneous cells in the mixture coming from multiple clusters does not affect significantly the sensitivity of the GDI to score cluster uniformity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] tidyr_1.3.0        tibble_3.2.1       parallelDist_0.2.6 COTAN_2.3.0       \n [5] data.table_1.14.8  zeallot_0.1.0      ggplot2_3.4.2      scales_1.3.0      \n [9] rlang_1.1.1        assertthat_0.2.1  \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.21          splines_4.3.2            \n  [3] later_1.3.1               polyclip_1.10-4          \n  [5] fastDummies_1.7.3         lifecycle_1.0.3          \n  [7] doParallel_1.0.17         globals_0.16.2           \n  [9] lattice_0.22-5            MASS_7.3-60              \n [11] dendextend_1.17.1         magrittr_2.0.3           \n [13] plotly_4.10.2             rmarkdown_2.24           \n [15] yaml_2.3.7                httpuv_1.6.11            \n [17] Seurat_5.0.0              sctransform_0.4.1        \n [19] spam_2.10-0               askpass_1.2.0            \n [21] sp_2.1-1                  spatstat.sparse_3.0-2    \n [23] reticulate_1.34.0         cowplot_1.1.1            \n [25] pbapply_1.7-2             RColorBrewer_1.1-3       \n [27] abind_1.4-5               Rtsne_0.16               \n [29] purrr_1.0.1               BiocGenerics_0.46.0      \n [31] circlize_0.4.15           IRanges_2.34.1           \n [33] S4Vectors_0.38.1          ggrepel_0.9.3            \n [35] irlba_2.3.5.1             listenv_0.9.0            \n [37] spatstat.utils_3.0-3      umap_0.2.10.0            \n [39] goftest_1.2-3             RSpectra_0.16-1          \n [41] spatstat.random_3.2-1     dqrng_0.3.0              \n [43] fitdistrplus_1.1-11       parallelly_1.36.0        \n [45] DelayedMatrixStats_1.22.5 leiden_0.4.3             \n [47] codetools_0.2-19          DelayedArray_0.26.7      \n [49] tidyselect_1.2.0          shape_1.4.6              \n [51] farver_2.1.1              ScaledMatrix_1.8.1       \n [53] viridis_0.6.4             matrixStats_1.2.0        \n [55] stats4_4.3.2              spatstat.explore_3.2-1   \n [57] jsonlite_1.8.7            GetoptLong_1.0.5         \n [59] ellipsis_0.3.2            progressr_0.14.0         \n [61] ggridges_0.5.4            survival_3.5-7           \n [63] iterators_1.0.14          foreach_1.5.2            \n [65] tools_4.3.2               ica_1.0-3                \n [67] Rcpp_1.0.11               glue_1.6.2               \n [69] gridExtra_2.3             xfun_0.39                \n [71] mgcv_1.9-1                MatrixGenerics_1.12.3    \n [73] ggthemes_5.0.0            dplyr_1.1.2              \n [75] withr_2.5.0               fastmap_1.1.1            \n [77] fansi_1.0.4               openssl_2.1.0            \n [79] digest_0.6.33             rsvd_1.0.5               \n [81] R6_2.5.1                  mime_0.12                \n [83] colorspace_2.1-0          scattermore_1.2          \n [85] tensor_1.5                spatstat.data_3.0-1      \n [87] utf8_1.2.3                generics_0.1.3           \n [89] httr_1.4.6                htmlwidgets_1.6.2        \n [91] S4Arrays_1.2.0            uwot_0.1.16              \n [93] pkgconfig_2.0.3           gtable_0.3.3             \n [95] ComplexHeatmap_2.16.0     lmtest_0.9-40            \n [97] htmltools_0.5.7           dotCall64_1.1-0          \n [99] clue_0.3-64               SeuratObject_5.0.0       \n[101] png_0.1-8                 knitr_1.43               \n[103] rstudioapi_0.15.0         reshape2_1.4.4           \n[105] rjson_0.2.21              nlme_3.1-163             \n[107] zoo_1.8-12                GlobalOptions_0.1.2      \n[109] stringr_1.5.0             KernSmooth_2.23-22       \n[111] parallel_4.3.2            miniUI_0.1.1.1           \n[113] RcppZiggurat_0.1.6        pillar_1.9.0             \n[115] grid_4.3.2                vctrs_0.6.3              \n[117] RANN_2.6.1                promises_1.2.0.1         \n[119] BiocSingular_1.16.0       beachmat_2.16.0          \n[121] xtable_1.8-4              cluster_2.1.6            \n[123] evaluate_0.21             cli_3.6.1                \n[125] compiler_4.3.2            crayon_1.5.2             \n[127] future.apply_1.11.0       labeling_0.4.2           \n[129] plyr_1.8.8                stringi_1.8.1            \n[131] viridisLite_0.4.2         deldir_2.0-2             \n[133] BiocParallel_1.34.2       munsell_0.5.0            \n[135] lazyeval_0.2.2            spatstat.geom_3.2-4      \n[137] PCAtools_2.14.0           Matrix_1.6-3             \n[139] RcppHNSW_0.5.0            patchwork_1.1.2          \n[141] sparseMatrixStats_1.12.2  future_1.33.0            \n[143] shiny_1.8.0               ROCR_1.0-11              \n[145] Rfast_2.1.0               igraph_1.6.0             \n[147] RcppParallel_5.1.7       \n```\n:::\n:::\n",
    "supporting": [
      "ForebrainDorsal_MixingUniformClusters_ToEstimateGDISensitivity_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}