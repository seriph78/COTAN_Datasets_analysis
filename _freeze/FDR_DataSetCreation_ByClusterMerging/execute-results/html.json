{
  "hash": "8acc01b3dbfdc38adf94d7dc49f0b445",
  "result": {
    "markdown": "---\ntitle: \"False Discovery Rate: data-sets creation\"\nauthor: \"Marco Fantozzi\"\nformat: html\neditor: source\ndate: \"2024-02-10\"\n---\n\n\n## Preamble\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the libraries\nlibrary(stringr)\nlibrary(assertthat)\nlibrary(rlang)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(zeallot)\nlibrary(data.table)\nlibrary(COTAN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nassert_that(packageVersion(\"COTAN\") >= package_version(\"2.3.3\"),\n            msg = \"Error: The required version of the 'COTAN' library is 2.3.3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ninDir <- file.path(\"Data/MouseCortexFromLoom/\")\ninRawDataDir <- file.path(inDir, \"SingleClusterRawData/\")\n\noutDir <- file.path(\"Data/MouseCortexFromLoom/FDR/MergedClusters_For_FDR/\")\nif (!dir.exists(outDir)) {\n  dir.create(outDir)\n}\n\noutMergedRawDataDir <- outDir\nif (!dir.exists(outMergedRawDataDir)) {\n  dir.create(outMergedRawDataDir)\n}\n\noptions(parallelly.fork.enable = TRUE)\n\nsetLoggingLevel(2)\nsetLoggingFile(file.path(outDir, \"MixingClusters_FDR_ForebrainDorsal.log\"))\n```\n:::\n\n\n\n## Loading all COTAN Objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfb135Obj <- readRDS(file = file.path(inRawDataDir, \"e13.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb135Obj, datasetTags()[[\"cond\"]])\n\nfb150Obj <- readRDS(file = file.path(inRawDataDir, \"e15.0_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb150Obj, datasetTags()[[\"cond\"]])\n\nfb175Obj <- readRDS(file = file.path(inRawDataDir, \"e17.5_ForebrainDorsal.cotan.RDS\"))\ngetMetadataElement(fb175Obj, datasetTags()[[\"cond\"]])\n```\n:::\n\n\n## Relevant clusters lists\n\n\n::: {.cell}\n\n:::\n\n\n## Align clusters from different datasets\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallGenes <- union(union(getGenes(fb135Obj), getGenes(fb150Obj)), getGenes(fb175Obj))\n\n# This function completes the raw data so that the genes list\n# matches the `allGenes` above\nfillGenes <- function(m, prefixName) {\n  # find the missing genes in the given matrix m\n  missingGenes <- !(allGenes %in% rownames(m))\n  # create a matrix with the right sizes for the missing genes\n  # and set their values all to zero\n  fillM <- matrix(0, nrow = sum(missingGenes), ncol = ncol(m))\n  rownames(fillM) <- allGenes[missingGenes]\n  # append the new matrix to the original and reorder the rows\n  # to match overall genes order\n  retM <- rbind(m, fillM)\n  retM <- retM[allGenes, ]\n  # assign unique identifiers to the columns, so that one can discriminate\n  # the source even after merging with other matrices\n  colnames(retM) <- paste0(prefixName, \"_\", colnames(retM))\n  return(retM)\n}\n```\n:::\n\n\n## Create all raw data for each cluster compatible with the full genes' list\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallClustersRawData <- list()\nfor (dsName in names(relevant)) {\n  clList <- toClustersList(getClusters(objSelector(dsName),\n                                       clName = \"original.clusters\"))\n  for (clName in relevant[[dsName]]) {\n    fullName <- fullClusterName(dsName = dsName, clName = clName)\n    fullRawData <- fillGenes(getRawData(objSelector(dsName))[, clList[[clName]]],\n                             fullName)\n    allClustersRawData <- append(allClustersRawData, list(fullRawData))\n    names(allClustersRawData)[length(allClustersRawData)] <- fullName\n  }\n}\n\nassert_that(identical(rownames(allClustersRawData[[1]]), allGenes))\n\n# delete the COTAN objects\nrm(fb135Obj, fb150Obj, fb175Obj)\n```\n:::\n\n\n## Calculate ritz average for each cluster\n\n\n::: {.cell}\n\n:::\n\n\n## Parse selected clusters' collections\n\n\n::: {.cell}\n\n:::\n\n\n## Create merged clusters cells' collections\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(137L)\n\ncellsUsed <- as.data.frame(x = matrix(list(), ncol = 2 + length(allClustersRawData)))\n\nfor (i in (1:length(allComb))) {\n  metaGroup <- allComb[[i]]\n  metaMix <- allMixtures[[i]]\n  metaGroupName <- names(allComb)[[i]]\n  print(paste0(\"Meta: \", metaGroupName))\n  \n  for (j in 1:length(metaGroup)) {\n    group <- metaGroup[[j]]\n    groupMix <- metaMix[[j]]\n    groupName <- paste0(metaGroupName, \"_\", names(metaGroup)[[j]])\n    print(paste0(\"Group: \", groupName))\n\n    for (k in 1:length(group)) {\n      coll <- group[[k]]\n      mix <- groupMix[[k]]\n      collName <- paste0(groupName, \"_\", k)\n      print(paste0(\"Coll: \", collName))\n      \n      pos <- names(allClustersRawData) %in% coll\n      collRawData <- allClustersRawData[pos]\n      \n      len <- unlist(lapply(collRawData, ncol))\n      perm <- order(len, decreasing = TRUE)\n\n      ratios <- len[perm] / mix\n      \n      cellsToPickUp <- set_names(ceiling(mix * min(ratios)),\n                                 nm = names(len)[perm])\n\n      collAsStr <- paste0(coll[perm], collapse = \"_+_\")\n      \n      numUsedCells <- set_names(rep(0L, length(allClustersRawData)),\n                             nm = names(allClustersRawData))\n      numUsedCells[names(cellsToPickUp)] <- cellsToPickUp\n      \n      cellsUsed <- rbind(cellsUsed, c(groupName, collAsStr, numUsedCells))\n\n      mergedRawData <- data.frame(row.names = allGenes)\n      mergedClusters <- c()\n      for (clName in names(cellsToPickUp)) {\n        cells <- sample(colnames(allClustersRawData[[clName]]),\n                        size = cellsToPickUp[[clName]],\n                        replace = FALSE)\n        mergedClusters <- c(mergedClusters,\n                            rep.int(max(0, mergedClusters) + 1L,\n                                    times = length(cells)))\n        mergedRawData <- cbind(mergedRawData,\n                               as.data.frame(allClustersRawData[[clName]][, cells]))\n      }\n      names(mergedClusters) <- colnames(mergedRawData)\n      mergedClusters <- niceFactorLevels(mergedClusters)\n      \n      mergedObj <- automaticCOTANObjectCreation(mergedRawData,\n                                         GEO = groupName,\n                                         sequencingMethod = \"10X\",\n                                         sampleCondition = collAsStr,\n                                         calcCoex = FALSE,\n                                         cores = 5L,\n                                         saveObj = FALSE)\n      mergedObj <- addClusterization(mergedObj, clName = \"mergedClusters\",\n                                     clusters = mergedClusters,\n                                     override = FALSE)\n\n      lfcDF <- logFoldChangeOnClusters(mergedObj, clusters = mergedClusters)\n      mergedObj <- addClusterization(mergedObj,\n                                     clName = \"Contains_LogFoldChange\",\n                                     clusters = mergedClusters,\n                                     coexDF = lfcDF, override = FALSE)\n\n      outFileName <- file.path(outMergedRawDataDir,\n                               paste0(collName, \"_\", collAsStr, \".RDS\"))\n      print(outFileName)\n      saveRDS(mergedObj, file = outFileName)\n    }\n  }\n}\ncolnames(cellsUsed) <- c(\"Group\", \"Collection\", names(allClustersRawData))\n\nhead(cellsUsed, n = 10)\n\nwrite.csv(cellsUsed, file = file.path(outMergedRawDataDir, \"Cells_Usage_DataFrame.csv\"))\n```\n:::\n\n\n## Loader\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncellsUsed <- read.csv(file = file.path(outMergedRawDataDir, \"Cells_Usage_DataFrame.csv\"))\n\nnumTopGenes <- 100\n\nfor(i in (1:nrow(cellsUsed))) {\n  collName <- cellsUsed[i, \"Group\"]\n  collAsStr <- cellsUsed[i, \"Collection\"]\n  fileName <- file.path(outMergedRawDataDir,\n                        paste0(collName, \"_\", (i - 1) %% 3 + 1,\n                               \"_\", collAsStr, \".RDS\"))\n  print(paste(\"Analisys of\", collName, \"consisting of clusters\", collAsStr))\n  \n  obj <- readRDS(fileName)\n  \n  cm1DF <- findClustersMarkers(obj, n = numTopGenes, clName = \"mergedClusters\")\n  \n  lfcDF <- getClusterizationData(obj, clName = \"Contains_LogFoldChange\")[[\"coex\"]]\n\n  cm2DF <- as.data.frame(matrix(data = NA, nrow = 0L, ncol = 3L))\n  colnames(cm2DF) <- c(\"CL\", \"Gene\", \"LFC\")\n\n  for(cl in colnames(lfcDF)) {\n    for (type in c(\"min\", \"max\")) {\n        tmpDF <- as.data.frame(matrix(data = NA, nrow = numTopGenes, ncol = ncol(cm2DF)))\n        colnames(tmpDF) <- colnames(cm2DF)\n\n        # Get the first numTopGenes minimum/maximum scores for each cluster\n        sortedPos <- order(lfcDF[, cl], decreasing = (type == \"max\"))[1L:numTopGenes]\n  \n        tmpDF[[\"CL\"]]   <- cl\n        tmpDF[[\"Gene\"]] <- rownames(lfcDF)[sortedPos]\n        tmpDF[[\"LFC\"]]  <- lfcDF[sortedPos, cl]\n\n        cm2DF <- rbind(cm2DF, tmpDF)\n        rm(tmpDF)\n    }\n  }\n\n  assert_that(identical(cm1DF$CL, cm2DF$CL))\n  \n  print(\"fraction of matching genes per cluster\")\n  \n  ## to be finished, debugged...\n  for (bl in c(0:(nrow(cm1DF) %/% numTopGenes -1))) {\n    r <- bl * numTopGenes\n    genes1 <- cm1DF[(r + 1):(r + numTopGenes), \"Gene\"]\n    genes2 <- cm2DF[(r + 1):(r + numTopGenes), \"Gene\"]\n\n    msg <- paste0(\"Cluster \", cm1DF[r + 1, \"CL\"], \": \", \n                 100.0 * length(intersect(genes1, genes2)) / numTopGenes, \"%\")\n    print(msg)\n  }\n}\n```\n:::\n\n\n\n## Footer\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.6 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.3.3       data.table_1.15.0 zeallot_0.1.0     ggplot2_3.4.2    \n[5] scales_1.3.0      rlang_1.1.1       assertthat_0.2.1  stringr_1.5.0    \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3        rstudioapi_0.15.0        \n  [3] jsonlite_1.8.7            shape_1.4.6              \n  [5] umap_0.2.10.0             magrittr_2.0.3           \n  [7] spatstat.utils_3.0-3      rmarkdown_2.24           \n  [9] GlobalOptions_0.1.2       vctrs_0.6.3              \n [11] ROCR_1.0-11               spatstat.explore_3.2-1   \n [13] DelayedMatrixStats_1.22.5 askpass_1.2.0            \n [15] htmltools_0.5.7           S4Arrays_1.2.0           \n [17] sctransform_0.4.1         parallelly_1.36.0        \n [19] KernSmooth_2.23-22        htmlwidgets_1.6.2        \n [21] ica_1.0-3                 plyr_1.8.8               \n [23] plotly_4.10.2             zoo_1.8-12               \n [25] igraph_1.6.0              mime_0.12                \n [27] lifecycle_1.0.3           iterators_1.0.14         \n [29] pkgconfig_2.0.3           rsvd_1.0.5               \n [31] Matrix_1.6-3              R6_2.5.1                 \n [33] fastmap_1.1.1             MatrixGenerics_1.12.3    \n [35] fitdistrplus_1.1-11       future_1.33.0            \n [37] shiny_1.8.0               clue_0.3-64              \n [39] digest_0.6.33             colorspace_2.1-0         \n [41] patchwork_1.2.0           S4Vectors_0.38.1         \n [43] tensor_1.5                Seurat_5.0.0             \n [45] dqrng_0.3.0               RSpectra_0.16-1          \n [47] irlba_2.3.5.1             beachmat_2.16.0          \n [49] PCAtools_2.14.0           progressr_0.14.0         \n [51] RcppZiggurat_0.1.6        spatstat.sparse_3.0-2    \n [53] fansi_1.0.4               polyclip_1.10-4          \n [55] httr_1.4.6                abind_1.4-5              \n [57] compiler_4.3.2            withr_3.0.0              \n [59] doParallel_1.0.17         BiocParallel_1.34.2      \n [61] viridis_0.6.4             fastDummies_1.7.3        \n [63] dendextend_1.17.1         MASS_7.3-60              \n [65] openssl_2.1.0             DelayedArray_0.26.7      \n [67] rjson_0.2.21              tools_4.3.2              \n [69] lmtest_0.9-40             httpuv_1.6.11            \n [71] future.apply_1.11.0       goftest_1.2-3            \n [73] glue_1.7.0                nlme_3.1-163             \n [75] promises_1.2.0.1          grid_4.3.2               \n [77] Rtsne_0.16                cluster_2.1.6            \n [79] reshape2_1.4.4            generics_0.1.3           \n [81] spatstat.data_3.0-1       gtable_0.3.3             \n [83] tidyr_1.3.0               BiocSingular_1.16.0      \n [85] ScaledMatrix_1.8.1        sp_2.1-1                 \n [87] utf8_1.2.3                spatstat.geom_3.2-4      \n [89] BiocGenerics_0.46.0       RcppAnnoy_0.0.21         \n [91] ggrepel_0.9.3             RANN_2.6.1               \n [93] foreach_1.5.2             pillar_1.9.0             \n [95] spam_2.10-0               RcppHNSW_0.6.0           \n [97] later_1.3.1               circlize_0.4.15          \n [99] splines_4.3.2             dplyr_1.1.2              \n[101] lattice_0.22-5            deldir_2.0-2             \n[103] survival_3.5-7            tidyselect_1.2.0         \n[105] ComplexHeatmap_2.16.0     miniUI_0.1.1.1           \n[107] pbapply_1.7-2             knitr_1.43               \n[109] gridExtra_2.3             IRanges_2.34.1           \n[111] scattermore_1.2           stats4_4.3.2             \n[113] xfun_0.39                 matrixStats_1.2.0        \n[115] stringi_1.8.1             lazyeval_0.2.2           \n[117] yaml_2.3.7                evaluate_0.21            \n[119] codetools_0.2-19          tibble_3.2.1             \n[121] cli_3.6.1                 uwot_0.1.16              \n[123] RcppParallel_5.1.7        xtable_1.8-4             \n[125] reticulate_1.35.0         munsell_0.5.0            \n[127] Rcpp_1.0.11               spatstat.random_3.2-1    \n[129] globals_0.16.2            png_0.1-8                \n[131] parallel_4.3.2            Rfast_2.1.0              \n[133] ellipsis_0.3.2            dotCall64_1.1-0          \n[135] parallelDist_0.2.6        sparseMatrixStats_1.12.2 \n[137] listenv_0.9.0             ggthemes_5.0.0           \n[139] viridisLite_0.4.2         ggridges_0.5.4           \n[141] purrr_1.0.1               SeuratObject_5.0.0       \n[143] leiden_0.4.3              crayon_1.5.2             \n[145] GetoptLong_1.0.5          cowplot_1.1.1            \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}