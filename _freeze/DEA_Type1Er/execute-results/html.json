{
  "hash": "0e58bdad7513f29b427d3b117555d0c9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Differential expression analisys: type I error\"\nauthor: \"Silvia Giulia Galfr√®\"\ndate: \"2025-12-16\"\noutput: html_document\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(COTAN)\noptions(parallelly.fork.enable = TRUE)\nlibrary(Seurat)\nlibrary(monocle3)\nlibrary(reticulate)\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(viridis)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndirOut <- \"Results/TypeIError/\"\ndataSetDir <- \"Data/MouseCortexFromLoom/SingleClusterRawData/\"\n```\n:::\n\n\n\n\n### Automatic functions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCOTAN.DEA <- function(dataSet,clusters.list, GEO.code, sequencingMethod,sampleCondition, clName,dirOut,percentage){\n  obj <- automaticCOTANObjectCreation(raw = dataSet,\n                                      calcCoex = F,\n                                      cores = 10,\n                                      saveObj = F,\n                                      GEO = GEO.code,\n                                      sequencingMethod = sequencingMethod,\n                                      sampleCondition = sampleCondition)\n  obj <- addClusterization(obj,clName = clName,clusters = clusters.list)\n  \n  DF.DEA <- DEAOnClusters(obj,clName = clName )\n  pval.DEA <- pValueFromDEA(DF.DEA,numCells = getNumCells(obj))\n  adj.pval.DEA <- pval.DEA\n  for (col in colnames(pval.DEA)) {\n    adj.pval.DEA[,col] <- p.adjust(adj.pval.DEA[,col],method = \"bonferroni\")\n  }\n  n.genes.DEA <- sum(adj.pval.DEA < 0.05)\n  res <- list(\"n.genes.DEA\"=n.genes.DEA,\"DF.DEA\"=DF.DEA,\"adj.pval.DEA\" = adj.pval.DEA)\n  \n  write.csv(res$adj.pval.DEA, file = paste0(dirOut,clName,\"_de_genes_COTAN_\",percentage,\".csv\"))\n  \n  return(res)\n\n}\n\nSeurat.DEA <- function(dataSet,clusters.list, project, dirOut,percentage){\n  pbmc <- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  stopifnot(length(clusters.list)==length(pbmc$orig.ident))\n  \n  \n  pbmc <- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n  pbmc <- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n  all.genes <- rownames(pbmc)\n  pbmc <- ScaleData(pbmc, features = all.genes)\n  \n  pbmc <- RunPCA(pbmc)\n  pbmc <- RunUMAP(pbmc, dims = 1:20)\n  \n  pbmc@meta.data$TestCl <- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl <- factor(clusters.list)\n  \n  pbmc <- SetIdent(pbmc,value = \"TestCl\")\n  \n  pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE)\n  \n  \n  \n  n.genes.DEA <- sum(pbmc.markers$p_val_adj < 0.05)\n  \n  print(n.genes.DEA)\n  \n  write.csv(pbmc.markers, file = paste0(dirOut,project,\"_de_genes_Seurat_\",percentage,\".csv\"))\n  \n  return(list(\"n.genes.DEA\"=n.genes.DEA,\"markers\"= pbmc.markers))\n  }\n\nMonocle.DEA <- function(dataSet,clusters.list,project, dirOut,percentage){\n  \n  cell_metadata = as.data.frame(clusters.list[colnames(dataSet)])\n  colnames(cell_metadata) <- \"Clusters\"\n  cds <- new_cell_data_set(dataSet[rowSums(dataSet) > 3,],\n                         cell_metadata = cell_metadata\n                         )\n  colData(cds)$cluster <- clusters.list[rownames(colData(cds))]\n\n  #cds <- preprocess_cds(cds, num_dim = 100)\n  #cds <- reduce_dimension(cds)\n  #cds <- cluster_cells(cds, resolution=1e-5)\n\n  marker_test_res <- top_markers(cds, \n                                 group_cells_by=\"Clusters\", \n                                 genes_to_test_per_group = dim(cds)[1],\n                                  cores=10)\n  \n  # de_results <- fit_models(cds,model_formula_str = \" ~ cluster\",cores = 10,verbose = T)\n  # fit_coefs <- coefficient_table(de_results)\n  # \n  # fit_coefs <- fit_coefs %>% filter(term == \"cluster\")\n  \n  write.csv(marker_test_res, file = paste0(dirOut,project,\"_de_genes_Monocle_\",percentage,\".csv\"))\n  \n  # return(list(\"n.genes.DEA\"=sum(fit_coefs$q_value < 0.05, na.rm = T),\n  #             \"fit_coefs\"= fit_coefs,\n  #             \"de_results\"=de_results))\n  return(list(\"n.genes.DEA\"=sum(marker_test_res$marker_test_q_value < 0.05, na.rm = T),\n              \"marker_test_res\"= marker_test_res\n              ))\n}\n\n\nScanPy.DEA <- function(dataSet,\n                       clusters.list, \n                       project, \n                       dirOut,\n                       percentage){\n  pbmc <- CreateSeuratObject(counts = dataSet, project = project, min.cells = 3, min.features = 20)\n  \n  \n  pbmc@meta.data$TestCl <- NA\n  pbmc@meta.data[names(clusters.list),]$TestCl <- clusters.list\n  \n  exprs <- pbmc@assays$RNA$counts\n  \n  meta <- pbmc[[]]\n  #feature_meta <- GetAssay(pbmc)[[]]\n  tmp <- as.data.frame(matrix(data = NA, \n                              ncol = 1, \n                              nrow = nrow(pbmc@assays$RNA$counts)))\n  rownames(tmp) <- rownames(pbmc@assays$RNA$counts)\n  \n  feature_meta <- tmp\n  #embedding <- Embeddings(pbmc, \"umap\")\n  \n  Sys.setenv(RETICULATE_PYTHON = \"../../../bin/python3\")\n  py <- import(\"sys\")\n  \n  source_python(\"src/scanpyTypeIError.py\")\n  scanpyTypeIError(exprs, \n                   meta, \n                   feature_meta, \n                   \"mt\", \n                   dirOut, \n                   percentage,project)\n\n  out <- read.csv(file = paste0(dirOut,\n                                project,\n                                \"_Scanpy_de_genes_\",\n                                percentage,\n                                \".csv\"),\n                  header = T, \n                  row.names = 1)\n  \n  gc()\n\n  return(out)\n}\n```\n:::\n\n\n\n\nWe would evaluate the Type I error and to do so, we consider some transcriptionally uniform clusters from the Loom dataset. We splitted these cluster in two partitions (with three different dimensions: 1/2, 1/3 and 1/4) one containing the cells with higher library size and the other with the lower library size. On these two clusters we than tested the four different software.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (perc in c(0.75)) { #0.5, 0.33, 0.25,0.67, \n  outPutMatrix <- as.data.frame(matrix(nrow = 1,ncol = 4))\n  colnames(outPutMatrix) <- c(\"COTAN\",\"Seurat\", \"Monocle\", \"Scanpy\")\n\n  for (dataSet in list.files(dataSetDir)) {\n  \n    cluster.name <- str_split(dataSet,pattern = \"_\", simplify = T)[1]\n    \n    print(cluster.name)\n    outTemp <- NA\n     \n    dataSet <- readRDS(paste0(dataSetDir,dataSet))\n    \n\n    cl1 <- colnames(dataSet)[order(colSums(dataSet),decreasing = T)[1:round(ncol(dataSet)*perc,digits = 0)]]\n    \n    clusters.list <- list(\"cl1\"=cl1,\n                          \"cl2\"=colnames(dataSet)[!colnames(dataSet) %in% cl1])\n  \n    clusters.list <- setNames(rep(1,ncol(dataSet)),\n                              colnames(dataSet))\n    clusters.list[colnames(dataSet)[!colnames(dataSet) %in% cl1]] <- 2 \n  \n    cotan.dea.out <- COTAN.DEA(dataSet = dataSet,\n                               clusters.list = clusters.list,\n                               GEO.code = \"\",\n                               sequencingMethod = \"10x\",\n                               sampleCondition = \"Temp\",\n                               clName =  cluster.name,\n                               dirOut, percentage = perc)\n  \n    outTemp <- c(outTemp,cotan.dea.out$n.genes.DEA)\n    \n    rm(cotan.dea.out)\n    gc()\n  \n    seurat.dea.out <- Seurat.DEA(dataSet = dataSet,\n                               clusters.list = clusters.list,\n                               project = cluster.name,\n                               dirOut, percentage = perc)\n  \n    outTemp <- c(outTemp,seurat.dea.out$n.genes.DEA)\n    \n    rm(seurat.dea.out)\n    gc()\n  \n  \n    monocle.dea.out <- Monocle.DEA(dataSet = dataSet,\n                                   clusters.list = clusters.list,\n                                   project = cluster.name,\n                                   dirOut = dirOut, percentage = perc)\n  \n    outTemp <- c(outTemp,monocle.dea.out$n.genes.DEA)\n    rm(monocle.dea.out)\n    gc()\n  \n    ScanPy.dea.out <- ScanPy.DEA(dataSet = dataSet, \n                                 clusters.list = clusters.list, \n                                 project = cluster.name, \n                                 dirOut = dirOut, percentage = perc\n                                  )\n    \n  \n    ScanPy.dea.out.filterd <- ScanPy.dea.out[ScanPy.dea.out$pval_adj < 0.05\n                                             & ScanPy.dea.out$clusters == \"cl1.0\",]\n    \n    outTemp <- c(outTemp,dim(ScanPy.dea.out.filterd)[1])\n    rm(ScanPy.dea.out.filterd)\n    gc()\n    \n    outTemp <- outTemp[2:length(outTemp)]\n    \n    outPutMatrix <- rbind(outPutMatrix,outTemp)\n    rownames(outPutMatrix)[nrow(outPutMatrix)] <- cluster.name\n    \n    write.csv(outPutMatrix,paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n  }\n  \n  outPutMatrix <-   outPutMatrix[2:nrow(outPutMatrix),]\n  write.csv(outPutMatrix,paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n\n}\n```\n:::\n\n\n\n\n### Summarize the output\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods.color <- c(\"COTAN\"=\"#F73604\",\"Seurat\"=\"#ABD9E9\",\"Seurat_scTr\"=\"#74ADD1\",\"Seurat_Bimod\"=\"#4575B4\", \"Monocle\"=\"#DAABE9\", \"Scanpy\"=\"#7F9B5C\" )\ndf_plot <- NA\nfor (perc in c(0.5, 0.33, 0.25,0.67, 0.75)) {\n  outPutMatrix <- read.csv(paste0(dirOut,\"Complete_outPut_\",perc,\".csv\"))\n  \n  outPutMatrix$Division <- perc\n  \n  df_plot <- rbind(df_plot,outPutMatrix)\n  \n}\ndf_plot <- df_plot[2:nrow(df_plot),]\n\ndf_plot <- as.data.frame(pivot_longer(df_plot,cols = c(2:5),values_to = \"N.Genes\",names_to = \"Method\"))\n\ndf_plot[df_plot$Method == \"Cotan\",]$Method <- \"COTAN\"\ndf_plot[df_plot$Method == \"ScanPy\",]$Method <- \"Scanpy\"\n\n\ntypeIerrorPlot <- ggplot(df_plot,aes(x = Method, y=N.Genes,fill=Method))+geom_boxplot(outliers = F)+\nscale_fill_manual(\n    values = methods.color)+ facet_wrap(~Division,scales = \"free\",nrow = 1)+\n    geom_jitter(color=\"black\",  alpha=0.5,width = 0.2) +\n    theme_light()+\n    theme(axis.text.x=element_blank(),axis.title.x=element_blank(),\n      legend.position=\"bottom\",\n      plot.title = element_text(size=11)\n    )\n\npdf(paste0(dirOut,\"Type1ErrorPlot.pdf\"),height = 3,width = 15)\n\nplot(typeIerrorPlot)\ndev.off()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npng \n  2 \n```\n\n\n:::\n\n```{.r .cell-code}\nplot(typeIerrorPlot)\n```\n\n::: {.cell-output-display}\n![](DEA_Type1Er_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.2 (2025-10-31)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: Europe/Rome\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n [1] viridis_0.6.5               viridisLite_0.4.2          \n [3] ggplot2_3.5.2               tidyr_1.3.1                \n [5] dplyr_1.1.4                 stringr_1.5.1              \n [7] reticulate_1.42.0           monocle3_1.3.7             \n [9] SingleCellExperiment_1.30.0 SummarizedExperiment_1.38.1\n[11] GenomicRanges_1.60.0        GenomeInfoDb_1.44.0        \n[13] IRanges_2.42.0              S4Vectors_0.46.0           \n[15] MatrixGenerics_1.20.0       matrixStats_1.5.0          \n[17] Biobase_2.68.0              BiocGenerics_0.54.0        \n[19] generics_0.1.3              Seurat_5.2.1               \n[21] SeuratObject_5.1.0          sp_2.2-0                   \n[23] COTAN_2.9.4                \n\nloaded via a namespace (and not attached):\n  [1] RcppAnnoy_0.0.22        splines_4.5.2           later_1.4.2            \n  [4] tibble_3.3.0            polyclip_1.10-7         fastDummies_1.7.5      \n  [7] lifecycle_1.0.4         Rdpack_2.6.4            doParallel_1.0.17      \n [10] globals_0.18.0          lattice_0.22-7          MASS_7.3-65            \n [13] dendextend_1.19.0       magrittr_2.0.3          plotly_4.11.0          \n [16] rmarkdown_2.29          yaml_2.3.10             httpuv_1.6.16          \n [19] sctransform_0.4.2       spam_2.11-1             spatstat.sparse_3.1-0  \n [22] cowplot_1.1.3           pbapply_1.7-2           minqa_1.2.8            \n [25] RColorBrewer_1.1-3      abind_1.4-8             Rtsne_0.17             \n [28] purrr_1.0.4             circlize_0.4.16         GenomeInfoDbData_1.2.14\n [31] ggrepel_0.9.6           irlba_2.3.5.1           listenv_0.9.1          \n [34] spatstat.utils_3.1-4    goftest_1.2-3           RSpectra_0.16-2        \n [37] spatstat.random_3.4-1   fitdistrplus_1.2-2      parallelly_1.45.0      \n [40] codetools_0.2-20        DelayedArray_0.34.1     tidyselect_1.2.1       \n [43] shape_1.4.6.1           UCSC.utils_1.4.0        farver_2.1.2           \n [46] lme4_1.1-37             ScaledMatrix_1.16.0     spatstat.explore_3.4-2 \n [49] jsonlite_2.0.0          GetoptLong_1.0.5        gghalves_0.1.4         \n [52] progressr_0.15.1        ggridges_0.5.6          survival_3.8-3         \n [55] iterators_1.0.14        foreach_1.5.2           tools_4.5.2            \n [58] ica_1.0-3               Rcpp_1.0.14             glue_1.8.0             \n [61] gridExtra_2.3           SparseArray_1.8.0       xfun_0.52              \n [64] ggthemes_5.1.0          withr_3.0.2             fastmap_1.2.0          \n [67] boot_1.3-32             digest_0.6.37           rsvd_1.0.5             \n [70] parallelDist_0.2.6      R6_2.6.1                mime_0.13              \n [73] colorspace_2.1-1        scattermore_1.2         tensor_1.5             \n [76] spatstat.data_3.1-6     data.table_1.17.0       httr_1.4.7             \n [79] htmlwidgets_1.6.4       S4Arrays_1.8.0          uwot_0.2.3             \n [82] pkgconfig_2.0.3         gtable_0.3.6            ComplexHeatmap_2.24.0  \n [85] lmtest_0.9-40           XVector_0.48.0          htmltools_0.5.8.1      \n [88] dotCall64_1.2           zigg_0.0.2              clue_0.3-66            \n [91] scales_1.4.0            png_0.1-8               reformulas_0.4.1       \n [94] spatstat.univar_3.1-3   knitr_1.50              reshape2_1.4.4         \n [97] rjson_0.2.23            nloptr_2.2.1            nlme_3.1-168           \n[100] proxy_0.4-27            zoo_1.8-14              GlobalOptions_0.1.2    \n[103] KernSmooth_2.23-26      parallel_4.5.2          miniUI_0.1.2           \n[106] pillar_1.10.2           grid_4.5.2              vctrs_0.6.5            \n[109] RANN_2.6.2              promises_1.3.2          BiocSingular_1.24.0    \n[112] beachmat_2.24.0         xtable_1.8-4            cluster_2.1.8.1        \n[115] evaluate_1.0.3          zeallot_0.2.0           cli_3.6.5              \n[118] compiler_4.5.2          rlang_1.1.6             crayon_1.5.3           \n[121] future.apply_1.20.0     labeling_0.4.3          plyr_1.8.9             \n[124] stringi_1.8.7           deldir_2.0-4            BiocParallel_1.42.0    \n[127] assertthat_0.2.1        lazyeval_0.2.2          spatstat.geom_3.4-1    \n[130] Matrix_1.7-4            RcppHNSW_0.6.0          patchwork_1.3.0        \n[133] future_1.58.0           shiny_1.11.0            rbibutils_2.3          \n[136] ROCR_1.0-11             Rfast_2.1.5.1           igraph_2.1.4           \n[139] RcppParallel_5.1.10    \n```\n\n\n:::\n:::\n",
    "supporting": [
      "DEA_Type1Er_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}